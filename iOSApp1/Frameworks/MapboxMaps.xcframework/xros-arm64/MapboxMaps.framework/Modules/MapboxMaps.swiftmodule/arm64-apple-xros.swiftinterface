// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-xros1.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MapboxMaps
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CoreFoundation.CFCGTypes
import CoreImage.CIFilterBuiltins
import CoreLocation.CLLocation
import Combine
import CoreFoundation
import CoreGraphics
import CoreImage
import CoreLocation
import DeveloperToolsSupport
import Dispatch
import Foundation
import MapboxCommon.MBXCoordinate2D
@_exported import MapboxCommon
@_exported import MapboxCoreMaps
@_exported import MapboxMaps
import Metal
import MetalKit
import QuartzCore
import RegexBuilder
import Swift
import SwiftUI
@_exported import Turf
import UIKit.UIGeometry
import UIKit.UIGestureRecognizerSubclass
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
extension MapboxMaps.Expression {
  public struct Operator : Swift.RawRepresentable, Swift.Codable, Swift.Equatable {
    public static let subtract: MapboxMaps.Expression.Operator
    public static let not: MapboxMaps.Expression.Operator
    public static let neq: MapboxMaps.Expression.Operator
    public static let product: MapboxMaps.Expression.Operator
    public static let division: MapboxMaps.Expression.Operator
    public static let mod: MapboxMaps.Expression.Operator
    public static let pow: MapboxMaps.Expression.Operator
    public static let sum: MapboxMaps.Expression.Operator
    public static let lt: MapboxMaps.Expression.Operator
    public static let lte: MapboxMaps.Expression.Operator
    public static let eq: MapboxMaps.Expression.Operator
    public static let gt: MapboxMaps.Expression.Operator
    public static let gte: MapboxMaps.Expression.Operator
    public static let abs: MapboxMaps.Expression.Operator
    public static let accumulated: MapboxMaps.Expression.Operator
    public static let acos: MapboxMaps.Expression.Operator
    public static let all: MapboxMaps.Expression.Operator
    public static let any: MapboxMaps.Expression.Operator
    public static let array: MapboxMaps.Expression.Operator
    public static let asin: MapboxMaps.Expression.Operator
    public static let at: MapboxMaps.Expression.Operator
    public static let atan: MapboxMaps.Expression.Operator
    public static let boolean: MapboxMaps.Expression.Operator
    public static let switchCase: MapboxMaps.Expression.Operator
    public static let ceil: MapboxMaps.Expression.Operator
    public static let coalesce: MapboxMaps.Expression.Operator
    public static let collator: MapboxMaps.Expression.Operator
    public static let concat: MapboxMaps.Expression.Operator
    public static let config: MapboxMaps.Expression.Operator
    public static let cos: MapboxMaps.Expression.Operator
    public static let distance: MapboxMaps.Expression.Operator
    public static let distanceFromCenter: MapboxMaps.Expression.Operator
    public static let downcase: MapboxMaps.Expression.Operator
    public static let e: MapboxMaps.Expression.Operator
    public static let featureState: MapboxMaps.Expression.Operator
    public static let floor: MapboxMaps.Expression.Operator
    public static let format: MapboxMaps.Expression.Operator
    public static let geometryType: MapboxMaps.Expression.Operator
    public static let get: MapboxMaps.Expression.Operator
    public static let has: MapboxMaps.Expression.Operator
    public static let heatmapDensity: MapboxMaps.Expression.Operator
    public static let hsl: MapboxMaps.Expression.Operator
    public static let hsla: MapboxMaps.Expression.Operator
    public static let id: MapboxMaps.Expression.Operator
    public static let image: MapboxMaps.Expression.Operator
    public static let inExpression: MapboxMaps.Expression.Operator
    public static let indexOf: MapboxMaps.Expression.Operator
    public static let interpolate: MapboxMaps.Expression.Operator
    public static let isSupportedScript: MapboxMaps.Expression.Operator
    public static let length: MapboxMaps.Expression.Operator
    public static let letExpression: MapboxMaps.Expression.Operator
    public static let lineProgress: MapboxMaps.Expression.Operator
    public static let literal: MapboxMaps.Expression.Operator
    public static let ln: MapboxMaps.Expression.Operator
    public static let ln2: MapboxMaps.Expression.Operator
    public static let log10: MapboxMaps.Expression.Operator
    public static let log2: MapboxMaps.Expression.Operator
    public static let match: MapboxMaps.Expression.Operator
    public static let max: MapboxMaps.Expression.Operator
    public static let measureLight: MapboxMaps.Expression.Operator
    public static let min: MapboxMaps.Expression.Operator
    public static let number: MapboxMaps.Expression.Operator
    public static let numberFormat: MapboxMaps.Expression.Operator
    public static let objectExpression: MapboxMaps.Expression.Operator
    public static let pi: MapboxMaps.Expression.Operator
    public static let pitch: MapboxMaps.Expression.Operator
    public static let properties: MapboxMaps.Expression.Operator
    public static let random: MapboxMaps.Expression.Operator
    public static let rasterParticleSpeed: MapboxMaps.Expression.Operator
    public static let rasterValue: MapboxMaps.Expression.Operator
    public static let resolvedLocale: MapboxMaps.Expression.Operator
    public static let rgb: MapboxMaps.Expression.Operator
    public static let rgba: MapboxMaps.Expression.Operator
    public static let round: MapboxMaps.Expression.Operator
    public static let sin: MapboxMaps.Expression.Operator
    public static let skyRadialProgress: MapboxMaps.Expression.Operator
    public static let slice: MapboxMaps.Expression.Operator
    public static let sqrt: MapboxMaps.Expression.Operator
    public static let step: MapboxMaps.Expression.Operator
    public static let string: MapboxMaps.Expression.Operator
    public static let tan: MapboxMaps.Expression.Operator
    public static let toBoolean: MapboxMaps.Expression.Operator
    public static let toColor: MapboxMaps.Expression.Operator
    public static let toNumber: MapboxMaps.Expression.Operator
    public static let toRgba: MapboxMaps.Expression.Operator
    public static let toString: MapboxMaps.Expression.Operator
    public static let typeofExpression: MapboxMaps.Expression.Operator
    public static let upcase: MapboxMaps.Expression.Operator
    public static let varExpression: MapboxMaps.Expression.Operator
    public static let within: MapboxMaps.Expression.Operator
    public static let zoom: MapboxMaps.Expression.Operator
    public static let linear: MapboxMaps.Expression.Operator
    public static let exponential: MapboxMaps.Expression.Operator
    public static let cubicBezier: MapboxMaps.Expression.Operator
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public struct AmbientLight : Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public let id: Swift.String
  public let type: MapboxMaps.LightType
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var intensity: MapboxMaps.Value<Swift.Double>?
  public var intensityTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String = UUID().uuidString)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.AmbientLight, b: MapboxMaps.AmbientLight) -> Swift.Bool
}
extension MapboxMaps.AmbientLight {
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func intensity(_ constant: Swift.Double) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func intensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func intensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.AmbientLight
}
public typealias AnimationCompletion = (UIKit.UIViewAnimatingPosition) -> Swift.Void
public struct AnimationOwner : Swift.RawRepresentable, Swift.Equatable {
  public typealias RawValue = Swift.String
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let gestures: MapboxMaps.AnimationOwner
  public static let unspecified: MapboxMaps.AnimationOwner
  public static let compass: MapboxMaps.AnimationOwner
}
public struct AnnotatedFeature : Swift.Equatable {
  public struct LayerFeature : Swift.Equatable {
    public var layerId: Swift.String
    public var featureId: Swift.String?
    public static func == (a: MapboxMaps.AnnotatedFeature.LayerFeature, b: MapboxMaps.AnnotatedFeature.LayerFeature) -> Swift.Bool
  }
  public var geometry: MapboxMaps.Geometry?
  public var layerFeature: MapboxMaps.AnnotatedFeature.LayerFeature?
  public static func layerFeature(layerId: Swift.String, featureId: Swift.String? = nil) -> MapboxMaps.AnnotatedFeature
  public static func geometry(_ geometry: any Turf.GeometryConvertible) -> MapboxMaps.AnnotatedFeature
  public static func == (a: MapboxMaps.AnnotatedFeature, b: MapboxMaps.AnnotatedFeature) -> Swift.Bool
}
public protocol Annotation {
  var id: Swift.String { get }
  var geometry: MapboxMaps.Geometry { get }
  @available(*, deprecated, message: "Will be deleted in future, for Mapbox-provided annotations see customData instead.")
  var userInfo: [Swift.String : Any]? { get set }
}
public struct AnnotationClusterGestureContext : Swift.Equatable {
  public var point: CoreFoundation.CGPoint
  public var coordinate: CoreLocation.CLLocationCoordinate2D
  public let expansionZoom: CoreFoundation.CGFloat?
  public static func == (a: MapboxMaps.AnnotationClusterGestureContext, b: MapboxMaps.AnnotationClusterGestureContext) -> Swift.Bool
}
extension MapboxMaps.PointAnnotation {
  public struct Image : Swift.Hashable {
    public var image: UIKit.UIImage
    public var name: Swift.String
    public init(image: UIKit.UIImage, name: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: MapboxMaps.PointAnnotation.Image, b: MapboxMaps.PointAnnotation.Image) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol AnnotationManager : AnyObject {
  var id: Swift.String { get }
  var sourceId: Swift.String { get }
  var layerId: Swift.String { get }
  var slot: Swift.String? { get set }
}
public protocol AnnotationInteractionDelegate : AnyObject {
  func annotationManager(_ manager: any MapboxMaps.AnnotationManager, didDetectTappedAnnotations annotations: [any MapboxMaps.Annotation])
}
@_hasMissingDesignatedInitializers final public class AnnotationOrchestrator {
  final public var annotationManagersById: [Swift.String : any MapboxMaps.AnnotationManager] {
    get
  }
  final public func makePointAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil, clusterOptions: MapboxMaps.ClusterOptions? = nil, onClusterTap: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)? = nil, onClusterLongPress: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)? = nil) -> MapboxMaps.PointAnnotationManager
  final public func makePolygonAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil) -> MapboxMaps.PolygonAnnotationManager
  final public func makePolylineAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil) -> MapboxMaps.PolylineAnnotationManager
  final public func makeCircleAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil) -> MapboxMaps.CircleAnnotationManager
  final public func removeAnnotationManager(withId id: Swift.String)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MapboxMaps.AnyCancelable {
  public func store(in set: inout Swift.Set<Combine.AnyCancellable>)
  public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == Combine.AnyCancellable
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.AnyCancellable {
  final public func store(in set: inout Swift.Set<MapboxMaps.AnyCancelable>)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  final public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == MapboxMaps.AnyCancelable
}
public class AnyCancelable : MapboxCommon.Cancelable {
  public init(_ closure: @escaping () -> Swift.Void)
  convenience public init<C>(_ canceler: C) where C : MapboxCommon.Cancelable
  convenience public init<S>(_ sequence: S) where S : Swift.Sequence, S.Element : MapboxCommon.Cancelable
  @objc public func cancel()
  @objc deinit
}
extension MapboxMaps.AnyCancelable : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: MapboxMaps.AnyCancelable, rhs: MapboxMaps.AnyCancelable) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxMaps.AnyCancelable {
  public func store(in set: inout Swift.Set<MapboxMaps.AnyCancelable>)
  public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == MapboxMaps.AnyCancelable
}
public protocol AppleLocationProviderDelegate : AnyObject {
  func appleLocationProvider(_ locationProvider: MapboxMaps.AppleLocationProvider, didFailWithError error: any Swift.Error)
  func appleLocationProvider(_ locationProvider: MapboxMaps.AppleLocationProvider, didChangeAccuracyAuthorization accuracyAuthorization: CoreLocation.CLAccuracyAuthorization)
  func appleLocationProviderShouldDisplayHeadingCalibration(_ locationProvider: MapboxMaps.AppleLocationProvider) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class AppleLocationProvider {
  public struct Options : Swift.Equatable {
    public var distanceFilter: CoreLocation.CLLocationDistance
    public var desiredAccuracy: CoreLocation.CLLocationAccuracy
    public var activityType: CoreLocation.CLActivityType
    public init(distanceFilter: CoreLocation.CLLocationDistance = kCLDistanceFilterNone, desiredAccuracy: CoreLocation.CLLocationAccuracy = kCLLocationAccuracyBest, activityType: CoreLocation.CLActivityType = .other)
    public static func == (a: MapboxMaps.AppleLocationProvider.Options, b: MapboxMaps.AppleLocationProvider.Options) -> Swift.Bool
  }
  final public var options: MapboxMaps.AppleLocationProvider.Options {
    get
    set
  }
  weak final public var delegate: (any MapboxMaps.AppleLocationProviderDelegate)?
  final public var onLocationUpdate: MapboxMaps.Signal<[MapboxCommon.Location]> {
    get
  }
  @available(visionOS, unavailable)
  final public var onHeadingUpdate: MapboxMaps.Signal<MapboxMaps.Heading> {
    get
  }
  final public var latestLocation: MapboxCommon.Location? {
    get
  }
  convenience public init()
  @objc deinit
  @available(iOS 14.0, *)
  final public func requestTemporaryFullAccuracyAuthorization(withPurposeKey purposeKey: Swift.String)
}
extension MapboxMaps.AppleLocationProvider : MapboxCommon.LocationProvider {
  @objc final public func getLastObservedLocation() -> MapboxCommon.Location?
  @objc final public func addLocationObserver(for observer: any MapboxCommon.LocationObserver)
  @objc final public func removeLocationObserver(for observer: any MapboxCommon.LocationObserver)
}
@available(visionOS, unavailable)
extension MapboxMaps.AppleLocationProvider : MapboxMaps.HeadingProvider {
  @available(visionOS, unavailable)
  final public var latestHeading: MapboxMaps.Heading? {
    get
  }
  @available(visionOS, unavailable)
  final public func add(headingObserver: any MapboxMaps.HeadingObserver)
  @available(visionOS, unavailable)
  final public func remove(headingObserver: any MapboxMaps.HeadingObserver)
}
extension MapboxMaps.AppleLocationProvider {
  final public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
  final public func locationManager(_ manager: CoreLocation.CLLocationManager, didFailWithError error: any Swift.Error)
  final public func locationManagerDidChangeAuthorization(_ manager: CoreLocation.CLLocationManager)
  final public func locationManagerShouldDisplayHeadingCalibration(_ manager: CoreLocation.CLLocationManager) -> Swift.Bool
}
public struct Atmosphere : Swift.Codable, Swift.Equatable {
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var highColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var highColorTransition: MapboxMaps.StyleTransition?
  public var horizonBlend: MapboxMaps.Value<Swift.Double>?
  public var horizonBlendTransition: MapboxMaps.StyleTransition?
  public var range: MapboxMaps.Value<[Swift.Double]>?
  public var rangeTransition: MapboxMaps.StyleTransition?
  public var spaceColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var spaceColorTransition: MapboxMaps.StyleTransition?
  public var starIntensity: MapboxMaps.Value<Swift.Double>?
  public var starIntensityTransition: MapboxMaps.StyleTransition?
  public var verticalRange: MapboxMaps.Value<[Swift.Double]>?
  public var verticalRangeTransition: MapboxMaps.StyleTransition?
  public init()
  public static func == (a: MapboxMaps.Atmosphere, b: MapboxMaps.Atmosphere) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_documentation(visibility: public) extension MapboxMaps.Atmosphere {
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColor(_ color: UIKit.UIColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func horizonBlend(_ constant: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func horizonBlendTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func horizonBlend(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func range(start: Swift.Double, end: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func rangeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func range(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColor(_ color: UIKit.UIColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func starIntensity(_ constant: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func starIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func starIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func verticalRange(start: Swift.Double, end: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func verticalRangeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func verticalRange(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
}
public protocol AttributionURLOpener {
  func openAttributionURL(_ url: Foundation.URL)
}
public struct BackgroundLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var backgroundColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var backgroundColorTransition: MapboxMaps.StyleTransition?
  public var backgroundEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var backgroundEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var backgroundOpacity: MapboxMaps.Value<Swift.Double>?
  public var backgroundOpacityTransition: MapboxMaps.StyleTransition?
  public var backgroundPattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.BackgroundLayer, b: MapboxMaps.BackgroundLayer) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class BasicCameraAnimator : MapboxMaps.CameraAnimator {
  final public var owner: MapboxMaps.AnimationOwner {
    get
  }
  final public var transition: MapboxMaps.CameraTransition? {
    get
  }
  final public var state: UIKit.UIViewAnimatingState {
    get
  }
  final public var isRunning: Swift.Bool {
    get
  }
  final public var isReversed: Swift.Bool {
    get
    set
  }
  final public var pausesOnCompletion: Swift.Bool {
    get
    set
  }
  final public var fractionComplete: Swift.Double {
    get
    set
  }
  final public var onStarted: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onFinished: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onCancelled: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public func startAnimation()
  final public func startAnimation(afterDelay delay: Foundation.TimeInterval)
  final public func pauseAnimation()
  final public func stopAnimation()
  final public func addCompletion(_ completion: @escaping MapboxMaps.AnimationCompletion)
  final public func continueAnimation(withTimingParameters timingParameters: (any UIKit.UITimingCurveProvider)?, durationFactor: Swift.Double)
  @objc final public func cancel()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CameraAnimationsManager {
  final public var cameraAnimators: [any MapboxMaps.CameraAnimator] {
    get
  }
  final public func cancelAnimations()
  @discardableResult
  final public func fly(to: MapboxMaps.CameraOptions, duration: Foundation.TimeInterval? = nil, curve: MapboxMaps.TimingCurve = .easeOut, completion: MapboxMaps.AnimationCompletion? = nil) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func ease(to: MapboxMaps.CameraOptions, duration: Foundation.TimeInterval, curve: UIKit.UIView.AnimationCurve = .easeOut, completion: MapboxMaps.AnimationCompletion? = nil) -> any MapboxCommon.Cancelable
  final public func makeAnimator(duration: Foundation.TimeInterval, timingParameters: any UIKit.UITimingCurveProvider, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public func makeAnimator(duration: Foundation.TimeInterval, curve: UIKit.UIView.AnimationCurve, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public func makeAnimator(duration: Foundation.TimeInterval, controlPoint1: CoreFoundation.CGPoint, controlPoint2: CoreFoundation.CGPoint, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public func makeAnimator(duration: Foundation.TimeInterval, dampingRatio: CoreFoundation.CGFloat, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public var onCameraAnimatorStarted: MapboxMaps.Signal<any MapboxMaps.CameraAnimator> {
    get
  }
  final public var onCameraAnimatorFinished: MapboxMaps.Signal<any MapboxMaps.CameraAnimator> {
    get
  }
  final public var onCameraAnimatorCancelled: MapboxMaps.Signal<any MapboxMaps.CameraAnimator> {
    get
  }
  @objc deinit
}
public protocol CameraAnimator : MapboxCommon.Cancelable {
  var owner: MapboxMaps.AnimationOwner { get }
  func stopAnimation()
  var state: UIKit.UIViewAnimatingState { get }
}
extension MapboxMaps.Signal where Payload == any MapboxMaps.CameraAnimator {
  public func owned(by owner: MapboxMaps.AnimationOwner) -> MapboxMaps.Signal<Payload>
}
public struct CameraBounds : Swift.Hashable {
  public let bounds: MapboxCoreMaps.CoordinateBounds
  public let maxZoom: CoreFoundation.CGFloat
  public let minZoom: CoreFoundation.CGFloat
  public let maxPitch: CoreFoundation.CGFloat
  public let minPitch: CoreFoundation.CGFloat
  public static func == (lhs: MapboxMaps.CameraBounds, rhs: MapboxMaps.CameraBounds) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraBoundsOptions : Swift.Hashable {
  public var bounds: MapboxCoreMaps.CoordinateBounds?
  public var maxZoom: CoreFoundation.CGFloat?
  public var minZoom: CoreFoundation.CGFloat?
  public var maxPitch: CoreFoundation.CGFloat?
  public var minPitch: CoreFoundation.CGFloat?
  public init(bounds: MapboxCoreMaps.CoordinateBounds? = nil, maxZoom: CoreFoundation.CGFloat? = nil, minZoom: CoreFoundation.CGFloat? = nil, maxPitch: CoreFoundation.CGFloat? = nil, minPitch: CoreFoundation.CGFloat? = nil)
  public static func == (lhs: MapboxMaps.CameraBoundsOptions, rhs: MapboxMaps.CameraBoundsOptions) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxMaps.CameraBoundsOptions {
  public init(cameraBounds: MapboxMaps.CameraBounds)
}
public struct CameraOptions : Swift.Codable, Swift.Hashable {
  public var center: CoreLocation.CLLocationCoordinate2D? {
    get
    set
  }
  public var padding: UIKit.UIEdgeInsets? {
    get
    set
  }
  public var anchor: CoreFoundation.CGPoint? {
    get
    set
  }
  public var zoom: CoreFoundation.CGFloat?
  public var bearing: CoreLocation.CLLocationDirection?
  public var pitch: CoreFoundation.CGFloat?
  public init(center: CoreLocation.CLLocationCoordinate2D? = nil, padding: UIKit.UIEdgeInsets? = nil, anchor: CoreFoundation.CGPoint? = nil, zoom: CoreFoundation.CGFloat? = nil, bearing: CoreLocation.CLLocationDirection? = nil, pitch: CoreFoundation.CGFloat? = nil)
  public init(cameraState: MapboxMaps.CameraState, anchor: CoreFoundation.CGPoint? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.CameraOptions, b: MapboxMaps.CameraOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct CameraState : Swift.Codable, Swift.Hashable {
  public var center: CoreLocation.CLLocationCoordinate2D {
    get
    set
  }
  public var padding: UIKit.UIEdgeInsets {
    get
    set
  }
  public var zoom: CoreFoundation.CGFloat
  public var bearing: CoreLocation.CLLocationDirection
  public var pitch: CoreFoundation.CGFloat
  public init(center: CoreLocation.CLLocationCoordinate2D, padding: UIKit.UIEdgeInsets, zoom: CoreFoundation.CGFloat, bearing: CoreLocation.CLLocationDirection, pitch: CoreFoundation.CGFloat)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.CameraState, b: MapboxMaps.CameraState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct CameraTransition : Swift.Equatable {
  public var center: MapboxMaps.CameraTransition.Change<CoreLocation.CLLocationCoordinate2D>
  public var zoom: MapboxMaps.CameraTransition.Change<CoreFoundation.CGFloat>
  public var padding: MapboxMaps.CameraTransition.Change<UIKit.UIEdgeInsets>
  public var anchor: MapboxMaps.CameraTransition.Change<CoreFoundation.CGPoint>
  public var bearing: MapboxMaps.CameraTransition.Change<CoreLocation.CLLocationDirection>
  public var shouldOptimizeBearingPath: Swift.Bool
  public var pitch: MapboxMaps.CameraTransition.Change<CoreFoundation.CGFloat>
  public struct Change<T> : Swift.Equatable where T : Swift.Equatable {
    public var fromValue: T
    public var toValue: T?
    public static func == (a: MapboxMaps.CameraTransition.Change<T>, b: MapboxMaps.CameraTransition.Change<T>) -> Swift.Bool
  }
  public static func == (a: MapboxMaps.CameraTransition, b: MapboxMaps.CameraTransition) -> Swift.Bool
}
public struct CircleAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var point: Turf.Point
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.CircleAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.CircleAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.CircleAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, point: Turf.Point, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public init(id: Swift.String = UUID().uuidString, centerCoordinate: CoreLocation.CLLocationCoordinate2D, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var circleSortKey: Swift.Double?
  public var circleBlur: Swift.Double?
  public var circleColor: MapboxMaps.StyleColor?
  public var circleOpacity: Swift.Double?
  public var circleRadius: Swift.Double?
  public var circleStrokeColor: MapboxMaps.StyleColor?
  public var circleStrokeOpacity: Swift.Double?
  public var circleStrokeWidth: Swift.Double?
  public static func == (a: MapboxMaps.CircleAnnotation, b: MapboxMaps.CircleAnnotation) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class CircleAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.CircleAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var circleEmissiveStrength: Swift.Double? {
    get
    set
  }
  public var circlePitchAlignment: MapboxMaps.CirclePitchAlignment? {
    get
    set
  }
  public var circlePitchScale: MapboxMaps.CirclePitchScale? {
    get
    set
  }
  public var circleTranslate: [Swift.Double]? {
    get
    set
  }
  public var circleTranslateAnchor: MapboxMaps.CircleTranslateAnchor? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @objc deinit
}
public struct CircleLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var circleSortKey: MapboxMaps.Value<Swift.Double>?
  public var circleBlur: MapboxMaps.Value<Swift.Double>?
  public var circleBlurTransition: MapboxMaps.StyleTransition?
  public var circleColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var circleColorTransition: MapboxMaps.StyleTransition?
  public var circleEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var circleEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var circleOpacity: MapboxMaps.Value<Swift.Double>?
  public var circleOpacityTransition: MapboxMaps.StyleTransition?
  public var circlePitchAlignment: MapboxMaps.Value<MapboxMaps.CirclePitchAlignment>?
  public var circlePitchScale: MapboxMaps.Value<MapboxMaps.CirclePitchScale>?
  public var circleRadius: MapboxMaps.Value<Swift.Double>?
  public var circleRadiusTransition: MapboxMaps.StyleTransition?
  public var circleStrokeColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var circleStrokeColorTransition: MapboxMaps.StyleTransition?
  public var circleStrokeOpacity: MapboxMaps.Value<Swift.Double>?
  public var circleStrokeOpacityTransition: MapboxMaps.StyleTransition?
  public var circleStrokeWidth: MapboxMaps.Value<Swift.Double>?
  public var circleStrokeWidthTransition: MapboxMaps.StyleTransition?
  public var circleTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var circleTranslateTransition: MapboxMaps.StyleTransition?
  public var circleTranslateAnchor: MapboxMaps.Value<MapboxMaps.CircleTranslateAnchor>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.CircleLayer, b: MapboxMaps.CircleLayer) -> Swift.Bool
}
public struct ClusterOptions : Swift.Equatable {
  public init(circleRadius: MapboxMaps.Value<Swift.Double> = .constant(18), circleColor: MapboxMaps.Value<MapboxMaps.StyleColor> = .constant(StyleColor(.black)), textColor: MapboxMaps.Value<MapboxMaps.StyleColor> = .constant(StyleColor(.white)), textSize: MapboxMaps.Value<Swift.Double> = .constant(12), textField: MapboxMaps.Value<Swift.String> = .expression(Exp(.get) { "point_count" }), clusterRadius: Swift.Double = 50, clusterMaxZoom: Swift.Double = 14, clusterMinPoints: Swift.Double = 2, clusterProperties: [Swift.String : MapboxMaps.Expression]? = nil)
  public static func == (a: MapboxMaps.ClusterOptions, b: MapboxMaps.ClusterOptions) -> Swift.Bool
}
public class CompassDirectionFormatter {
  public enum Style : Swift.Hashable {
    case short
    case long
    public static func == (a: MapboxMaps.CompassDirectionFormatter.Style, b: MapboxMaps.CompassDirectionFormatter.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var style: MapboxMaps.CompassDirectionFormatter.Style
  public init()
  public func string(from direction: CoreLocation.CLLocationDirection) -> Swift.String
  @objc deinit
}
extension MapboxCoreMaps.CoordinateBounds {
  public static var world: MapboxCoreMaps.CoordinateBounds {
    get
  }
  public var south: CoreLocation.CLLocationDegrees {
    get
  }
  public var west: CoreLocation.CLLocationDegrees {
    get
  }
  public var north: CoreLocation.CLLocationDegrees {
    get
  }
  public var east: CoreLocation.CLLocationDegrees {
    get
  }
  public var center: CoreLocation.CLLocationCoordinate2D {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var latitudeSpan: CoreLocation.CLLocationDegrees {
    get
  }
  public var longitudeSpan: CoreLocation.CLLocationDegrees {
    get
  }
  public var northwest: CoreLocation.CLLocationCoordinate2D {
    get
  }
  public var southeast: CoreLocation.CLLocationCoordinate2D {
    get
  }
}
extension MapboxCoreMaps.MapLoadingError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension MapboxCoreMaps.CameraChanged {
  public var cameraState: MapboxMaps.CameraState {
    get
  }
  convenience public init(cameraState: MapboxMaps.CameraState, timestamp: Foundation.Date)
}
extension MapboxCoreMaps.SourceDataLoaded {
  public var loaded: Swift.Bool? {
    get
  }
  convenience public init(sourceId: Swift.String, type: MapboxCoreMaps.SourceDataLoadedType, loaded: Swift.Bool?, tileId: MapboxCoreMaps.CanonicalTileID, dataId: Swift.String?, timeInterval: MapboxCoreMaps.EventTimeInterval)
}
extension MapboxCoreMaps.RequestInfo {
  public var loadingMethod: [MapboxCoreMaps.RequestLoadingMethodType] {
    get
  }
}
public struct CustomGeometrySource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public let options: MapboxCoreMaps.CustomGeometrySourceOptions?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public init(id: Swift.String, options: MapboxCoreMaps.CustomGeometrySourceOptions)
}
extension MapboxMaps.CustomGeometrySource {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension MapboxCoreMaps.CustomRasterSourceTileData {
  public var image: UIKit.UIImage? {
    get
  }
  convenience public init(tileId: MapboxCoreMaps.CanonicalTileID, image: UIKit.UIImage?)
}
@_hasMissingDesignatedInitializers final public class DefaultViewportTransition {
  final public var options: MapboxMaps.DefaultViewportTransitionOptions
  @objc deinit
}
extension MapboxMaps.DefaultViewportTransition : MapboxMaps.ViewportTransition {
  final public func run(to toState: any MapboxMaps.ViewportState, completion: @escaping (Swift.Bool) -> Swift.Void) -> any MapboxCommon.Cancelable
}
public struct DefaultViewportTransitionOptions : Swift.Hashable {
  public var maxDuration: Foundation.TimeInterval
  public init(maxDuration: Foundation.TimeInterval = 3.5)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.DefaultViewportTransitionOptions, b: MapboxMaps.DefaultViewportTransitionOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DirectionalLight : Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public let id: Swift.String
  public let type: MapboxMaps.LightType
  public var castShadows: MapboxMaps.Value<Swift.Bool>?
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var direction: MapboxMaps.Value<[Swift.Double]>?
  public var directionTransition: MapboxMaps.StyleTransition?
  public var intensity: MapboxMaps.Value<Swift.Double>?
  public var intensityTransition: MapboxMaps.StyleTransition?
  public var shadowIntensity: MapboxMaps.Value<Swift.Double>?
  public var shadowIntensityTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String = UUID().uuidString)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.DirectionalLight, b: MapboxMaps.DirectionalLight) -> Swift.Bool
}
extension MapboxMaps.DirectionalLight {
  @_documentation(visibility: public) public func castShadows(_ constant: Swift.Bool) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func castShadows(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func direction(azimuthal: Swift.Double, polar: Swift.Double) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func directionTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func direction(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func intensity(_ constant: Swift.Double) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func intensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func intensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func shadowIntensity(_ constant: Swift.Double) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func shadowIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func shadowIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
}
public typealias Exp = MapboxMaps.Expression
public struct Expression : Swift.Codable, Swift.CustomStringConvertible, Swift.Equatable {
  public var `operator`: MapboxMaps.Expression.Operator {
    get
  }
  public var arguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(_ op: MapboxMaps.Expression.Operator, @MapboxMaps.ExpressionArgumentBuilder content: () -> [MapboxMaps.Expression.Argument])
  public init(_ op: MapboxMaps.Expression.Operator)
  public init(operator op: MapboxMaps.Expression.Operator, arguments: [MapboxMaps.Expression.Argument])
  public init(@MapboxMaps.ExpressionArgumentBuilder content: () -> [MapboxMaps.Expression.Argument])
  public init(arguments: [MapboxMaps.Expression.Argument])
  public func encode(to encoder: any Swift.Encoder) throws
  public var description: Swift.String {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  indirect public enum Element : Swift.Codable, Swift.CustomStringConvertible, Swift.Equatable {
    case `operator`(MapboxMaps.Expression.Operator)
    case argument(MapboxMaps.Expression.Argument)
    public var description: Swift.String {
      get
    }
    public static func == (lhs: MapboxMaps.Expression.Element, rhs: MapboxMaps.Expression.Element) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  indirect public enum Argument : Swift.Codable, Swift.CustomStringConvertible, Swift.Equatable {
    case number(Swift.Double)
    case string(Swift.String)
    case boolean(Swift.Bool)
    case numberArray([Swift.Double])
    case stringArray([Swift.String])
    case option(MapboxMaps.Expression.Option)
    case geoJSONObject(Turf.GeoJSONObject)
    case null
    case expression(MapboxMaps.Expression)
    public var description: Swift.String {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: MapboxMaps.Expression.Argument, b: MapboxMaps.Expression.Argument) -> Swift.Bool
  }
  public static func == (a: MapboxMaps.Expression, b: MapboxMaps.Expression) -> Swift.Bool
}
@_functionBuilder public struct ExpressionArgumentBuilder {
  public static func buildBlock(_ arguments: any MapboxMaps.ExpressionArgumentConvertible...) -> [MapboxMaps.Expression.Argument]
}
public protocol ExpressionArgumentConvertible {
  var expressionArguments: [MapboxMaps.Expression.Argument] { get }
}
extension Swift.Int : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.UInt : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Double : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.String : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Bool : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Array : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension MapboxMaps.Expression : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Dictionary : MapboxMaps.ExpressionArgumentConvertible where Key == Swift.Double, Value : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension UIKit.UIColor : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Turf.GeoJSONObject : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension MapboxMaps.Expression {
  public enum Option : Swift.Codable, Swift.Equatable {
    case format(MapboxMaps.FormatOptions)
    case numberFormat(MapboxMaps.NumberFormatOptions)
    case collator(MapboxMaps.CollatorOptions)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: MapboxMaps.Expression.Option, b: MapboxMaps.Expression.Option) -> Swift.Bool
  }
}
public struct FormatOptions : Swift.Codable, Swift.Equatable, MapboxMaps.ExpressionArgumentConvertible {
  public var fontScale: MapboxMaps.Value<Swift.Double>?
  public var textFont: MapboxMaps.Value<[Swift.String]>?
  public var textColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(fontScale: MapboxMaps.Value<Swift.Double>? = nil, textFont: MapboxMaps.Value<[Swift.String]>? = nil, textColor: MapboxMaps.Value<MapboxMaps.StyleColor>? = nil)
  public init()
  public static func == (a: MapboxMaps.FormatOptions, b: MapboxMaps.FormatOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NumberFormatOptions : Swift.Codable, Swift.Equatable, MapboxMaps.ExpressionArgumentConvertible {
  public var locale: Swift.String?
  public var currency: Swift.String?
  public var minFractionDigits: Swift.Int?
  public var maxFractionDigits: Swift.Int?
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(locale: Swift.String?, currency: Swift.String?, minFractionDigits: Swift.Int?, maxFractionDigits: Swift.Int?)
  public static func == (a: MapboxMaps.NumberFormatOptions, b: MapboxMaps.NumberFormatOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CollatorOptions : Swift.Codable, Swift.Equatable, MapboxMaps.ExpressionArgumentConvertible {
  public var caseSensitive: Swift.Bool?
  public var diacriticSensitive: Swift.Bool?
  public var locale: Swift.String?
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(caseSensitive: Swift.Bool?, diacriticSensitive: Swift.Bool?, locale: Swift.String?)
  public static func == (a: MapboxMaps.CollatorOptions, b: MapboxMaps.CollatorOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias Feature = Turf.Feature
extension MapboxCoreMaps.FeatureExtensionValue {
  convenience public init(value: Any?, features: [MapboxMaps.Feature]?)
  public var features: [MapboxMaps.Feature]? {
    get
  }
}
public struct FillExtrusionLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var fillExtrusionAmbientOcclusionIntensity: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionAmbientOcclusionIntensityTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionAmbientOcclusionRadius: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionAmbientOcclusionRadiusTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionBase: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionBaseTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var fillExtrusionColorTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionCutoffFadeRange: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionHeight: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionHeightTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionOpacity: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionOpacityTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionPattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var fillExtrusionTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var fillExtrusionTranslateTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionTranslateAnchor: MapboxMaps.Value<MapboxMaps.FillExtrusionTranslateAnchor>?
  public var fillExtrusionVerticalGradient: MapboxMaps.Value<Swift.Bool>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.FillExtrusionLayer, b: MapboxMaps.FillExtrusionLayer) -> Swift.Bool
}
public struct FillLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var fillSortKey: MapboxMaps.Value<Swift.Double>?
  public var fillAntialias: MapboxMaps.Value<Swift.Bool>?
  public var fillColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var fillColorTransition: MapboxMaps.StyleTransition?
  public var fillEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var fillEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var fillOpacity: MapboxMaps.Value<Swift.Double>?
  public var fillOpacityTransition: MapboxMaps.StyleTransition?
  public var fillOutlineColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var fillOutlineColorTransition: MapboxMaps.StyleTransition?
  public var fillPattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var fillTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var fillTranslateTransition: MapboxMaps.StyleTransition?
  public var fillTranslateAnchor: MapboxMaps.Value<MapboxMaps.FillTranslateAnchor>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.FillLayer, b: MapboxMaps.FillLayer) -> Swift.Bool
}
public struct FlatLight : Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public let id: Swift.String
  public let type: MapboxMaps.LightType
  public var anchor: MapboxMaps.Value<MapboxMaps.Anchor>?
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var intensity: MapboxMaps.Value<Swift.Double>?
  public var intensityTransition: MapboxMaps.StyleTransition?
  public var position: MapboxMaps.Value<[Swift.Double]>?
  public var positionTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String = UUID().uuidString)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.FlatLight, b: MapboxMaps.FlatLight) -> Swift.Bool
}
extension MapboxMaps.FlatLight {
  @_documentation(visibility: public) public func anchor(_ constant: MapboxMaps.Anchor) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func anchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func intensity(_ constant: Swift.Double) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func intensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func intensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func position(radial: Swift.Double, azimuthal: Swift.Double, polar: Swift.Double) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func positionTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func position(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
}
@_hasMissingDesignatedInitializers final public class FlyToCameraAnimator : MapboxMaps.CameraAnimator {
  final public let owner: MapboxMaps.AnimationOwner
  final public let duration: Foundation.TimeInterval
  final public var state: UIKit.UIViewAnimatingState {
    get
  }
  final public var onStarted: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onFinished: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onCancelled: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public func stopAnimation()
  @objc final public func cancel()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FollowPuckViewportState {
  final public var options: MapboxMaps.FollowPuckViewportStateOptions {
    get
    set
  }
  @objc deinit
}
extension MapboxMaps.FollowPuckViewportState : MapboxMaps.ViewportState {
  final public func observeDataSource(with handler: @escaping (MapboxMaps.CameraOptions) -> Swift.Bool) -> any MapboxCommon.Cancelable
  final public func startUpdatingCamera()
  final public func stopUpdatingCamera()
}
public enum FollowPuckViewportStateBearing : Swift.Codable, Swift.Hashable {
  case constant(_: CoreLocation.CLLocationDirection)
  case heading
  case course
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.FollowPuckViewportStateBearing, b: MapboxMaps.FollowPuckViewportStateBearing) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct FollowPuckViewportStateOptions : Swift.Codable, Swift.Hashable {
  public var padding: UIKit.UIEdgeInsets? {
    get
    set
  }
  public var zoom: CoreFoundation.CGFloat?
  public var bearing: MapboxMaps.FollowPuckViewportStateBearing?
  public var pitch: CoreFoundation.CGFloat?
  public init(padding: UIKit.UIEdgeInsets? = nil, zoom: CoreFoundation.CGFloat? = 16.35, bearing: MapboxMaps.FollowPuckViewportStateBearing? = .heading, pitch: CoreFoundation.CGFloat? = 45)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.FollowPuckViewportStateOptions, b: MapboxMaps.FollowPuckViewportStateOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxCoreMaps.FreeCameraOptions {
  public var location: CoreLocation.CLLocationCoordinate2D {
    get
    set
  }
  public var altitude: CoreLocation.CLLocationDistance {
    get
    set
  }
}
public struct GeoJSONSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var data: MapboxMaps.GeoJSONSourceData?
  public var maxzoom: Swift.Double?
  public var attribution: Swift.String?
  public var buffer: Swift.Double?
  public var tolerance: Swift.Double?
  public var cluster: Swift.Bool?
  public var clusterRadius: Swift.Double?
  public var clusterMaxZoom: Swift.Double?
  public var clusterMinPoints: Swift.Double?
  public var clusterProperties: [Swift.String : MapboxMaps.Expression]?
  public var lineMetrics: Swift.Bool?
  public var generateId: Swift.Bool?
  public var promoteId: MapboxMaps.PromoteId?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.GeoJSONSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
public enum GeoJSONSourceData : Swift.Codable, Swift.Equatable {
  case string(Swift.String)
  case feature(MapboxMaps.Feature)
  case featureCollection(Turf.FeatureCollection)
  case geometry(MapboxMaps.Geometry)
  @available(*, unavailable, message: "use nil data.")
  case empty
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func url(_ url: Foundation.URL) -> MapboxMaps.GeoJSONSourceData
  public static func == (a: MapboxMaps.GeoJSONSourceData, b: MapboxMaps.GeoJSONSourceData) -> Swift.Bool
}
public typealias Geometry = Turf.Geometry
public protocol GestureManagerDelegate : AnyObject {
  func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didBegin gestureType: MapboxMaps.GestureType)
  func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didEnd gestureType: MapboxMaps.GestureType, willAnimate: Swift.Bool)
  func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didEndAnimatingFor gestureType: MapboxMaps.GestureType)
}
@_hasMissingDesignatedInitializers final public class GestureManager {
  final public var options: MapboxMaps.GestureOptions {
    get
    set
  }
  final public var panGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var pinchGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var rotateGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var pitchGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var doubleTapToZoomInGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var doubleTouchToZoomOutGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var quickZoomGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var singleTapGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var onMapTap: MapboxMaps.Signal<MapboxMaps.MapContentGestureContext> {
    get
  }
  final public var onMapLongPress: MapboxMaps.Signal<MapboxMaps.MapContentGestureContext> {
    get
  }
  final public func onLayerTap(_ layerId: Swift.String, handler: @escaping MapboxMaps.MapLayerGestureHandler) -> MapboxMaps.AnyCancelable
  final public func onLayerLongPress(_ layerId: Swift.String, handler: @escaping MapboxMaps.MapLayerGestureHandler) -> MapboxMaps.AnyCancelable
  weak final public var delegate: (any MapboxMaps.GestureManagerDelegate)?
  @objc deinit
}
public enum PanMode : Swift.String, Swift.Equatable, Swift.CaseIterable {
  case horizontal
  case vertical
  case horizontalAndVertical
  public init?(rawValue: Swift.String)
  public typealias AllCases = [MapboxMaps.PanMode]
  public typealias RawValue = Swift.String
  public static var allCases: [MapboxMaps.PanMode] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct GestureOptions : Swift.Equatable {
  public var panEnabled: Swift.Bool
  public var pinchEnabled: Swift.Bool
  public var rotateEnabled: Swift.Bool
  public var simultaneousRotateAndPinchZoomEnabled: Swift.Bool
  public var pinchZoomEnabled: Swift.Bool
  public var pinchPanEnabled: Swift.Bool
  public var pitchEnabled: Swift.Bool
  public var doubleTapToZoomInEnabled: Swift.Bool
  public var doubleTouchToZoomOutEnabled: Swift.Bool
  public var quickZoomEnabled: Swift.Bool
  public var panMode: MapboxMaps.PanMode
  public var panDecelerationFactor: CoreFoundation.CGFloat
  public var focalPoint: CoreFoundation.CGPoint?
  public init(panEnabled: Swift.Bool = true, pinchEnabled: Swift.Bool = true, rotateEnabled: Swift.Bool = true, simultaneousRotateAndPinchZoomEnabled: Swift.Bool = true, pinchZoomEnabled: Swift.Bool = true, pinchPanEnabled: Swift.Bool = true, pitchEnabled: Swift.Bool = true, doubleTapToZoomInEnabled: Swift.Bool = true, doubleTouchToZoomOutEnabled: Swift.Bool = true, quickZoomEnabled: Swift.Bool = true, panMode: MapboxMaps.PanMode = .horizontalAndVertical, panDecelerationFactor: CoreFoundation.CGFloat = UIScrollView.DecelerationRate.normal.rawValue, focalPoint: CoreFoundation.CGPoint? = nil)
  public static func == (a: MapboxMaps.GestureOptions, b: MapboxMaps.GestureOptions) -> Swift.Bool
}
public enum GestureType : Swift.Hashable, Swift.CaseIterable {
  case pan
  case pinch
  case pitch
  case doubleTapToZoomIn
  case doubleTouchToZoomOut
  case quickZoom
  case singleTap
  case rotation
  public static func == (a: MapboxMaps.GestureType, b: MapboxMaps.GestureType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [MapboxMaps.GestureType]
  public static var allCases: [MapboxMaps.GestureType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxCoreMaps.GlyphsRasterizationOptions {
  convenience public init(rasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode = .ideographsRasterizedLocally, fontFamilies: [Swift.String] = [])
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic open var hash: Swift.Int {
    @objc get
  }
}
public struct Heading : Swift.Equatable {
  public var direction: CoreLocation.CLLocationDirection
  public var accuracy: CoreLocation.CLLocationDirection
  public var timestamp: Foundation.Date
  public init(direction: CoreLocation.CLLocationDirection, accuracy: CoreLocation.CLLocationDirection, timestamp: Foundation.Date = Date())
  @available(visionOS, unavailable)
  public init(from clHeading: CoreLocation.CLHeading)
  public static func == (a: MapboxMaps.Heading, b: MapboxMaps.Heading) -> Swift.Bool
}
public protocol HeadingObserver : AnyObject {
  func onHeadingUpdate(_ heading: MapboxMaps.Heading)
}
public protocol HeadingProvider {
  var latestHeading: MapboxMaps.Heading? { get }
  func add(headingObserver: any MapboxMaps.HeadingObserver)
  func remove(headingObserver: any MapboxMaps.HeadingObserver)
}
public struct HeatmapLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var heatmapColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var heatmapIntensity: MapboxMaps.Value<Swift.Double>?
  public var heatmapIntensityTransition: MapboxMaps.StyleTransition?
  public var heatmapOpacity: MapboxMaps.Value<Swift.Double>?
  public var heatmapOpacityTransition: MapboxMaps.StyleTransition?
  public var heatmapRadius: MapboxMaps.Value<Swift.Double>?
  public var heatmapRadiusTransition: MapboxMaps.StyleTransition?
  public var heatmapWeight: MapboxMaps.Value<Swift.Double>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.HeatmapLayer, b: MapboxMaps.HeatmapLayer) -> Swift.Bool
}
public struct HillshadeLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var hillshadeAccentColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var hillshadeAccentColorTransition: MapboxMaps.StyleTransition?
  public var hillshadeEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var hillshadeEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var hillshadeExaggeration: MapboxMaps.Value<Swift.Double>?
  public var hillshadeExaggerationTransition: MapboxMaps.StyleTransition?
  public var hillshadeHighlightColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var hillshadeHighlightColorTransition: MapboxMaps.StyleTransition?
  public var hillshadeIlluminationAnchor: MapboxMaps.Value<MapboxMaps.HillshadeIlluminationAnchor>?
  public var hillshadeIlluminationDirection: MapboxMaps.Value<Swift.Double>?
  public var hillshadeShadowColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var hillshadeShadowColorTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.HillshadeLayer, b: MapboxMaps.HillshadeLayer) -> Swift.Bool
}
public struct ImageSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var coordinates: [[Swift.Double]]?
  public var prefetchZoomDelta: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.ImageSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_hasMissingDesignatedInitializers final public class ImmediateViewportTransition : MapboxMaps.ViewportTransition {
  final public func run(to toState: any MapboxMaps.ViewportState, completion: @escaping (Swift.Bool) -> Swift.Void) -> any MapboxCommon.Cancelable
  @objc deinit
}
public enum ImportPosition : Swift.Equatable, Swift.Codable {
  case `default`
  case above(Swift.String)
  case below(Swift.String)
  case at(Swift.Int)
  public static func == (a: MapboxMaps.ImportPosition, b: MapboxMaps.ImportPosition) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol Layer : MapboxMaps.StyleDecodable, MapboxMaps.StyleEncodable, Swift.Decodable, Swift.Encodable {
  var id: Swift.String { get set }
  var type: MapboxMaps.LayerType { get }
  var visibility: MapboxMaps.Value<MapboxMaps.Visibility> { get set }
  var minZoom: Swift.Double? { get set }
  var maxZoom: Swift.Double? { get set }
  var slot: MapboxMaps.Slot? { get set }
}
extension MapboxMaps.Layer {
  public init(jsonObject: [Swift.String : Any]) throws
}
public struct LayerInfo {
  public var id: Swift.String
  public var type: MapboxMaps.LayerType
  public init(id: Swift.String, type: MapboxMaps.LayerType)
}
public enum LayerPosition : Swift.Equatable, Swift.Codable {
  case `default`
  case above(Swift.String)
  case below(Swift.String)
  case at(Swift.Int)
  public static func == (a: MapboxMaps.LayerPosition, b: MapboxMaps.LayerPosition) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct LayerType : Swift.ExpressibleByStringLiteral, Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public static let fill: MapboxMaps.LayerType
  public static let line: MapboxMaps.LayerType
  public static let symbol: MapboxMaps.LayerType
  public static let circle: MapboxMaps.LayerType
  public static let heatmap: MapboxMaps.LayerType
  public static let fillExtrusion: MapboxMaps.LayerType
  public static let raster: MapboxMaps.LayerType
  public static let rasterParticle: MapboxMaps.LayerType
  public static let hillshade: MapboxMaps.LayerType
  public static let background: MapboxMaps.LayerType
  public static let locationIndicator: MapboxMaps.LayerType
  public static let sky: MapboxMaps.LayerType
  public static let slot: MapboxMaps.LayerType
  public static let custom: MapboxMaps.LayerType
  public init(stringLiteral type: Swift.String)
  public init(rawValue: Swift.String)
  public var layerType: (any MapboxMaps.Layer.Type)? {
    get
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct LightInfo : Swift.Decodable {
  public var id: Swift.String
  public var type: MapboxMaps.LightType
  public init(id: Swift.String, type: MapboxMaps.LightType)
  public init(from decoder: any Swift.Decoder) throws
}
public struct LightType : Swift.RawRepresentable, Swift.Codable, Swift.Equatable {
  public static let flat: MapboxMaps.LightType
  public static let ambient: MapboxMaps.LightType
  public static let directional: MapboxMaps.LightType
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public struct LineLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var lineCap: MapboxMaps.Value<MapboxMaps.LineCap>?
  public var lineJoin: MapboxMaps.Value<MapboxMaps.LineJoin>?
  public var lineMiterLimit: MapboxMaps.Value<Swift.Double>?
  public var lineRoundLimit: MapboxMaps.Value<Swift.Double>?
  public var lineSortKey: MapboxMaps.Value<Swift.Double>?
  public var lineBlur: MapboxMaps.Value<Swift.Double>?
  public var lineBlurTransition: MapboxMaps.StyleTransition?
  public var lineBorderColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var lineBorderColorTransition: MapboxMaps.StyleTransition?
  public var lineBorderWidth: MapboxMaps.Value<Swift.Double>?
  public var lineBorderWidthTransition: MapboxMaps.StyleTransition?
  public var lineColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var lineColorTransition: MapboxMaps.StyleTransition?
  public var lineDasharray: MapboxMaps.Value<[Swift.Double]>?
  public var lineDepthOcclusionFactor: MapboxMaps.Value<Swift.Double>?
  public var lineDepthOcclusionFactorTransition: MapboxMaps.StyleTransition?
  public var lineEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var lineEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var lineGapWidth: MapboxMaps.Value<Swift.Double>?
  public var lineGapWidthTransition: MapboxMaps.StyleTransition?
  public var lineGradient: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var lineOffset: MapboxMaps.Value<Swift.Double>?
  public var lineOffsetTransition: MapboxMaps.StyleTransition?
  public var lineOpacity: MapboxMaps.Value<Swift.Double>?
  public var lineOpacityTransition: MapboxMaps.StyleTransition?
  public var linePattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var lineTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var lineTranslateTransition: MapboxMaps.StyleTransition?
  public var lineTranslateAnchor: MapboxMaps.Value<MapboxMaps.LineTranslateAnchor>?
  public var lineTrimOffset: MapboxMaps.Value<[Swift.Double]>?
  public var lineWidth: MapboxMaps.Value<Swift.Double>?
  public var lineWidthTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.LineLayer, b: MapboxMaps.LineLayer) -> Swift.Bool
}
public struct LocationIndicatorLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var bearingImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var shadowImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var topImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var accuracyRadius: MapboxMaps.Value<Swift.Double>?
  public var accuracyRadiusTransition: MapboxMaps.StyleTransition?
  public var accuracyRadiusBorderColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var accuracyRadiusBorderColorTransition: MapboxMaps.StyleTransition?
  public var accuracyRadiusColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var accuracyRadiusColorTransition: MapboxMaps.StyleTransition?
  public var bearing: MapboxMaps.Value<Swift.Double>?
  public var bearingTransition: MapboxMaps.StyleTransition?
  public var bearingImageSize: MapboxMaps.Value<Swift.Double>?
  public var bearingImageSizeTransition: MapboxMaps.StyleTransition?
  public var emphasisCircleColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var emphasisCircleColorTransition: MapboxMaps.StyleTransition?
  public var emphasisCircleRadius: MapboxMaps.Value<Swift.Double>?
  public var emphasisCircleRadiusTransition: MapboxMaps.StyleTransition?
  public var imagePitchDisplacement: MapboxMaps.Value<Swift.Double>?
  public var location: MapboxMaps.Value<[Swift.Double]>?
  public var locationTransition: MapboxMaps.StyleTransition?
  public var locationIndicatorOpacity: MapboxMaps.Value<Swift.Double>?
  public var locationIndicatorOpacityTransition: MapboxMaps.StyleTransition?
  public var perspectiveCompensation: MapboxMaps.Value<Swift.Double>?
  public var shadowImageSize: MapboxMaps.Value<Swift.Double>?
  public var shadowImageSizeTransition: MapboxMaps.StyleTransition?
  public var topImageSize: MapboxMaps.Value<Swift.Double>?
  public var topImageSizeTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.LocationIndicatorLayer, b: MapboxMaps.LocationIndicatorLayer) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class LocationManager {
  final public var onLocationChange: MapboxMaps.Signal<[MapboxCommon.Location]> {
    get
  }
  final public var onHeadingChange: MapboxMaps.Signal<MapboxMaps.Heading> {
    get
  }
  final public let onPuckRender: MapboxMaps.Signal<MapboxMaps.PuckRenderingData>
  final public var options: MapboxMaps.LocationOptions {
    get
    set
  }
  final public func override(locationProvider: MapboxMaps.Signal<[MapboxCommon.Location]>, headingProvider: MapboxMaps.Signal<MapboxMaps.Heading>? = nil)
  final public func override(locationProvider: any MapboxCommon.LocationProvider, headingProvider: (any MapboxMaps.HeadingProvider)? = nil)
  final public func override(provider: any MapboxCommon.LocationProvider & MapboxMaps.HeadingProvider)
  final public var latestLocation: MapboxCommon.Location? {
    get
  }
  @available(*, unavailable, message: "Use override(provider:) instead")
  final public func overrideLocationProvider(with customLocationProvider: any MapboxCommon.LocationProvider)
  @available(*, unavailable, message: "Use onLocationChange")
  final public func addLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use onLocationChange")
  final public func removeLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use onPuckRender")
  final public func addPuckLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use onPuckRender")
  final public func removePuckLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use AppleLocationProvider.requestTemporaryFullAccuracyAuthorization(withPurposeKey:) instead")
  final public func requestTemporaryFullAccuracyPermissions(withPurposeKey purposeKey: Swift.String)
  @available(*, unavailable, message: "Use AppleLocationProvider.delegate instead")
  weak final public var delegate: (any MapboxMaps.LocationPermissionsDelegate)? {
    get
  }
  @available(*, unavailable, message: "Use onLocationChange instead")
  final public var locationProvider: (any MapboxCommon.LocationProvider)? {
    get
  }
  @objc deinit
}
public struct LocationOptions : Swift.Equatable {
  @available(*, unavailable, message: "Use AppleLocationProvider.Options.distanceFilter instead")
  public var distanceFilter: CoreLocation.CLLocationDistance {
    get
  }
  @available(*, unavailable, message: "Use AppleLocationProvider.Options.desiredAccuracy instead")
  public var desiredAccuracy: CoreLocation.CLLocationAccuracy {
    get
  }
  @available(*, unavailable, message: "Use AppleLocationProvider.Options.activityType instead")
  public var activityType: CoreLocation.CLActivityType {
    get
  }
  public var puckType: MapboxMaps.PuckType?
  public var puckBearing: MapboxMaps.PuckBearing
  public var puckBearingEnabled: Swift.Bool
  public init(puckType: MapboxMaps.PuckType? = nil, puckBearing: MapboxMaps.PuckBearing = .heading, puckBearingEnabled: Swift.Bool = false)
  public static func == (a: MapboxMaps.LocationOptions, b: MapboxMaps.LocationOptions) -> Swift.Bool
}
public enum PuckBearing : Swift.Equatable {
  case heading
  case course
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.PuckBearing, b: MapboxMaps.PuckBearing) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(*, unavailable, renamed: "AppleLocationProviderDelegate")
public protocol LocationPermissionsDelegate : AnyObject {
}
public struct MapContentGestureContext {
  public var point: CoreFoundation.CGPoint
  public var coordinate: CoreLocation.CLLocationCoordinate2D
}
public typealias MapLayerGestureHandler = (MapboxCoreMaps.QueriedFeature, MapboxMaps.MapContentGestureContext) -> Swift.Bool
@available(*, deprecated)
public struct MapEventType<Payload> {
  public static var mapLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.MapLoaded> {
    get
  }
  public static var mapLoadingError: MapboxMaps.MapEventType<MapboxCoreMaps.MapLoadingError> {
    get
  }
  public static var styleLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.StyleLoaded> {
    get
  }
  public static var styleDataLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.StyleDataLoaded> {
    get
  }
  public static var cameraChanged: MapboxMaps.MapEventType<MapboxCoreMaps.CameraChanged> {
    get
  }
  public static var mapIdle: MapboxMaps.MapEventType<MapboxCoreMaps.MapIdle> {
    get
  }
  public static var sourceAdded: MapboxMaps.MapEventType<MapboxCoreMaps.SourceAdded> {
    get
  }
  public static var sourceRemoved: MapboxMaps.MapEventType<MapboxCoreMaps.SourceRemoved> {
    get
  }
  public static var sourceDataLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.SourceDataLoaded> {
    get
  }
  public static var styleImageMissing: MapboxMaps.MapEventType<MapboxCoreMaps.StyleImageMissing> {
    get
  }
  public static var styleImageRemoveUnused: MapboxMaps.MapEventType<MapboxCoreMaps.StyleImageRemoveUnused> {
    get
  }
  public static var renderFrameStarted: MapboxMaps.MapEventType<MapboxCoreMaps.RenderFrameStarted> {
    get
  }
  public static var renderFrameFinished: MapboxMaps.MapEventType<MapboxCoreMaps.RenderFrameFinished> {
    get
  }
  public static var resourceRequest: MapboxMaps.MapEventType<MapboxCoreMaps.ResourceRequest> {
    get
  }
}
extension MapboxCoreMaps.MapLoadingError {
  @available(*, deprecated, message: "Use MapLoadingError fields to access the event data.")
  public var payload: MapboxCoreMaps.MapLoadingError {
    get
  }
  @available(*, deprecated, renamed: "type")
  public var error: MapboxCoreMaps.MapLoadingErrorType {
    get
  }
}
extension MapboxCoreMaps.StyleDataLoaded {
  @available(*, deprecated, message: "Use StyleDataLoaded fields to access the event data.")
  public var payload: MapboxCoreMaps.StyleDataLoaded {
    get
  }
}
extension MapboxCoreMaps.SourceAdded {
  @available(*, deprecated, message: "Use SourceAdded fields to access the event data.")
  public var payload: MapboxCoreMaps.SourceAdded {
    get
  }
  @available(*, deprecated, renamed: "sourceId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.SourceRemoved {
  @available(*, deprecated, message: "Use SourceRemoved fields to access the event data.")
  public var payload: MapboxCoreMaps.SourceRemoved {
    get
  }
  @available(*, deprecated, renamed: "sourceId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.SourceDataLoaded {
  @available(*, deprecated, message: "Use SourceDataLoaded fields to access the event data.")
  public var payload: MapboxCoreMaps.SourceDataLoaded {
    get
  }
  @available(*, deprecated, renamed: "sourceId")
  public var id: Swift.String? {
    get
  }
}
extension MapboxCoreMaps.StyleImageMissing {
  @available(*, deprecated, message: "Use StyleImageMissing fields to access the event data.")
  public var payload: MapboxCoreMaps.StyleImageMissing {
    get
  }
  @available(*, deprecated, renamed: "imageId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.StyleImageRemoveUnused {
  @available(*, deprecated, message: "Use StyleImageRemoveUnused fields to access the event data.")
  public var payload: MapboxCoreMaps.StyleImageRemoveUnused {
    get
  }
  @available(*, deprecated, renamed: "imageId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.RenderFrameFinished {
  @available(*, deprecated, message: "Use RenderFrameFinished fields to access the event data.")
  public var payload: MapboxCoreMaps.RenderFrameFinished {
    get
  }
}
extension MapboxCoreMaps.ResourceRequest {
  @available(*, deprecated, message: "Use ResourceRequest fields to access the event data.")
  public var payload: MapboxCoreMaps.ResourceRequest {
    get
  }
  @available(*, deprecated, renamed: "source")
  public var dataSource: MapboxCoreMaps.RequestDataSourceType? {
    get
  }
}
@objc public protocol MapInitOptionsProvider {
  @objc func mapInitOptions() -> MapboxMaps.MapInitOptions
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapInitOptions : ObjectiveC.NSObject {
  final public let mapOptions: MapboxCoreMaps.MapOptions
  final public let styleURI: MapboxMaps.StyleURI?
  final public let styleJSON: Swift.String?
  final public let cameraOptions: MapboxMaps.CameraOptions?
  final public let antialiasingSampleCount: Swift.Int
  public init(mapOptions: MapboxCoreMaps.MapOptions = MapOptions(), cameraOptions: MapboxMaps.CameraOptions? = nil, styleURI: MapboxMaps.StyleURI? = .standard, styleJSON: Swift.String? = nil, antialiasingSampleCount: Swift.Int = 1)
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension MapboxCoreMaps.MapOptions {
  @available(*, unavailable, message: "'optimizeForTerrain' is obsolete and has no effect. Layer order is automatically adjusted for better performance based on the presence of terrain.")
  convenience public init(constrainMode: MapboxCoreMaps.ConstrainMode = .heightOnly, viewportMode: MapboxCoreMaps.ViewportMode = .default, orientation: MapboxCoreMaps.NorthOrientation = .upwards, crossSourceCollisions: Swift.Bool = true, optimizeForTerrain: Swift.Bool = true, size: CoreFoundation.CGSize? = nil, pixelRatio: CoreFoundation.CGFloat? = nil, glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions = GlyphsRasterizationOptions(fontFamilies: []))
  convenience public init(constrainMode: MapboxCoreMaps.ConstrainMode = .heightOnly, viewportMode: MapboxCoreMaps.ViewportMode = .default, orientation: MapboxCoreMaps.NorthOrientation = .upwards, crossSourceCollisions: Swift.Bool = true, size: CoreFoundation.CGSize? = nil, pixelRatio: CoreFoundation.CGFloat? = nil, glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions = GlyphsRasterizationOptions(fontFamilies: []))
  public var crossSourceCollisions: Swift.Bool {
    get
  }
  @available(*, unavailable, message: "Not needed anymore, layer order is automatically adjusted for better performance based on the presence of terrain.")
  public var optimizeForTerrain: Swift.Bool {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic open var hash: Swift.Int {
    @objc get
  }
}
public struct MapPlayerOptions {
  public init(playbackCount: Swift.Int, playbackSpeedMultiplier: Swift.Double, avoidPlaybackPauses: Swift.Bool)
}
public struct MapRecorderOptions {
  public init(timeWindow: Swift.Int?, loggingEnabled: Swift.Bool, compressed: Swift.Bool)
}
public struct MapSnapshotOptions {
  public var size: CoreFoundation.CGSize
  public var pixelRatio: CoreFoundation.CGFloat
  public var glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions
  public var showsLogo: Swift.Bool
  public var showsAttribution: Swift.Bool
  public init(size: CoreFoundation.CGSize, pixelRatio: CoreFoundation.CGFloat, glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions = GlyphsRasterizationOptions(), showsLogo: Swift.Bool = true, showsAttribution: Swift.Bool = true)
}
extension MapboxMaps.MapView {
  public struct SnapshotError : Swift.Error, Swift.Equatable {
    public let message: Swift.String
    public static let noMetalView: MapboxMaps.MapView.SnapshotError
    public static let missingImageData: MapboxMaps.MapView.SnapshotError
    public static func == (a: MapboxMaps.MapView.SnapshotError, b: MapboxMaps.MapView.SnapshotError) -> Swift.Bool
  }
  @_Concurrency.MainActor(unsafe) public func snapshot(includeOverlays: Swift.Bool = false) throws -> UIKit.UIImage
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class MapView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public var mapboxMap: MapboxMaps.MapboxMap! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var gestures: MapboxMaps.GestureManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var ornaments: MapboxMaps.OrnamentsManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var camera: MapboxMaps.CameraAnimationsManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var location: MapboxMaps.LocationManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var annotations: MapboxMaps.AnnotationOrchestrator! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var viewAnnotations: MapboxMaps.ViewAnnotationManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var viewport: MapboxMaps.ViewportManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var presentsWithTransaction: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isOpaque: Swift.Bool {
    @objc get
    @objc set
  }
  @available(iOS, deprecated: 15, message: "Use preferredFrameRateRange instead.")
  @_Concurrency.MainActor(unsafe) public var preferredFramesPerSecond: Swift.Int {
    get
    set
  }
  @available(iOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var preferredFrameRateRange: QuartzCore.CAFrameRateRange {
    get
    set
  }
  @available(*, deprecated, renamed: "mapboxMap.cameraState")
  @_Concurrency.MainActor(unsafe) public var cameraState: MapboxMaps.CameraState {
    get
  }
  @available(*, deprecated, renamed: "mapboxMap.anchor")
  @_Concurrency.MainActor(unsafe) public var anchor: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor(unsafe) public var debugOptions: MapboxMaps.MapViewDebugOptions {
    get
    set
  }
  @available(iOSApplicationExtension, unavailable)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, mapInitOptions: MapboxMaps.MapInitOptions = MapInitOptions())
  @available(iOS, unavailable, message: "Use init(frame:mapInitOptions:urlOpener:) instead")
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, mapInitOptions: MapboxMaps.MapInitOptions = MapInitOptions(), orientationProvider: Swift.Void, urlOpener: any MapboxMaps.AttributionURLOpener)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, mapInitOptions: MapboxMaps.MapInitOptions = MapInitOptions(), urlOpener: any MapboxMaps.AttributionURLOpener)
  @available(iOSApplicationExtension, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
}
public struct MapViewDebugOptions : Swift.OptionSet, Swift.Hashable {
  public let rawValue: Swift.Int
  public static let tileBorders: MapboxMaps.MapViewDebugOptions
  public static let parseStatus: MapboxMaps.MapViewDebugOptions
  public static let timestamps: MapboxMaps.MapViewDebugOptions
  public static let collision: MapboxMaps.MapViewDebugOptions
  public static let overdraw: MapboxMaps.MapViewDebugOptions
  public static let stencilClip: MapboxMaps.MapViewDebugOptions
  public static let depthBuffer: MapboxMaps.MapViewDebugOptions
  public static let modelBounds: MapboxMaps.MapViewDebugOptions
  public static let light: MapboxMaps.MapViewDebugOptions
  public static let camera: MapboxMaps.MapViewDebugOptions
  public static let padding: MapboxMaps.MapViewDebugOptions
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = MapboxMaps.MapViewDebugOptions
  public typealias Element = MapboxMaps.MapViewDebugOptions
  public typealias RawValue = Swift.Int
}
@_hasMissingDesignatedInitializers final public class MapboxMap : MapboxMaps.StyleManager {
  @available(*, deprecated, message: "Access style APIs directly from MapboxMap instance instead")
  final public var style: MapboxMaps.StyleManager {
    get
  }
  @objc deinit
  final public func triggerRepaint()
  final public func loadStyle(_ styleURI: MapboxMaps.StyleURI, transition: MapboxMaps.TransitionOptions? = nil, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "loadStyle")
  final public func loadStyleURI(_ styleURI: MapboxMaps.StyleURI, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  final public func loadStyle(_ JSON: Swift.String, transition: MapboxMaps.TransitionOptions? = nil, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "loadStyle")
  final public func loadStyleJSON(_ JSON: Swift.String, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  final public var prefetchZoomDelta: Swift.UInt8 {
    get
    set
  }
  final public func reduceMemoryUse()
  final public func setTileCacheBudget(size: MapboxMaps.TileCacheBudgetSize?)
  @available(*, deprecated, message: "Use .setTileCacheBudget(size: TileCacheBudgetSize?) instead.")
  final public func setTileCacheBudget(_ tileCacheBudget: MapboxCoreMaps.TileCacheBudget?)
  final public var shouldRenderWorldCopies: Swift.Bool {
    get
    set
  }
  final public func elevation(at coordinate: CoreLocation.CLLocationCoordinate2D) -> Swift.Double?
  final public func coordinateBounds(for rect: CoreFoundation.CGRect) -> MapboxCoreMaps.CoordinateBounds
  final public func rect(for coordinateBounds: MapboxCoreMaps.CoordinateBounds) -> CoreFoundation.CGRect
  @available(*, deprecated, message: "Use MapView.debugOptions instead.")
  final public var debugOptions: [MapboxCoreMaps.MapDebugOptions] {
    get
    set
  }
  final public var options: MapboxCoreMaps.MapOptions {
    get
  }
  final public func setNorthOrientation(_ northOrientation: MapboxCoreMaps.NorthOrientation)
  final public func setConstrainMode(_ constrainMode: MapboxCoreMaps.ConstrainMode)
  final public func setViewportMode(_ viewportMode: MapboxCoreMaps.ViewportMode)
  @available(*, deprecated, renamed: "camera(for:camera:coordinatesPadding:maxZoom:offset:)", message: "Use camera(for:camera:coordinatesPadding:maxZoom:offset:) instead.")
  final public func camera(for coordinateBounds: MapboxCoreMaps.CoordinateBounds, padding: UIKit.UIEdgeInsets?, bearing: Swift.Double?, pitch: Swift.Double?, maxZoom: Swift.Double?, offset: CoreFoundation.CGPoint?) -> MapboxMaps.CameraOptions
  @available(*, deprecated, renamed: "camera(for:camera:coordinatesPadding:maxZoom:offset:)", message: "Use camera(for:camera:coordinatesPadding:maxZoom:offset:) instead.")
  final public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], padding: UIKit.UIEdgeInsets?, bearing: Swift.Double?, pitch: Swift.Double?) -> MapboxMaps.CameraOptions
  final public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], camera: MapboxMaps.CameraOptions, rect: CoreFoundation.CGRect) -> MapboxMaps.CameraOptions
  final public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], camera: MapboxMaps.CameraOptions, coordinatesPadding: UIKit.UIEdgeInsets?, maxZoom: Swift.Double?, offset: CoreFoundation.CGPoint?) throws -> MapboxMaps.CameraOptions
  @available(*, deprecated, renamed: "camera(for:camera:coordinatesPadding:maxZoom:offset:)", message: "Use camera(for:camera:coordinatesPadding:maxZoom:offset:) method instead.")
  final public func camera(for geometry: MapboxMaps.Geometry, padding: UIKit.UIEdgeInsets, bearing: CoreFoundation.CGFloat?, pitch: CoreFoundation.CGFloat?) -> MapboxMaps.CameraOptions
  final public func coordinateBounds(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBounds
  final public func coordinateBoundsUnwrapped(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBounds
  final public func coordinateBoundsZoom(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBoundsZoom
  final public func coordinateBoundsZoomUnwrapped(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBoundsZoom
  final public func coordinate(for point: CoreFoundation.CGPoint) -> CoreLocation.CLLocationCoordinate2D
  final public func point(for coordinate: CoreLocation.CLLocationCoordinate2D) -> CoreFoundation.CGPoint
  final public func points(for coordinates: [CoreLocation.CLLocationCoordinate2D]) -> [CoreFoundation.CGPoint]
  final public func coordinates(for points: [CoreFoundation.CGPoint]) -> [CoreLocation.CLLocationCoordinate2D]
  final public func coordinateInfo(for point: CoreFoundation.CGPoint) -> MapboxCoreMaps.CoordinateInfo
  final public func coordinatesInfo(for points: [CoreFoundation.CGPoint]) -> [MapboxCoreMaps.CoordinateInfo]
  final public func setCamera(to cameraOptions: MapboxMaps.CameraOptions)
  final public var cameraState: MapboxMaps.CameraState {
    get
  }
  final public var freeCameraOptions: MapboxCoreMaps.FreeCameraOptions {
    get
    set
  }
  final public var cameraBounds: MapboxMaps.CameraBounds {
    get
  }
  final public func setCameraBounds(with options: MapboxMaps.CameraBoundsOptions) throws
  final public func dragCameraOptions(from: CoreFoundation.CGPoint, to: CoreFoundation.CGPoint) -> MapboxMaps.CameraOptions
  final public var isAnimationInProgress: Swift.Bool {
    get
  }
  final public func beginAnimation()
  final public func endAnimation()
  final public var centerAltitudeMode: MapboxCoreMaps.MapCenterAltitudeMode {
    get
    set
  }
  final public var isGestureInProgress: Swift.Bool {
    get
  }
  final public func beginGesture()
  final public func endGesture()
}
extension MapboxMaps.MapboxMap {
  @discardableResult
  final public func queryRenderedFeatures(with shape: [CoreFoundation.CGPoint], options: MapboxCoreMaps.RenderedQueryOptions? = nil, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedRenderedFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func queryRenderedFeatures(with rect: CoreFoundation.CGRect, options: MapboxCoreMaps.RenderedQueryOptions? = nil, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedRenderedFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func queryRenderedFeatures(with point: CoreFoundation.CGPoint, options: MapboxCoreMaps.RenderedQueryOptions? = nil, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedRenderedFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func querySourceFeatures(for sourceId: Swift.String, options: MapboxCoreMaps.SourceQueryOptions, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedSourceFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getGeoJsonClusterLeaves(forSourceId sourceId: Swift.String, feature: MapboxMaps.Feature, limit: Swift.UInt64 = 10, offset: Swift.UInt64 = 0, completion: @escaping (Swift.Result<MapboxCoreMaps.FeatureExtensionValue, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getGeoJsonClusterChildren(forSourceId sourceId: Swift.String, feature: MapboxMaps.Feature, completion: @escaping (Swift.Result<MapboxCoreMaps.FeatureExtensionValue, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getGeoJsonClusterExpansionZoom(forSourceId sourceId: Swift.String, feature: MapboxMaps.Feature, completion: @escaping (Swift.Result<MapboxCoreMaps.FeatureExtensionValue, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.MapboxMap {
  final public var onMapLoaded: MapboxMaps.Signal<MapboxCoreMaps.MapLoaded> {
    get
  }
  final public var onMapLoadingError: MapboxMaps.Signal<MapboxCoreMaps.MapLoadingError> {
    get
  }
  final public var onStyleLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleLoaded> {
    get
  }
  final public var onStyleDataLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleDataLoaded> {
    get
  }
  final public var onCameraChanged: MapboxMaps.Signal<MapboxCoreMaps.CameraChanged> {
    get
  }
  final public var onMapIdle: MapboxMaps.Signal<MapboxCoreMaps.MapIdle> {
    get
  }
  final public var onSourceAdded: MapboxMaps.Signal<MapboxCoreMaps.SourceAdded> {
    get
  }
  final public var onSourceRemoved: MapboxMaps.Signal<MapboxCoreMaps.SourceRemoved> {
    get
  }
  final public var onSourceDataLoaded: MapboxMaps.Signal<MapboxCoreMaps.SourceDataLoaded> {
    get
  }
  final public var onStyleImageMissing: MapboxMaps.Signal<MapboxCoreMaps.StyleImageMissing> {
    get
  }
  final public var onStyleImageRemoveUnused: MapboxMaps.Signal<MapboxCoreMaps.StyleImageRemoveUnused> {
    get
  }
  final public var onRenderFrameStarted: MapboxMaps.Signal<MapboxCoreMaps.RenderFrameStarted> {
    get
  }
  final public var onRenderFrameFinished: MapboxMaps.Signal<MapboxCoreMaps.RenderFrameFinished> {
    get
  }
  final public var onResourceRequest: MapboxMaps.Signal<MapboxCoreMaps.ResourceRequest> {
    get
  }
  @available(*, deprecated, message: "Use mapboxMap.on<eventType>.observeNext instead.")
  @discardableResult
  final public func onNext<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
  @available(*, deprecated, message: "Use mapboxMap.on<eventType>.observe instead.")
  @discardableResult
  final public func onEvery<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.MapboxMap {
  public static func clearData(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
}
extension MapboxMaps.MapboxMap {
  @discardableResult
  final public func setFeatureState(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, featureId: Swift.String, state: [Swift.String : Any], callback: @escaping (Swift.Result<Foundation.NSNull, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getFeatureState(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, featureId: Swift.String, callback: @escaping (Swift.Result<[Swift.String : Any], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func removeFeatureState(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, featureId: Swift.String, stateKey: Swift.String? = nil, callback: @escaping (Swift.Result<Foundation.NSNull, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func resetFeatureStates(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, callback: @escaping (Swift.Result<Foundation.NSNull, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
}
public enum MapboxMapsOptions {
  public static var baseURL: Foundation.URL {
    get
    set
  }
  public static var dataPath: Foundation.URL {
    get
    set
  }
  public static var assetPath: Foundation.URL {
    get
    set
  }
  public static var tileStoreUsageMode: MapboxCoreMaps.TileStoreUsageMode {
    get
    set
  }
  public static var tileStore: MapboxCommon.TileStore? {
    get
    set
  }
}
public struct Model : Swift.Equatable, Swift.Codable {
  public var id: Swift.String?
  public var uri: Foundation.URL?
  public var position: [Swift.Double]?
  public var orientation: [Swift.Double]?
  public init(id: Swift.String? = nil, uri: Foundation.URL? = nil, position: [Swift.Double]? = nil, orientation: [Swift.Double]? = nil)
  public static func == (a: MapboxMaps.Model, b: MapboxMaps.Model) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum TileRegionError : Foundation.LocalizedError, Swift.Equatable {
  case canceled(Swift.String)
  case doesNotExist(Swift.String)
  case tilesetDescriptor(Swift.String)
  case diskFull(Swift.String)
  case other(Swift.String)
  case tileCountExceeded(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: MapboxMaps.TileRegionError, b: MapboxMaps.TileRegionError) -> Swift.Bool
}
public enum StylePackError : Foundation.LocalizedError, Swift.Equatable {
  case canceled(Swift.String)
  case doesNotExist(Swift.String)
  case diskFull(Swift.String)
  case other(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: MapboxMaps.StylePackError, b: MapboxMaps.StylePackError) -> Swift.Bool
}
extension MapboxCoreMaps.OfflineManager {
  @discardableResult
  public func loadStylePack(for styleURI: MapboxMaps.StyleURI, loadOptions: MapboxCoreMaps.StylePackLoadOptions, progress: MapboxCoreMaps.StylePackLoadProgressCallback? = nil, completion: @escaping (Swift.Result<MapboxCoreMaps.StylePack, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  public func allStylePacks(completion: @escaping (Swift.Result<[MapboxCoreMaps.StylePack], any Swift.Error>) -> Swift.Void)
  public func stylePack(for styleURI: MapboxMaps.StyleURI, completion: @escaping (Swift.Result<MapboxCoreMaps.StylePack, any Swift.Error>) -> Swift.Void)
  public func stylePackMetadata(for styleURI: MapboxMaps.StyleURI, completion: @escaping (Swift.Result<Swift.AnyObject, any Swift.Error>) -> Swift.Void)
  public func removeStylePack(for styleURI: MapboxMaps.StyleURI, completion: ((Swift.Result<MapboxCoreMaps.StylePack, any Swift.Error>) -> Swift.Void)? = nil)
}
@available(*, deprecated)
extension MapboxCoreMaps.OfflineRegion {
  public func invalidate(completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  public func purge(completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  public func setMetadata(_ metadata: Foundation.Data, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  public func getStatus(completion: @escaping (Swift.Result<MapboxCoreMaps.OfflineRegionStatus, any Swift.Error>) -> Swift.Void)
}
@available(*, deprecated)
extension MapboxCoreMaps.OfflineRegionGeometryDefinition {
  convenience public init(styleURL: Swift.String, geometry: MapboxMaps.Geometry, minZoom: Swift.Double, maxZoom: Swift.Double, pixelRatio: Swift.Float, glyphsRasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode)
  public var geometry: MapboxMaps.Geometry? {
    get
  }
}
@available(*, deprecated)
extension MapboxCoreMaps.OfflineRegionManager {
  public func offlineRegions(completion: @escaping (Swift.Result<[MapboxCoreMaps.OfflineRegion], any Swift.Error>) -> Swift.Void)
  public func createOfflineRegion(for geometryDefinition: MapboxCoreMaps.OfflineRegionGeometryDefinition, completion: @escaping (Swift.Result<MapboxCoreMaps.OfflineRegion, any Swift.Error>) -> Swift.Void)
  public func createOfflineRegion(for tilePyramidDefinition: MapboxCoreMaps.OfflineRegionTilePyramidDefinition, completion: @escaping (Swift.Result<MapboxCoreMaps.OfflineRegion, any Swift.Error>) -> Swift.Void)
  @available(iOS, deprecated, message: "use mergeOfflineDatabase(forPath:completion) instead")
  public func mergeOfflineDatabase(for filePath: Swift.String, completion: @escaping (_ result: Swift.Result<MapboxCoreMaps.OfflineRegion, any Swift.Error>) -> Swift.Void)
  public func mergeOfflineDatabase(forPath filePath: Swift.String, completion: @escaping (Swift.Result<[MapboxCoreMaps.OfflineRegion], any Swift.Error>) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class OfflineSwitch {
  public static var shared: MapboxMaps.OfflineSwitch
  public var isMapboxStackConnected: Swift.Bool {
    get
    set
  }
  @objc deinit
}
public struct OrnamentOptions : Swift.Equatable {
  public var scaleBar: MapboxMaps.ScaleBarViewOptions
  public var compass: MapboxMaps.CompassViewOptions
  public var logo: MapboxMaps.LogoViewOptions
  public var attributionButton: MapboxMaps.AttributionButtonOptions
  public init(scaleBar: MapboxMaps.ScaleBarViewOptions = .init(), compass: MapboxMaps.CompassViewOptions = .init(), logo: MapboxMaps.LogoViewOptions = .init(), attributionButton: MapboxMaps.AttributionButtonOptions = .init())
  public static func == (a: MapboxMaps.OrnamentOptions, b: MapboxMaps.OrnamentOptions) -> Swift.Bool
}
public struct ScaleBarViewOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  public var visibility: MapboxMaps.OrnamentVisibility
  public var useMetricUnits: Swift.Bool
  public init(position: MapboxMaps.OrnamentPosition = .topLeading, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0), visibility: MapboxMaps.OrnamentVisibility = .adaptive, useMetricUnits: Swift.Bool = Locale.current.usesMetricSystem)
  public static func == (a: MapboxMaps.ScaleBarViewOptions, b: MapboxMaps.ScaleBarViewOptions) -> Swift.Bool
}
public struct CompassViewOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  public var image: UIKit.UIImage?
  public var visibility: MapboxMaps.OrnamentVisibility
  public init(position: MapboxMaps.OrnamentPosition = .topTrailing, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0), image: UIKit.UIImage? = nil, visibility: MapboxMaps.OrnamentVisibility = .adaptive)
  public static func == (a: MapboxMaps.CompassViewOptions, b: MapboxMaps.CompassViewOptions) -> Swift.Bool
}
public struct AttributionButtonOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  public init(position: MapboxMaps.OrnamentPosition = .bottomTrailing, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0))
  public static func == (a: MapboxMaps.AttributionButtonOptions, b: MapboxMaps.AttributionButtonOptions) -> Swift.Bool
}
public struct LogoViewOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  public init(position: MapboxMaps.OrnamentPosition = .bottomLeading, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0))
  public static func == (a: MapboxMaps.LogoViewOptions, b: MapboxMaps.LogoViewOptions) -> Swift.Bool
}
public enum OrnamentPosition : Swift.String, Swift.Equatable {
  case topLeft
  case topRight
  case bottomRight
  case bottomLeft
  case topLeading
  case topTrailing
  case bottomLeading
  case bottomTrailing
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum OrnamentVisibility : Swift.String, Swift.Equatable {
  case adaptive
  case hidden
  case visible
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class OrnamentsManager {
  final public var options: MapboxMaps.OrnamentOptions {
    get
    set
  }
  final public var logoView: UIKit.UIView {
    get
  }
  final public var scaleBarView: UIKit.UIView {
    get
  }
  final public var compassView: UIKit.UIView {
    get
  }
  final public var attributionButton: UIKit.UIView {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class OverviewViewportState {
  final public var options: MapboxMaps.OverviewViewportStateOptions {
    get
    set
  }
  @objc deinit
}
extension MapboxMaps.OverviewViewportState : MapboxMaps.ViewportState {
  final public func observeDataSource(with handler: @escaping (MapboxMaps.CameraOptions) -> Swift.Bool) -> any MapboxCommon.Cancelable
  final public func startUpdatingCamera()
  final public func stopUpdatingCamera()
}
public struct OverviewViewportStateOptions : Swift.Equatable {
  public var geometry: MapboxMaps.Geometry
  public var geometryPadding: UIKit.UIEdgeInsets
  public var bearing: CoreLocation.CLLocationDirection?
  public var pitch: CoreFoundation.CGFloat?
  public var padding: UIKit.UIEdgeInsets?
  public var maxZoom: Swift.Double?
  public var offset: CoreFoundation.CGPoint?
  public var animationDuration: Foundation.TimeInterval
  public init(geometry: any Turf.GeometryConvertible, geometryPadding: UIKit.UIEdgeInsets = .zero, bearing: CoreLocation.CLLocationDirection? = 0, pitch: CoreFoundation.CGFloat? = 0, padding: UIKit.UIEdgeInsets? = nil, maxZoom: Swift.Double? = nil, offset: CoreFoundation.CGPoint? = nil, animationDuration: Foundation.TimeInterval = 1)
  public static func == (a: MapboxMaps.OverviewViewportStateOptions, b: MapboxMaps.OverviewViewportStateOptions) -> Swift.Bool
}
extension MapboxCoreMaps.CumulativeRenderingStatistics {
  public var drawCalls: Swift.UInt? {
    get
  }
  public var textureBytes: Swift.UInt? {
    get
  }
  public var vertexBytes: Swift.UInt? {
    get
  }
}
public struct PointAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var point: Turf.Point
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.PointAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.PointAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.PointAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, point: Turf.Point, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public init(id: Swift.String = UUID().uuidString, coordinate: CoreLocation.CLLocationCoordinate2D, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var iconAnchor: MapboxMaps.IconAnchor?
  public var iconImage: Swift.String?
  public var iconOffset: [Swift.Double]?
  public var iconRotate: Swift.Double?
  public var iconSize: Swift.Double?
  public var iconTextFit: MapboxMaps.IconTextFit?
  public var iconTextFitPadding: [Swift.Double]?
  public var symbolSortKey: Swift.Double?
  public var textAnchor: MapboxMaps.TextAnchor?
  public var textField: Swift.String?
  public var textJustify: MapboxMaps.TextJustify?
  public var textLetterSpacing: Swift.Double?
  public var textLineHeight: Swift.Double?
  public var textMaxWidth: Swift.Double?
  public var textOffset: [Swift.Double]?
  public var textRadialOffset: Swift.Double?
  public var textRotate: Swift.Double?
  public var textSize: Swift.Double?
  public var textTransform: MapboxMaps.TextTransform?
  public var iconColor: MapboxMaps.StyleColor?
  public var iconEmissiveStrength: Swift.Double?
  public var iconHaloBlur: Swift.Double?
  public var iconHaloColor: MapboxMaps.StyleColor?
  public var iconHaloWidth: Swift.Double?
  public var iconImageCrossFade: Swift.Double?
  public var iconOpacity: Swift.Double?
  public var textColor: MapboxMaps.StyleColor?
  public var textEmissiveStrength: Swift.Double?
  public var textHaloBlur: Swift.Double?
  public var textHaloColor: MapboxMaps.StyleColor?
  public var textHaloWidth: Swift.Double?
  public var textOpacity: Swift.Double?
  public var image: MapboxMaps.PointAnnotation.Image? {
    get
    set
  }
  public static func == (a: MapboxMaps.PointAnnotation, b: MapboxMaps.PointAnnotation) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class PointAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.PointAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var onClusterTap: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)?
  public var onClusterLongPress: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)?
  public var iconAllowOverlap: Swift.Bool? {
    get
    set
  }
  public var iconIgnorePlacement: Swift.Bool? {
    get
    set
  }
  public var iconKeepUpright: Swift.Bool? {
    get
    set
  }
  public var iconOptional: Swift.Bool? {
    get
    set
  }
  public var iconPadding: Swift.Double? {
    get
    set
  }
  public var iconPitchAlignment: MapboxMaps.IconPitchAlignment? {
    get
    set
  }
  public var iconRotationAlignment: MapboxMaps.IconRotationAlignment? {
    get
    set
  }
  public var symbolAvoidEdges: Swift.Bool? {
    get
    set
  }
  public var symbolPlacement: MapboxMaps.SymbolPlacement? {
    get
    set
  }
  public var symbolSpacing: Swift.Double? {
    get
    set
  }
  public var symbolZElevate: Swift.Bool? {
    get
    set
  }
  public var symbolZOrder: MapboxMaps.SymbolZOrder? {
    get
    set
  }
  public var textAllowOverlap: Swift.Bool? {
    get
    set
  }
  public var textFont: [Swift.String]? {
    get
    set
  }
  public var textIgnorePlacement: Swift.Bool? {
    get
    set
  }
  public var textKeepUpright: Swift.Bool? {
    get
    set
  }
  public var textMaxAngle: Swift.Double? {
    get
    set
  }
  public var textOptional: Swift.Bool? {
    get
    set
  }
  public var textPadding: Swift.Double? {
    get
    set
  }
  public var textPitchAlignment: MapboxMaps.TextPitchAlignment? {
    get
    set
  }
  public var textRotationAlignment: MapboxMaps.TextRotationAlignment? {
    get
    set
  }
  public var textVariableAnchor: [MapboxMaps.TextAnchor]? {
    get
    set
  }
  public var textWritingMode: [MapboxMaps.TextWritingMode]? {
    get
    set
  }
  public var iconColorSaturation: Swift.Double? {
    get
    set
  }
  public var iconOcclusionOpacity: Swift.Double? {
    get
    set
  }
  public var iconTranslate: [Swift.Double]? {
    get
    set
  }
  public var iconTranslateAnchor: MapboxMaps.IconTranslateAnchor? {
    get
    set
  }
  public var textOcclusionOpacity: Swift.Double? {
    get
    set
  }
  public var textTranslate: [Swift.Double]? {
    get
    set
  }
  public var textTranslateAnchor: MapboxMaps.TextTranslateAnchor? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @available(*, deprecated, message: "icon-text-fit property is now data driven, use `PointAnnotation.iconTextFit` instead.")
  public var iconTextFit: MapboxMaps.IconTextFit? {
    get
    set
  }
  @available(*, deprecated, message: "icon-text-fit-padding property is now data driven, use `PointAnnotation.iconTextFitPadding` instead.")
  public var iconTextFitPadding: [Swift.Double]? {
    get
    set
  }
  @objc deinit
}
@_documentation(visibility: internal) public typealias Polygon = Turf.Polygon
public struct PolygonAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var polygon: MapboxMaps.Polygon
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.PolygonAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.PolygonAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.PolygonAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, polygon: MapboxMaps.Polygon, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var fillSortKey: Swift.Double?
  public var fillColor: MapboxMaps.StyleColor?
  public var fillOpacity: Swift.Double?
  public var fillOutlineColor: MapboxMaps.StyleColor?
  public var fillPattern: Swift.String?
  public static func == (a: MapboxMaps.PolygonAnnotation, b: MapboxMaps.PolygonAnnotation) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class PolygonAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.PolygonAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var fillAntialias: Swift.Bool? {
    get
    set
  }
  public var fillEmissiveStrength: Swift.Double? {
    get
    set
  }
  public var fillTranslate: [Swift.Double]? {
    get
    set
  }
  public var fillTranslateAnchor: MapboxMaps.FillTranslateAnchor? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @objc deinit
}
public struct PolylineAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var lineString: Turf.LineString
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.PolylineAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.PolylineAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.PolylineAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, lineString: Turf.LineString, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public init(id: Swift.String = UUID().uuidString, lineCoordinates: [CoreLocation.CLLocationCoordinate2D], isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var lineJoin: MapboxMaps.LineJoin?
  public var lineSortKey: Swift.Double?
  public var lineZOffset: Swift.Double?
  public var lineBlur: Swift.Double?
  public var lineBorderColor: MapboxMaps.StyleColor?
  public var lineBorderWidth: Swift.Double?
  public var lineColor: MapboxMaps.StyleColor?
  public var lineGapWidth: Swift.Double?
  public var lineOffset: Swift.Double?
  public var lineOpacity: Swift.Double?
  public var linePattern: Swift.String?
  public var lineWidth: Swift.Double?
  public static func == (a: MapboxMaps.PolylineAnnotation, b: MapboxMaps.PolylineAnnotation) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class PolylineAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.PolylineAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var lineCap: MapboxMaps.LineCap? {
    get
    set
  }
  public var lineMiterLimit: Swift.Double? {
    get
    set
  }
  public var lineRoundLimit: Swift.Double? {
    get
    set
  }
  public var lineDasharray: [Swift.Double]? {
    get
    set
  }
  public var lineDepthOcclusionFactor: Swift.Double? {
    get
    set
  }
  public var lineEmissiveStrength: Swift.Double? {
    get
    set
  }
  public var lineOcclusionOpacity: Swift.Double? {
    get
    set
  }
  public var lineTranslate: [Swift.Double]? {
    get
    set
  }
  public var lineTranslateAnchor: MapboxMaps.LineTranslateAnchor? {
    get
    set
  }
  public var lineTrimOffset: [Swift.Double]? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Projection {
  public static let latitudeMax: CoreLocation.CLLocationDegrees
  public static let latitudeMin: Swift.Double
  public static let latitudeRange: (Swift.ClosedRange<CoreLocation.CLLocationDegrees>)
  public static func metersPerPoint(for latitude: CoreLocation.CLLocationDegrees, zoom: CoreFoundation.CGFloat) -> Swift.Double
  public static func projectedMeters(for coordinate: CoreLocation.CLLocationCoordinate2D) -> MapboxCoreMaps.ProjectedMeters
  public static func coordinate(for projectedMeters: MapboxCoreMaps.ProjectedMeters) -> CoreLocation.CLLocationCoordinate2D
  public static func project(_ coordinate: CoreLocation.CLLocationCoordinate2D, zoomScale: CoreFoundation.CGFloat) -> MapboxCoreMaps.MercatorCoordinate
  public static func unproject(_ mercatorCoordinate: MapboxCoreMaps.MercatorCoordinate, zoomScale: CoreFoundation.CGFloat) -> CoreLocation.CLLocationCoordinate2D
  @objc deinit
}
public enum PromoteId : Swift.Equatable, Swift.Codable {
  case string(Swift.String)
  case object([Swift.String : Swift.String])
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: MapboxMaps.PromoteId, b: MapboxMaps.PromoteId) -> Swift.Bool
}
public enum Visibility : Swift.String, Swift.Codable {
  case visible
  case none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct LineCap : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let butt: MapboxMaps.LineCap
  public static let round: MapboxMaps.LineCap
  public static let square: MapboxMaps.LineCap
  public typealias RawValue = Swift.String
}
public struct LineJoin : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let bevel: MapboxMaps.LineJoin
  public static let round: MapboxMaps.LineJoin
  public static let miter: MapboxMaps.LineJoin
  public static let none: MapboxMaps.LineJoin
  public typealias RawValue = Swift.String
}
public struct IconAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let center: MapboxMaps.IconAnchor
  public static let left: MapboxMaps.IconAnchor
  public static let right: MapboxMaps.IconAnchor
  public static let top: MapboxMaps.IconAnchor
  public static let bottom: MapboxMaps.IconAnchor
  public static let topLeft: MapboxMaps.IconAnchor
  public static let topRight: MapboxMaps.IconAnchor
  public static let bottomLeft: MapboxMaps.IconAnchor
  public static let bottomRight: MapboxMaps.IconAnchor
  public typealias RawValue = Swift.String
}
public struct IconPitchAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.IconPitchAlignment
  public static let viewport: MapboxMaps.IconPitchAlignment
  public static let auto: MapboxMaps.IconPitchAlignment
  public typealias RawValue = Swift.String
}
public struct IconRotationAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.IconRotationAlignment
  public static let viewport: MapboxMaps.IconRotationAlignment
  public static let auto: MapboxMaps.IconRotationAlignment
  public typealias RawValue = Swift.String
}
public struct IconTextFit : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let none: MapboxMaps.IconTextFit
  public static let width: MapboxMaps.IconTextFit
  public static let height: MapboxMaps.IconTextFit
  public static let both: MapboxMaps.IconTextFit
  public typealias RawValue = Swift.String
}
public struct SymbolPlacement : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let point: MapboxMaps.SymbolPlacement
  public static let line: MapboxMaps.SymbolPlacement
  public static let lineCenter: MapboxMaps.SymbolPlacement
  public typealias RawValue = Swift.String
}
public struct SymbolZOrder : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let auto: MapboxMaps.SymbolZOrder
  public static let viewportY: MapboxMaps.SymbolZOrder
  public static let source: MapboxMaps.SymbolZOrder
  public typealias RawValue = Swift.String
}
public struct TextAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let center: MapboxMaps.TextAnchor
  public static let left: MapboxMaps.TextAnchor
  public static let right: MapboxMaps.TextAnchor
  public static let top: MapboxMaps.TextAnchor
  public static let bottom: MapboxMaps.TextAnchor
  public static let topLeft: MapboxMaps.TextAnchor
  public static let topRight: MapboxMaps.TextAnchor
  public static let bottomLeft: MapboxMaps.TextAnchor
  public static let bottomRight: MapboxMaps.TextAnchor
  public typealias RawValue = Swift.String
}
public struct TextJustify : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let auto: MapboxMaps.TextJustify
  public static let left: MapboxMaps.TextJustify
  public static let center: MapboxMaps.TextJustify
  public static let right: MapboxMaps.TextJustify
  public typealias RawValue = Swift.String
}
public struct TextPitchAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.TextPitchAlignment
  public static let viewport: MapboxMaps.TextPitchAlignment
  public static let auto: MapboxMaps.TextPitchAlignment
  public typealias RawValue = Swift.String
}
public struct TextRotationAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.TextRotationAlignment
  public static let viewport: MapboxMaps.TextRotationAlignment
  public static let auto: MapboxMaps.TextRotationAlignment
  public typealias RawValue = Swift.String
}
public struct TextTransform : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let none: MapboxMaps.TextTransform
  public static let uppercase: MapboxMaps.TextTransform
  public static let lowercase: MapboxMaps.TextTransform
  public typealias RawValue = Swift.String
}
public struct FillTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.FillTranslateAnchor
  public static let viewport: MapboxMaps.FillTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct LineTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.LineTranslateAnchor
  public static let viewport: MapboxMaps.LineTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct IconTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.IconTranslateAnchor
  public static let viewport: MapboxMaps.IconTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct TextTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.TextTranslateAnchor
  public static let viewport: MapboxMaps.TextTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct CirclePitchAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.CirclePitchAlignment
  public static let viewport: MapboxMaps.CirclePitchAlignment
  public typealias RawValue = Swift.String
}
public struct CirclePitchScale : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.CirclePitchScale
  public static let viewport: MapboxMaps.CirclePitchScale
  public typealias RawValue = Swift.String
}
public struct CircleTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.CircleTranslateAnchor
  public static let viewport: MapboxMaps.CircleTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct FillExtrusionTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.FillExtrusionTranslateAnchor
  public static let viewport: MapboxMaps.FillExtrusionTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct RasterResampling : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let linear: MapboxMaps.RasterResampling
  public static let nearest: MapboxMaps.RasterResampling
  public typealias RawValue = Swift.String
}
public struct HillshadeIlluminationAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.HillshadeIlluminationAnchor
  public static let viewport: MapboxMaps.HillshadeIlluminationAnchor
  public typealias RawValue = Swift.String
}
public struct ModelScaleMode : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.ModelScaleMode
  public static let viewport: MapboxMaps.ModelScaleMode
  public typealias RawValue = Swift.String
}
public struct ModelType : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let common3d: MapboxMaps.ModelType
  public static let locationIndicator: MapboxMaps.ModelType
  public typealias RawValue = Swift.String
}
public struct SkyType : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let gradient: MapboxMaps.SkyType
  public static let atmosphere: MapboxMaps.SkyType
  public typealias RawValue = Swift.String
}
public struct Anchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.Anchor
  public static let viewport: MapboxMaps.Anchor
  public typealias RawValue = Swift.String
}
public struct StyleProjectionName : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let mercator: MapboxMaps.StyleProjectionName
  public static let globe: MapboxMaps.StyleProjectionName
  public typealias RawValue = Swift.String
}
public struct TextWritingMode : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let horizontal: MapboxMaps.TextWritingMode
  public static let vertical: MapboxMaps.TextWritingMode
  public typealias RawValue = Swift.String
}
public struct PuckRenderingData : Swift.Equatable {
  public var location: MapboxCommon.Location
  public var heading: MapboxMaps.Heading?
  public init(location: MapboxCommon.Location, heading: MapboxMaps.Heading? = nil)
  public static func == (a: MapboxMaps.PuckRenderingData, b: MapboxMaps.PuckRenderingData) -> Swift.Bool
}
public enum PuckType : Swift.Equatable {
  case puck2D(_: MapboxMaps.Puck2DConfiguration = Puck2DConfiguration())
  case puck3D(MapboxMaps.Puck3DConfiguration)
  public static func == (a: MapboxMaps.PuckType, b: MapboxMaps.PuckType) -> Swift.Bool
}
public struct Puck2DConfiguration : Swift.Equatable {
  public struct Pulsing : Swift.Equatable {
    public static let `default`: MapboxMaps.Puck2DConfiguration.Pulsing
    public enum Radius : Swift.Equatable {
      case constant(Swift.Double)
      case accuracy
      public static func == (a: MapboxMaps.Puck2DConfiguration.Pulsing.Radius, b: MapboxMaps.Puck2DConfiguration.Pulsing.Radius) -> Swift.Bool
    }
    public var isEnabled: Swift.Bool
    public var color: UIKit.UIColor
    public var radius: MapboxMaps.Puck2DConfiguration.Pulsing.Radius
    public init(color: UIKit.UIColor = UIColor(red: 0.29, green: 0.565, blue: 0.886, alpha: 1), radius: MapboxMaps.Puck2DConfiguration.Pulsing.Radius = .constant(30))
    public static func == (a: MapboxMaps.Puck2DConfiguration.Pulsing, b: MapboxMaps.Puck2DConfiguration.Pulsing) -> Swift.Bool
  }
  public var opacity: Swift.Double
  public var topImage: UIKit.UIImage?
  public var bearingImage: UIKit.UIImage?
  public var shadowImage: UIKit.UIImage?
  public var scale: MapboxMaps.Value<Swift.Double>?
  public var pulsing: MapboxMaps.Puck2DConfiguration.Pulsing?
  public var showsAccuracyRing: Swift.Bool
  public var accuracyRingColor: UIKit.UIColor
  public var accuracyRingBorderColor: UIKit.UIColor
  public var slot: MapboxMaps.Slot?
  public var layerPosition: MapboxMaps.LayerPosition?
  public init(topImage: UIKit.UIImage? = nil, bearingImage: UIKit.UIImage? = nil, shadowImage: UIKit.UIImage? = nil, scale: MapboxMaps.Value<Swift.Double>? = nil, pulsing: MapboxMaps.Puck2DConfiguration.Pulsing? = nil, showsAccuracyRing: Swift.Bool = false, opacity: Swift.Double = 1)
  public init(topImage: UIKit.UIImage? = nil, bearingImage: UIKit.UIImage? = nil, shadowImage: UIKit.UIImage? = nil, scale: MapboxMaps.Value<Swift.Double>? = nil, showsAccuracyRing: Swift.Bool = false, accuracyRingColor: UIKit.UIColor = UIColor(red: 0.537, green: 0.812, blue: 0.941, alpha: 0.3), accuracyRingBorderColor: UIKit.UIColor = UIColor(red: 0.537, green: 0.812, blue: 0.941, alpha: 0.3), opacity: Swift.Double = 1, layerPosition: MapboxMaps.LayerPosition? = nil)
  public static func makeDefault(showBearing: Swift.Bool = false) -> MapboxMaps.Puck2DConfiguration
  public static func == (a: MapboxMaps.Puck2DConfiguration, b: MapboxMaps.Puck2DConfiguration) -> Swift.Bool
}
public struct Puck3DConfiguration : Swift.Equatable {
  public var model: MapboxMaps.Model
  public var modelScale: MapboxMaps.Value<[Swift.Double]>?
  public var modelRotation: MapboxMaps.Value<[Swift.Double]>?
  public var modelOpacity: MapboxMaps.Value<Swift.Double>?
  public var modelEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var slot: MapboxMaps.Slot?
  public var layerPosition: MapboxMaps.LayerPosition?
  public init(model: MapboxMaps.Model, modelScale: MapboxMaps.Value<[Swift.Double]>? = nil, modelRotation: MapboxMaps.Value<[Swift.Double]>? = nil, modelOpacity: MapboxMaps.Value<Swift.Double>? = nil, layerPosition: MapboxMaps.LayerPosition? = nil)
  public static func == (a: MapboxMaps.Puck3DConfiguration, b: MapboxMaps.Puck3DConfiguration) -> Swift.Bool
}
extension MapboxCoreMaps.QueriedFeature {
  public var feature: MapboxMaps.Feature {
    get
  }
}
public struct RasterDemSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var tiles: [Swift.String]?
  public var bounds: [Swift.Double]?
  public var minzoom: Swift.Double?
  public var maxzoom: Swift.Double?
  public var tileSize: Swift.Double?
  public var attribution: Swift.String?
  public var encoding: MapboxMaps.Encoding?
  public var volatile: Swift.Bool?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public var minimumTileUpdateInterval: Swift.Double?
  public var maxOverscaleFactorForParentTiles: Swift.Double?
  public var tileRequestsDelay: Swift.Double?
  public var tileNetworkRequestsDelay: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.RasterDemSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct RasterLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var rasterBrightnessMax: MapboxMaps.Value<Swift.Double>?
  public var rasterBrightnessMaxTransition: MapboxMaps.StyleTransition?
  public var rasterBrightnessMin: MapboxMaps.Value<Swift.Double>?
  public var rasterBrightnessMinTransition: MapboxMaps.StyleTransition?
  public var rasterColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var rasterColorMix: MapboxMaps.Value<[Swift.Double]>?
  public var rasterColorMixTransition: MapboxMaps.StyleTransition?
  public var rasterColorRange: MapboxMaps.Value<[Swift.Double]>?
  public var rasterColorRangeTransition: MapboxMaps.StyleTransition?
  public var rasterContrast: MapboxMaps.Value<Swift.Double>?
  public var rasterContrastTransition: MapboxMaps.StyleTransition?
  public var rasterEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var rasterEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var rasterFadeDuration: MapboxMaps.Value<Swift.Double>?
  public var rasterHueRotate: MapboxMaps.Value<Swift.Double>?
  public var rasterHueRotateTransition: MapboxMaps.StyleTransition?
  public var rasterOpacity: MapboxMaps.Value<Swift.Double>?
  public var rasterOpacityTransition: MapboxMaps.StyleTransition?
  public var rasterResampling: MapboxMaps.Value<MapboxMaps.RasterResampling>?
  public var rasterSaturation: MapboxMaps.Value<Swift.Double>?
  public var rasterSaturationTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.RasterLayer, b: MapboxMaps.RasterLayer) -> Swift.Bool
}
public struct RasterSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var tiles: [Swift.String]?
  public var bounds: [Swift.Double]?
  public var minzoom: Swift.Double?
  public var maxzoom: Swift.Double?
  public var tileSize: Swift.Double?
  public var scheme: MapboxMaps.Scheme?
  public var attribution: Swift.String?
  public var volatile: Swift.Bool?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public var minimumTileUpdateInterval: Swift.Double?
  public var maxOverscaleFactorForParentTiles: Swift.Double?
  public var tileRequestsDelay: Swift.Double?
  public var tileNetworkRequestsDelay: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.RasterSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
extension MapboxCoreMaps.RenderedQueryOptions {
  convenience public init(layerIds: [Swift.String]?, filter: MapboxMaps.Expression?)
  public var filter: MapboxMaps.Expression? {
    get
  }
}
public enum ResolvedImage : Swift.Codable {
  case name(Swift.String)
  case data(MapboxMaps.ResolvedImageData)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ResolvedImageData : Swift.Codable, Swift.Equatable {
  public var available: Swift.Bool
  public var name: Swift.String
  public static func == (a: MapboxMaps.ResolvedImageData, b: MapboxMaps.ResolvedImageData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.ResolvedImage : Swift.Equatable {
  public static func == (lhs: MapboxMaps.ResolvedImage, rhs: MapboxMaps.ResolvedImage) -> Swift.Bool
}
@available(iOS 13.0, *)
extension MapboxMaps.Signal : Combine.Publisher {
  public typealias Output = Payload
  public typealias Failure = Swift.Never
  public func receive<S>(subscriber: S) where Payload == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
}
@available(iOS 13.0, *)
extension Combine.Publisher where Self.Failure == Swift.Never {
  public func eraseToSignal() -> MapboxMaps.Signal<Self.Output>
}
public struct Signal<Payload> {
  public typealias Handler = (Payload) -> Swift.Void
  public typealias ObserveImpl = (@escaping MapboxMaps.Signal<Payload>.Handler) -> MapboxMaps.AnyCancelable
  public func observe(_ handler: @escaping MapboxMaps.Signal<Payload>.Handler) -> MapboxMaps.AnyCancelable
  public init(observeImpl: @escaping MapboxMaps.Signal<Payload>.ObserveImpl)
}
extension MapboxMaps.Signal {
  public init(just constant: Payload)
  public func observeNext(_ handler: @escaping MapboxMaps.Signal<Payload>.Handler) -> MapboxMaps.AnyCancelable
}
public struct SkyLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var skyAtmosphereColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var skyAtmosphereHaloColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var skyAtmosphereSun: MapboxMaps.Value<[Swift.Double]>?
  public var skyAtmosphereSunIntensity: MapboxMaps.Value<Swift.Double>?
  public var skyGradient: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var skyGradientCenter: MapboxMaps.Value<[Swift.Double]>?
  public var skyGradientRadius: MapboxMaps.Value<Swift.Double>?
  public var skyOpacity: MapboxMaps.Value<Swift.Double>?
  public var skyOpacityTransition: MapboxMaps.StyleTransition?
  public var skyType: MapboxMaps.Value<MapboxMaps.SkyType>?
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.SkyLayer, b: MapboxMaps.SkyLayer) -> Swift.Bool
}
public struct Slot : Swift.Hashable, Swift.Codable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public static let top: MapboxMaps.Slot?
  public static let middle: MapboxMaps.Slot?
  public static let bottom: MapboxMaps.Slot?
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct SlotLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.SlotLayer, b: MapboxMaps.SlotLayer) -> Swift.Bool
}
public struct SnapshotOverlay {
  public var context: CoreGraphics.CGContext {
    get
  }
  public var scale: CoreFoundation.CGFloat {
    get
  }
  public var pointForCoordinate: ((CoreLocation.CLLocationCoordinate2D) -> CoreFoundation.CGPoint) {
    get
  }
  public var coordinateForPoint: ((CoreFoundation.CGPoint) -> CoreLocation.CLLocationCoordinate2D) {
    get
  }
}
public typealias SnapshotOverlayHandler = ((MapboxMaps.SnapshotOverlay) -> Swift.Void)
@_hasMissingDesignatedInitializers public class Snapshotter : MapboxMaps.StyleManager {
  @available(*, deprecated, message: "Access style APIs directly from Snapshotter instance instead")
  public var style: MapboxMaps.StyleManager {
    get
  }
  convenience public init(options: MapboxMaps.MapSnapshotOptions)
  public var snapshotSize: CoreFoundation.CGSize {
    get
    set(newSize)
  }
  public var cameraState: MapboxMaps.CameraState {
    get
  }
  public func setCamera(to cameraOptions: MapboxMaps.CameraOptions)
  public func start(overlayHandler: MapboxMaps.SnapshotOverlayHandler?, completion: @escaping (Swift.Result<UIKit.UIImage, MapboxMaps.Snapshotter.SnapshotError>) -> Swift.Void)
  public func cancel()
  public enum SnapshotError : Swift.Error {
    case unknown
    case snapshotFailed(reason: Swift.String?)
  }
  public func coordinateBounds(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBounds
  public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], padding: UIKit.UIEdgeInsets?, bearing: Swift.Double?, pitch: Swift.Double?) -> MapboxMaps.CameraOptions
  @objc deinit
}
extension MapboxMaps.Snapshotter {
  public var onMapLoadingError: MapboxMaps.Signal<MapboxCoreMaps.MapLoadingError> {
    get
  }
  public var onStyleLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleLoaded> {
    get
  }
  public var onStyleDataLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleDataLoaded> {
    get
  }
  public var onStyleImageMissing: MapboxMaps.Signal<MapboxCoreMaps.StyleImageMissing> {
    get
  }
  @available(*, deprecated, message: "Use snapshotter.on<eventType>.observeNext instead.")
  @discardableResult
  public func onNext<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
  @available(*, deprecated, message: "Use snapshotter.on<eventType>.observe instead.")
  @discardableResult
  public func onEvery<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.Snapshotter {
  public func clearData(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
}
public protocol Source : MapboxMaps.StyleDecodable, MapboxMaps.StyleEncodable, Swift.Decodable, Swift.Encodable {
  var type: MapboxMaps.SourceType { get }
  var id: Swift.String { get }
}
extension MapboxMaps.Source {
  public init(jsonObject: [Swift.String : Any]) throws
}
public struct SourceInfo {
  public var id: Swift.String
  public var type: MapboxMaps.SourceType
  public init(id: Swift.String, type: MapboxMaps.SourceType)
}
public struct Scheme : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let xyz: MapboxMaps.Scheme
  public static let tms: MapboxMaps.Scheme
  public typealias RawValue = Swift.String
}
public struct Encoding : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let terrarium: MapboxMaps.Encoding
  public static let mapbox: MapboxMaps.Encoding
  public typealias RawValue = Swift.String
}
public struct SourceType : Swift.ExpressibleByStringLiteral, Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public static let vector: MapboxMaps.SourceType
  public static let raster: MapboxMaps.SourceType
  public static let rasterDem: MapboxMaps.SourceType
  public static let geoJson: MapboxMaps.SourceType
  public static let image: MapboxMaps.SourceType
  public static let model: MapboxMaps.SourceType
  public static let customGeometry: MapboxMaps.SourceType
  public init(stringLiteral type: Swift.String)
  public init(rawValue: Swift.String)
  public var sourceType: (any MapboxMaps.Source.Type)? {
    get
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@_documentation(visibility: internal) extension MapboxMaps.StyleManager {
  @available(*, deprecated, renamed: "styleURI")
  public var uri: MapboxMaps.StyleURI? {
    get
    set
  }
  @available(*, deprecated, renamed: "styleJSON")
  public var JSON: Swift.String {
    get
    set
  }
  @available(*, deprecated, renamed: "styleTransition")
  public var transition: MapboxMaps.TransitionOptions {
    get
    set
  }
  @available(*, deprecated, renamed: "isStyleLoaded")
  public var isLoaded: Swift.Bool {
    get
  }
  @available(*, deprecated, renamed: "styleDefaultCamera")
  public var defaultCamera: MapboxMaps.CameraOptions {
    get
  }
}
extension MapboxMaps.StyleManager {
  public func localizeLabels(into locale: Foundation.Locale, forLayerIds layerIds: [Swift.String]? = nil) throws
}
public struct StyleColor : Swift.Codable, Swift.Equatable, Swift.RawRepresentable, Swift.ExpressibleByStringInterpolation {
  public let rawValue: Swift.String
  @available(*, unavailable, message: "Inspect color components by accessing the 'rawValue' property.")
  public var red: Swift.Double {
    get
  }
  @available(*, unavailable, message: "Inspect color components by accessing the 'rawValue' property.")
  public var green: Swift.Double {
    get
  }
  @available(*, unavailable, message: "Inspect color components by accessing the 'rawValue' property.")
  public var blue: Swift.Double {
    get
  }
  public init?(red: Swift.Double, green: Swift.Double, blue: Swift.Double)
  public init?(red: Swift.Double, green: Swift.Double, blue: Swift.Double, alpha: Swift.Double)
  public init?(hue: Swift.Double, saturation: Swift.Double, lightness: Swift.Double)
  public init?(hue: Swift.Double, saturation: Swift.Double, lightness: Swift.Double, alpha: Swift.Double)
  public init(_ color: UIKit.UIColor)
  public init(rawValue: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias RawValue = Swift.String
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
public protocol StyleEncodable {
  func jsonObject() throws -> [Swift.String : Any]
}
public protocol StyleDecodable {
  init(jsonObject: [Swift.String : Any]) throws
}
extension MapboxMaps.StyleEncodable where Self : Swift.Encodable {
  public func jsonObject() throws -> [Swift.String : Any]
  public func allStyleProperties() throws -> [Swift.String : Any]
}
public struct StyleError : Swift.RawRepresentable, Foundation.LocalizedError {
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct CancelError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct TypeConversionError : Swift.Error, Swift.Equatable {
  public let message: Swift.String
  public static let invalidObject: MapboxMaps.TypeConversionError
  public static let unexpectedType: MapboxMaps.TypeConversionError
  public static let unsuccessfulConversion: MapboxMaps.TypeConversionError
  public static func == (a: MapboxMaps.TypeConversionError, b: MapboxMaps.TypeConversionError) -> Swift.Bool
}
public struct MapError : Foundation.LocalizedError {
  public var errorDescription: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class StyleManager {
  public func addLayer(_ layer: any MapboxMaps.Layer, layerPosition: MapboxMaps.LayerPosition? = nil) throws
  public func addPersistentLayer(_ layer: any MapboxMaps.Layer, layerPosition: MapboxMaps.LayerPosition? = nil) throws
  public func layer<T>(withId id: Swift.String, type: T.Type) throws -> T where T : MapboxMaps.Layer
  public func layer(withId id: Swift.String) throws -> any MapboxMaps.Layer
  public func updateLayer<T>(withId id: Swift.String, type: T.Type, update: (inout T) throws -> Swift.Void) throws where T : MapboxMaps.Layer
  public func addSource(_ source: any MapboxMaps.Source, dataId: Swift.String? = nil) throws
  public func source<T>(withId id: Swift.String, type: T.Type) throws -> T where T : MapboxMaps.Source
  public func source(withId id: Swift.String) throws -> any MapboxMaps.Source
  public func updateGeoJSONSource(withId id: Swift.String, data: MapboxMaps.GeoJSONSourceData, dataId: Swift.String? = nil)
  public func updateGeoJSONSource(withId id: Swift.String, geoJSON: Turf.GeoJSONObject, dataId: Swift.String? = nil)
  public func addGeoJSONSourceFeatures(forSourceId sourceId: Swift.String, features: [MapboxMaps.Feature], dataId: Swift.String? = nil)
  public func updateGeoJSONSourceFeatures(forSourceId sourceId: Swift.String, features: [MapboxMaps.Feature], dataId: Swift.String? = nil)
  public func removeGeoJSONSourceFeatures(forSourceId sourceId: Swift.String, featureIds: [Swift.String], dataId: Swift.String? = nil)
  public var isStyleLoaded: Swift.Bool {
    get
  }
  public var styleURI: MapboxMaps.StyleURI? {
    get
    set
  }
  public var styleJSON: Swift.String {
    get
    set
  }
  public var styleDefaultCamera: MapboxMaps.CameraOptions {
    get
  }
  public var styleTransition: MapboxMaps.TransitionOptions {
    get
    set
  }
  public var styleImports: [MapboxCoreMaps.StyleObjectInfo] {
    get
  }
  public func getStyleImportSchema(for importId: Swift.String) throws -> Any
  public func getStyleImportConfigProperties(for importId: Swift.String) throws -> [Swift.String : MapboxCoreMaps.StylePropertyValue]
  public func getStyleImportConfigProperty(for importId: Swift.String, config: Swift.String) throws -> MapboxCoreMaps.StylePropertyValue
  public func setStyleImportConfigProperties(for importId: Swift.String, configs: [Swift.String : Any]) throws
  public func setStyleImportConfigProperty(for importId: Swift.String, config: Swift.String, value: Any) throws
  public func addLayer(with properties: [Swift.String : Any], layerPosition: MapboxMaps.LayerPosition?) throws
  public func moveLayer(withId id: Swift.String, to position: MapboxMaps.LayerPosition) throws
  public func addPersistentLayer(with properties: [Swift.String : Any], layerPosition: MapboxMaps.LayerPosition?) throws
  public func isPersistentLayer(id: Swift.String) throws -> Swift.Bool
  public func addPersistentCustomLayer(withId id: Swift.String, layerHost: any MapboxCoreMaps.CustomLayerHost, layerPosition: MapboxMaps.LayerPosition?) throws
  public func addCustomLayer(withId id: Swift.String, layerHost: any MapboxCoreMaps.CustomLayerHost, layerPosition: MapboxMaps.LayerPosition?) throws
  public func removeLayer(withId id: Swift.String) throws
  public func layerExists(withId id: Swift.String) -> Swift.Bool
  public var allLayerIdentifiers: [MapboxMaps.LayerInfo] {
    get
  }
  public func layerPropertyValue(for layerId: Swift.String, property: Swift.String) -> Any
  public func layerProperty(for layerId: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setLayerProperty(for layerId: Swift.String, property: Swift.String, value: Any) throws
  public static func layerPropertyDefaultValue(for layerType: MapboxMaps.LayerType, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func layerProperties(for layerId: Swift.String) throws -> [Swift.String : Any]
  public func setLayerProperties(for layerId: Swift.String, properties: [Swift.String : Any]) throws
  public func addSource(withId id: Swift.String, properties: [Swift.String : Any]) throws
  public func removeSource(withId id: Swift.String) throws
  public func sourceExists(withId id: Swift.String) -> Swift.Bool
  public var allSourceIdentifiers: [MapboxMaps.SourceInfo] {
    get
  }
  public func sourceProperty(for sourceId: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setSourceProperty(for sourceId: Swift.String, property: Swift.String, value: Any) throws
  public func sourceProperties(for sourceId: Swift.String) throws -> [Swift.String : Any]
  public func setSourceProperties(for sourceId: Swift.String, properties: [Swift.String : Any]) throws
  public static func sourcePropertyDefaultValue(for sourceType: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func updateImageSource(withId id: Swift.String, image: UIKit.UIImage) throws
  public func addImage(_ image: UIKit.UIImage, id: Swift.String, sdf: Swift.Bool = false, stretchX: [MapboxCoreMaps.ImageStretches], stretchY: [MapboxCoreMaps.ImageStretches], content: MapboxCoreMaps.ImageContent? = nil) throws
  public func addImage(_ image: UIKit.UIImage, id: Swift.String, sdf: Swift.Bool = false, contentInsets: UIKit.UIEdgeInsets = .zero) throws
  public func removeImage(withId id: Swift.String) throws
  public func imageExists(withId id: Swift.String) -> Swift.Bool
  public func image(withId id: Swift.String) -> UIKit.UIImage?
  public var allLightIdentifiers: [MapboxMaps.LightInfo] {
    get
  }
  public func lightProperty(for lightId: Swift.String, property: Swift.String) -> Any
  public func lightPropertyValue(for lightId: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setLights(_ flatLight: MapboxMaps.FlatLight) throws
  public func setLights(ambient ambientLight: MapboxMaps.AmbientLight, directional directionalLight: MapboxMaps.DirectionalLight) throws
  public func setLightProperty(for lightId: Swift.String, property: Swift.String, value: Any) throws
  public func setTerrain(_ terrain: MapboxMaps.Terrain) throws
  public func removeTerrain()
  public func setTerrain(properties: [Swift.String : Any]) throws
  public func setTerrainProperty(_ property: Swift.String, value: Any) throws
  public func terrainProperty(_ property: Swift.String) -> Any
  public func terrainProperty(_ property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setAtmosphere(_ atmosphere: MapboxMaps.Atmosphere) throws
  public func removeAtmosphere() throws
  public func setAtmosphere(properties: [Swift.String : Any]) throws
  public func setAtmosphereProperty(_ property: Swift.String, value: Any) throws
  public func atmosphereProperty(_ property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func addCustomGeometrySource(withId id: Swift.String, options: MapboxCoreMaps.CustomGeometrySourceOptions) throws
  public func setCustomGeometrySourceTileData(forSourceId sourceId: Swift.String, tileId: MapboxCoreMaps.CanonicalTileID, features: [MapboxMaps.Feature]) throws
  public func invalidateCustomGeometrySourceTile(forSourceId sourceId: Swift.String, tileId: MapboxCoreMaps.CanonicalTileID) throws
  public func invalidateCustomGeometrySourceRegion(forSourceId sourceId: Swift.String, bounds: MapboxCoreMaps.CoordinateBounds) throws
  public func addStyleImport(withId id: Swift.String, uri: MapboxMaps.StyleURI, config: [Swift.String : Any]? = nil, importPosition: MapboxMaps.ImportPosition? = nil) throws
  public func addStyleImport(withId id: Swift.String, json: Swift.String, config: [Swift.String : Any]? = nil, importPosition: MapboxMaps.ImportPosition? = nil) throws
  public func updateStyleImport(withId id: Swift.String, uri: MapboxMaps.StyleURI, config: [Swift.String : Any]? = nil) throws
  public func updateStyleImport(withId id: Swift.String, json: Swift.String, config: [Swift.String : Any]? = nil) throws
  public func moveStyleImport(withId id: Swift.String, to position: MapboxMaps.ImportPosition) throws
  public func removeStyleImport(withId id: Swift.String) throws
  @available(*, deprecated, renamed: "removeStyleImport(withId:)", message: "Please use the removeStyleImport(withId:) version.")
  public func removeStyleImport(for importId: Swift.String) throws
  @objc deinit
}
extension MapboxMaps.StyleManager {
  public func setProjection(_ projection: MapboxMaps.StyleProjection) throws
  public var projection: MapboxMaps.StyleProjection? {
    get
  }
}
public struct StyleTransition : Swift.Codable, Swift.Equatable {
  public static let zero: MapboxMaps.StyleTransition
  public var duration: Swift.Double
  public var delay: Swift.Double
  public init(duration: Foundation.TimeInterval, delay: Foundation.TimeInterval)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: MapboxMaps.StyleTransition, b: MapboxMaps.StyleTransition) -> Swift.Bool
}
extension MapboxCoreMaps.StylePackLoadOptions {
  convenience public init?(glyphsRasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode?, metadata: Any? = nil, acceptExpired: Swift.Bool = false, extraOptions: Any? = nil)
  public var glyphsRasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode? {
    get
  }
}
public struct StyleProjection : Swift.Hashable, Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public var name: MapboxMaps.StyleProjectionName
  public init(name: MapboxMaps.StyleProjectionName)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.StyleProjection, b: MapboxMaps.StyleProjection) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct StyleURI : Swift.Hashable, Swift.RawRepresentable {
  public typealias RawValue = Swift.String
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init?(url: Foundation.URL)
  public static let streets: MapboxMaps.StyleURI
  public static let outdoors: MapboxMaps.StyleURI
  public static let light: MapboxMaps.StyleURI
  public static let dark: MapboxMaps.StyleURI
  public static let satellite: MapboxMaps.StyleURI
  public static let satelliteStreets: MapboxMaps.StyleURI
  public static let standard: MapboxMaps.StyleURI
}
public struct SymbolLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var iconAllowOverlap: MapboxMaps.Value<Swift.Bool>?
  public var iconAnchor: MapboxMaps.Value<MapboxMaps.IconAnchor>?
  public var iconIgnorePlacement: MapboxMaps.Value<Swift.Bool>?
  public var iconImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var iconKeepUpright: MapboxMaps.Value<Swift.Bool>?
  public var iconOffset: MapboxMaps.Value<[Swift.Double]>?
  public var iconOptional: MapboxMaps.Value<Swift.Bool>?
  public var iconPadding: MapboxMaps.Value<Swift.Double>?
  public var iconPitchAlignment: MapboxMaps.Value<MapboxMaps.IconPitchAlignment>?
  public var iconRotate: MapboxMaps.Value<Swift.Double>?
  public var iconRotationAlignment: MapboxMaps.Value<MapboxMaps.IconRotationAlignment>?
  public var iconSize: MapboxMaps.Value<Swift.Double>?
  public var iconTextFit: MapboxMaps.Value<MapboxMaps.IconTextFit>?
  public var iconTextFitPadding: MapboxMaps.Value<[Swift.Double]>?
  public var symbolAvoidEdges: MapboxMaps.Value<Swift.Bool>?
  public var symbolPlacement: MapboxMaps.Value<MapboxMaps.SymbolPlacement>?
  public var symbolSortKey: MapboxMaps.Value<Swift.Double>?
  public var symbolSpacing: MapboxMaps.Value<Swift.Double>?
  public var symbolZElevate: MapboxMaps.Value<Swift.Bool>?
  public var symbolZOrder: MapboxMaps.Value<MapboxMaps.SymbolZOrder>?
  public var textAllowOverlap: MapboxMaps.Value<Swift.Bool>?
  public var textAnchor: MapboxMaps.Value<MapboxMaps.TextAnchor>?
  public var textField: MapboxMaps.Value<Swift.String>?
  public var textFont: MapboxMaps.Value<[Swift.String]>?
  public var textIgnorePlacement: MapboxMaps.Value<Swift.Bool>?
  public var textJustify: MapboxMaps.Value<MapboxMaps.TextJustify>?
  public var textKeepUpright: MapboxMaps.Value<Swift.Bool>?
  public var textLetterSpacing: MapboxMaps.Value<Swift.Double>?
  public var textLineHeight: MapboxMaps.Value<Swift.Double>?
  public var textMaxAngle: MapboxMaps.Value<Swift.Double>?
  public var textMaxWidth: MapboxMaps.Value<Swift.Double>?
  public var textOffset: MapboxMaps.Value<[Swift.Double]>?
  public var textOptional: MapboxMaps.Value<Swift.Bool>?
  public var textPadding: MapboxMaps.Value<Swift.Double>?
  public var textPitchAlignment: MapboxMaps.Value<MapboxMaps.TextPitchAlignment>?
  public var textRadialOffset: MapboxMaps.Value<Swift.Double>?
  public var textRotate: MapboxMaps.Value<Swift.Double>?
  public var textRotationAlignment: MapboxMaps.Value<MapboxMaps.TextRotationAlignment>?
  public var textSize: MapboxMaps.Value<Swift.Double>?
  public var textTransform: MapboxMaps.Value<MapboxMaps.TextTransform>?
  public var textVariableAnchor: MapboxMaps.Value<[MapboxMaps.TextAnchor]>?
  public var textWritingMode: MapboxMaps.Value<[MapboxMaps.TextWritingMode]>?
  public var iconColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var iconColorTransition: MapboxMaps.StyleTransition?
  public var iconColorSaturation: MapboxMaps.Value<Swift.Double>?
  public var iconColorSaturationTransition: MapboxMaps.StyleTransition?
  public var iconEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var iconEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var iconHaloBlur: MapboxMaps.Value<Swift.Double>?
  public var iconHaloBlurTransition: MapboxMaps.StyleTransition?
  public var iconHaloColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var iconHaloColorTransition: MapboxMaps.StyleTransition?
  public var iconHaloWidth: MapboxMaps.Value<Swift.Double>?
  public var iconHaloWidthTransition: MapboxMaps.StyleTransition?
  public var iconImageCrossFade: MapboxMaps.Value<Swift.Double>?
  public var iconImageCrossFadeTransition: MapboxMaps.StyleTransition?
  public var iconOpacity: MapboxMaps.Value<Swift.Double>?
  public var iconOpacityTransition: MapboxMaps.StyleTransition?
  public var iconTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var iconTranslateTransition: MapboxMaps.StyleTransition?
  public var iconTranslateAnchor: MapboxMaps.Value<MapboxMaps.IconTranslateAnchor>?
  public var textColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var textColorTransition: MapboxMaps.StyleTransition?
  public var textEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var textEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var textHaloBlur: MapboxMaps.Value<Swift.Double>?
  public var textHaloBlurTransition: MapboxMaps.StyleTransition?
  public var textHaloColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var textHaloColorTransition: MapboxMaps.StyleTransition?
  public var textHaloWidth: MapboxMaps.Value<Swift.Double>?
  public var textHaloWidthTransition: MapboxMaps.StyleTransition?
  public var textOpacity: MapboxMaps.Value<Swift.Double>?
  public var textOpacityTransition: MapboxMaps.StyleTransition?
  public var textTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var textTranslateTransition: MapboxMaps.StyleTransition?
  public var textTranslateAnchor: MapboxMaps.Value<MapboxMaps.TextTranslateAnchor>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.SymbolLayer, b: MapboxMaps.SymbolLayer) -> Swift.Bool
}
public struct Terrain : Swift.Codable, Swift.Equatable {
  public var source: Swift.String
  public init(sourceId: Swift.String)
  public var exaggeration: MapboxMaps.Value<Swift.Double>?
  public var exaggerationTransition: MapboxMaps.StyleTransition?
  public static func == (a: MapboxMaps.Terrain, b: MapboxMaps.Terrain) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public enum TileCacheBudgetSize {
  case tiles(Swift.Int)
  case megabytes(Swift.Int)
}
extension MapboxMaps.TileCacheBudgetSize : Swift.Codable, Swift.Equatable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: MapboxMaps.TileCacheBudgetSize, b: MapboxMaps.TileCacheBudgetSize) -> Swift.Bool
}
extension MapboxCommon.TileRegionLoadOptions {
  convenience public init?(geometry: MapboxMaps.Geometry?, descriptors: [MapboxCommon.TilesetDescriptor]? = nil, metadata: Any? = nil, acceptExpired: Swift.Bool = false, networkRestriction: MapboxCommon.NetworkRestriction = .none, averageBytesPerSecond: Swift.Int? = nil, extraOptions: Any? = nil)
  public var averageBytesPerSecond: Swift.Int? {
    get
  }
  public var geometry: MapboxMaps.Geometry? {
    get
  }
}
extension MapboxCommon.TileStore {
  public static var `default`: MapboxCommon.TileStore {
    get
  }
  public static func shared(for filePathURL: Foundation.URL) -> MapboxCommon.TileStore
  @discardableResult
  public func loadTileRegion(forId id: Swift.String, loadOptions: MapboxCommon.TileRegionLoadOptions, progress: MapboxCommon.TileRegionLoadProgressCallback? = nil, completion: @escaping (Swift.Result<MapboxCommon.TileRegion, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  public func estimateTileRegion(forId id: Swift.String, loadOptions: MapboxCommon.TileRegionLoadOptions, estimateOptions: MapboxCommon.TileRegionEstimateOptions? = nil, progress: @escaping MapboxCommon.TileRegionEstimateProgressCallback, completion: @escaping (Swift.Result<MapboxCommon.TileRegionEstimateResult, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  public func tileRegionContainsDescriptors(forId id: Swift.String, descriptors: [MapboxCommon.TilesetDescriptor], completion: @escaping (Swift.Result<Swift.Bool, any Swift.Error>) -> Swift.Void)
  public func allTileRegions(completion: @escaping (Swift.Result<[MapboxCommon.TileRegion], any Swift.Error>) -> Swift.Void)
  public func tileRegion(forId id: Swift.String, completion: @escaping (Swift.Result<MapboxCommon.TileRegion, any Swift.Error>) -> Swift.Void)
  public func tileRegionGeometry(forId id: Swift.String, completion: @escaping (Swift.Result<MapboxMaps.Geometry, any Swift.Error>) -> Swift.Void)
  public func tileRegionMetadata(forId id: Swift.String, completion: @escaping (Swift.Result<Any, any Swift.Error>) -> Swift.Void)
  public func subscribe(_ observer: any MapboxMaps.TileStoreObserver) -> any MapboxCommon.Cancelable
  public func removeRegion(forId id: Swift.String, completion: @escaping (Swift.Result<MapboxCommon.TileRegion, any Swift.Error>) -> Swift.Void)
}
public protocol TileStoreObserver : AnyObject {
  func onRegionLoadProgress(forId id: Swift.String, progress: MapboxCommon.TileRegionLoadProgress)
  func onRegionLoadFinished(forId id: Swift.String, region: Swift.Result<MapboxCommon.TileRegion, any Swift.Error>)
  func onRegionRemoved(forId id: Swift.String)
  func onRegionGeometryChanged(forId id: Swift.String, geometry: MapboxMaps.Geometry?)
  func onRegionMetadataChanged(forId id: Swift.String, value: Any)
}
extension MapboxCoreMaps.TilesetDescriptorOptions {
  convenience public init(styleURI: MapboxMaps.StyleURI, zoomRange: Swift.ClosedRange<Swift.UInt8>, pixelRatio: Swift.Float? = nil, tilesets: [Swift.String]?, stylePackOptions: MapboxCoreMaps.StylePackLoadOptions? = nil, extraOptions: Any? = nil)
}
public struct TimingCurve : Swift.Equatable {
  public static let easeInOut: MapboxMaps.TimingCurve
  public static let easeIn: MapboxMaps.TimingCurve
  public static let easeOut: MapboxMaps.TimingCurve
  public static let linear: MapboxMaps.TimingCurve
  public static func == (a: MapboxMaps.TimingCurve, b: MapboxMaps.TimingCurve) -> Swift.Bool
}
public struct Tracing : Swift.OptionSet {
  public static let disabled: MapboxMaps.Tracing
  public static let platform: MapboxMaps.Tracing
  public static let core: MapboxMaps.Tracing
  public static let enabled: MapboxMaps.Tracing
  public static let environmentVariableName: Swift.String
  public static var status: MapboxMaps.Tracing {
    get
    set
  }
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = MapboxMaps.Tracing
  public typealias Element = MapboxMaps.Tracing
  public typealias RawValue = Swift.Int
}
public struct TransitionOptions : Swift.Equatable {
  public init(duration: Foundation.TimeInterval? = nil, delay: Foundation.TimeInterval? = nil, enablePlacementTransitions: Swift.Bool? = nil)
  public var duration: Foundation.TimeInterval?
  public var delay: Foundation.TimeInterval?
  public var enablePlacementTransitions: Swift.Bool?
  public static func == (a: MapboxMaps.TransitionOptions, b: MapboxMaps.TransitionOptions) -> Swift.Bool
}
public enum Value<T> : Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  case constant(T)
  case expression(MapboxMaps.Expression)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.Value : Swift.Equatable where T : Swift.Equatable {
  public static func == (a: MapboxMaps.Value<T>, b: MapboxMaps.Value<T>) -> Swift.Bool
}
public struct VectorSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var tiles: [Swift.String]?
  public var bounds: [Swift.Double]?
  public var scheme: MapboxMaps.Scheme?
  public var minzoom: Swift.Double?
  public var maxzoom: Swift.Double?
  public var attribution: Swift.String?
  public var promoteId: MapboxMaps.PromoteId?
  public var volatile: Swift.Bool?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public var minimumTileUpdateInterval: Swift.Double?
  public var maxOverscaleFactorForParentTiles: Swift.Double?
  public var tileRequestsDelay: Swift.Double?
  public var tileNetworkRequestsDelay: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.VectorSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
final public class ViewAnnotation {
  final public let view: UIKit.UIView
  final public var annotatedFeature: MapboxMaps.AnnotatedFeature {
    get
    set
  }
  final public var allowOverlap: Swift.Bool {
    get
    set
  }
  final public var allowOverlapWithPuck: Swift.Bool {
    get
    set
  }
  final public var ignoreCameraPadding: Swift.Bool {
    get
    set
  }
  final public var visible: Swift.Bool {
    get
    set
  }
  final public var selected: Swift.Bool {
    get
    set
  }
  final public var variableAnchors: [MapboxCoreMaps.ViewAnnotationAnchorConfig] {
    get
    set
  }
  final public var onVisibilityChanged: ((Swift.Bool) -> Swift.Void)?
  final public var onAnchorChanged: ((MapboxCoreMaps.ViewAnnotationAnchorConfig) -> Swift.Void)?
  final public var onAnchorCoordinateChanged: ((CoreLocation.CLLocationCoordinate2D) -> Swift.Void)?
  final public var onFrameChanged: ((CoreFoundation.CGRect) -> Swift.Void)?
  final public var anchorConfig: MapboxCoreMaps.ViewAnnotationAnchorConfig? {
    get
  }
  final public var anchorCoordinate: CoreLocation.CLLocationCoordinate2D? {
    get
  }
  public init(annotatedFeature: MapboxMaps.AnnotatedFeature, view: UIKit.UIView)
  convenience public init(coordinate: CoreLocation.CLLocationCoordinate2D, view: UIKit.UIView)
  convenience public init(layerId: Swift.String, featureId: Swift.String? = nil, view: UIKit.UIView)
  final public func remove()
  final public func setNeedsUpdateSize()
  @objc deinit
}
extension MapboxCoreMaps.ViewAnnotationAnchorConfig {
  convenience public init(anchor: MapboxCoreMaps.ViewAnnotationAnchor, offsetX: CoreFoundation.CGFloat = 0, offsetY: CoreFoundation.CGFloat = 0)
}
extension Swift.Array where Element == MapboxCoreMaps.ViewAnnotationAnchorConfig {
  public static let all: [MapboxCoreMaps.ViewAnnotationAnchorConfig]
  public static let center: [MapboxCoreMaps.ViewAnnotationAnchorConfig]
}
public struct ViewAnnotationManagerError : Swift.Error, Swift.Equatable {
  public let message: Swift.String
  public static let viewIsAlreadyAdded: MapboxMaps.ViewAnnotationManagerError
  public static let annotationNotFound: MapboxMaps.ViewAnnotationManagerError
  public static let annotatedFeatureMissing: MapboxMaps.ViewAnnotationManagerError
  public static func == (a: MapboxMaps.ViewAnnotationManagerError, b: MapboxMaps.ViewAnnotationManagerError) -> Swift.Bool
}
public protocol ViewAnnotationUpdateObserver : AnyObject {
  func framesDidChange(for annotationViews: [UIKit.UIView])
  func visibilityDidChange(for annotationViews: [UIKit.UIView])
}
@_hasMissingDesignatedInitializers final public class ViewAnnotationManager {
  @available(*, deprecated)
  final public var validatesViews: Swift.Bool {
    get
    set
  }
  final public var allAnnotations: [MapboxMaps.ViewAnnotation] {
    get
  }
  @available(*, deprecated, renamed: "allAnnotations", message: "Please use allAnnotations instead, or directly access ViewAnnotation itself")
  final public var annotations: [UIKit.UIView : MapboxMaps.ViewAnnotationOptions] {
    get
  }
  @objc deinit
  final public func add(_ annotation: MapboxMaps.ViewAnnotation)
  @available(*, deprecated, message: "Use add(_:) that takes ViewAnnotation")
  final public func add(_ view: UIKit.UIView, options: MapboxMaps.ViewAnnotationOptions) throws
  @available(*, deprecated, message: "Use add(_:) that takes ViewAnnotation")
  final public func add(_ view: UIKit.UIView, id: Swift.String?, options: MapboxMaps.ViewAnnotationOptions) throws
  @available(*, deprecated, message: "Use ViewAnnotation.remove()")
  final public func remove(_ view: UIKit.UIView)
  final public func removeAll()
  @available(*, deprecated, message: "Use ViewAnnotation properties")
  final public func update(_ view: UIKit.UIView, options: MapboxMaps.ViewAnnotationOptions) throws
  @available(*, deprecated, message: "Use ViewAnnotation.view")
  final public func view(forId id: Swift.String) -> UIKit.UIView?
  @available(*, unavailable, message: "Store annotation references on calling site")
  final public func view(forFeatureId identifier: Swift.String) -> UIKit.UIView?
  @available(*, unavailable, message: "Use options(for:) with UIView")
  final public func options(forFeatureId identifier: Swift.String) -> MapboxMaps.ViewAnnotationOptions?
  @available(*, deprecated, message: "Use ViewAnnotation properties")
  final public func options(for view: UIKit.UIView) -> MapboxMaps.ViewAnnotationOptions?
  @available(*, deprecated, message: "Use ViewAnnotation")
  final public func addViewAnnotationUpdateObserver(_ observer: any MapboxMaps.ViewAnnotationUpdateObserver)
  @available(*, deprecated, message: "Use ViewAnnotation")
  final public func removeViewAnnotationUpdateObserver(_ observer: any MapboxMaps.ViewAnnotationUpdateObserver)
  final public func camera(forAnnotations annotations: [MapboxMaps.ViewAnnotation], padding: UIKit.UIEdgeInsets = .zero, bearing: CoreFoundation.CGFloat? = nil, pitch: CoreFoundation.CGFloat? = nil) -> MapboxMaps.CameraOptions?
  @available(*, deprecated, message: "Use camera(forAnnotations:...) that works with array of ViewAnnotation")
  final public func camera(forAnnotations identifiers: [Swift.String], padding: UIKit.UIEdgeInsets = .zero, bearing: CoreFoundation.CGFloat? = nil, pitch: CoreFoundation.CGFloat? = nil) -> MapboxMaps.CameraOptions?
}
public struct ViewAnnotationOptions : Swift.Equatable {
  @available(*, unavailable, message: "Use annotatedFeature instead.")
  public var geometry: MapboxMaps.Geometry? {
    get
  }
  public var annotatedFeature: MapboxMaps.AnnotatedFeature?
  public var width: CoreFoundation.CGFloat?
  public var height: CoreFoundation.CGFloat?
  @available(*, unavailable, message: "Use annotatedFeature instead.")
  public var associatedFeatureId: Swift.String? {
    get
  }
  public var allowOverlap: Swift.Bool?
  public var allowOverlapWithPuck: Swift.Bool?
  public var visible: Swift.Bool?
  public var variableAnchors: [MapboxCoreMaps.ViewAnnotationAnchorConfig]?
  @available(*, unavailable, message: "Use variableAnchors instead.")
  public var anchor: MapboxCoreMaps.ViewAnnotationAnchor? {
    get
  }
  @available(*, unavailable, message: "Use variableAnchors instead.")
  public var offsetX: CoreFoundation.CGFloat? {
    get
  }
  @available(*, unavailable, message: "Use variableAnchors instead.")
  public var offsetY: CoreFoundation.CGFloat? {
    get
  }
  public var selected: Swift.Bool?
  public var ignoreCameraPadding: Swift.Bool?
  public init(annotatedFeature: MapboxMaps.AnnotatedFeature? = nil, width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil, allowOverlap: Swift.Bool? = nil, allowOverlapWithPuck: Swift.Bool? = nil, visible: Swift.Bool? = nil, selected: Swift.Bool? = nil, variableAnchors: [MapboxCoreMaps.ViewAnnotationAnchorConfig]? = nil, ignoreCameraPadding: Swift.Bool? = nil)
  @available(*, deprecated, message: "Use ViewAnnotation to create view annotations.")
  public init(geometry: (any Turf.GeometryConvertible)? = nil, width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil, associatedFeatureId: Swift.String? = nil, allowOverlap: Swift.Bool? = nil, visible: Swift.Bool? = nil, anchor: MapboxCoreMaps.ViewAnnotationAnchor? = nil, offsetX: CoreFoundation.CGFloat? = nil, offsetY: CoreFoundation.CGFloat? = nil, selected: Swift.Bool? = nil)
  public static func == (a: MapboxMaps.ViewAnnotationOptions, b: MapboxMaps.ViewAnnotationOptions) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class ViewportManager {
  final public var options: MapboxMaps.ViewportOptions {
    get
    set
  }
  final public var status: MapboxMaps.ViewportStatus {
    get
  }
  final public func addStatusObserver(_ observer: any MapboxMaps.ViewportStatusObserver)
  final public func removeStatusObserver(_ observer: any MapboxMaps.ViewportStatusObserver)
  final public func idle()
  final public func transition(to toState: any MapboxMaps.ViewportState, transition: (any MapboxMaps.ViewportTransition)? = nil, completion: ((_ success: Swift.Bool) -> Swift.Void)? = nil)
  final public var defaultTransition: any MapboxMaps.ViewportTransition {
    get
    set
  }
  final public func makeFollowPuckViewportState(options: MapboxMaps.FollowPuckViewportStateOptions = .init()) -> MapboxMaps.FollowPuckViewportState
  final public func makeOverviewViewportState(options: MapboxMaps.OverviewViewportStateOptions) -> MapboxMaps.OverviewViewportState
  final public func makeDefaultViewportTransition(options: MapboxMaps.DefaultViewportTransitionOptions = .init()) -> MapboxMaps.DefaultViewportTransition
  final public func makeImmediateViewportTransition() -> MapboxMaps.ImmediateViewportTransition
  @objc deinit
}
public struct ViewportOptions : Swift.Hashable {
  public var transitionsToIdleUponUserInteraction: Swift.Bool
  public init(transitionsToIdleUponUserInteraction: Swift.Bool = true)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.ViewportOptions, b: MapboxMaps.ViewportOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ViewportState : AnyObject {
  func observeDataSource(with handler: @escaping (_ camera: MapboxMaps.CameraOptions) -> Swift.Bool) -> any MapboxCommon.Cancelable
  func startUpdatingCamera()
  func stopUpdatingCamera()
}
public enum ViewportStatus : Swift.Hashable {
  case idle
  case state(_: any MapboxMaps.ViewportState)
  case transition(_: any MapboxMaps.ViewportTransition, toState: any MapboxMaps.ViewportState)
  public static func == (lhs: MapboxMaps.ViewportStatus, rhs: MapboxMaps.ViewportStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ViewportStatusObserver : AnyObject {
  func viewportStatusDidChange(from fromStatus: MapboxMaps.ViewportStatus, to toStatus: MapboxMaps.ViewportStatus, reason: MapboxMaps.ViewportStatusChangeReason)
}
public struct ViewportStatusChangeReason : Swift.Hashable {
  public static let idleRequested: MapboxMaps.ViewportStatusChangeReason
  public static let transitionStarted: MapboxMaps.ViewportStatusChangeReason
  public static let transitionSucceeded: MapboxMaps.ViewportStatusChangeReason
  public static let transitionFailed: MapboxMaps.ViewportStatusChangeReason
  public static let userInteraction: MapboxMaps.ViewportStatusChangeReason
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.ViewportStatusChangeReason, b: MapboxMaps.ViewportStatusChangeReason) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ViewportTransition : AnyObject {
  func run(to toState: any MapboxMaps.ViewportState, completion: @escaping (_ success: Swift.Bool) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.PointAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.CircleAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.PanMode : Swift.Hashable {}
extension MapboxMaps.PanMode : Swift.RawRepresentable {}
extension MapboxMaps.PuckBearing : Swift.Hashable {}
extension MapboxMaps.OrnamentPosition : Swift.Hashable {}
extension MapboxMaps.OrnamentPosition : Swift.RawRepresentable {}
extension MapboxMaps.OrnamentVisibility : Swift.Hashable {}
extension MapboxMaps.OrnamentVisibility : Swift.RawRepresentable {}
extension MapboxMaps.PolygonAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.PolylineAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.Visibility : Swift.Equatable {}
extension MapboxMaps.Visibility : Swift.Hashable {}
extension MapboxMaps.Visibility : Swift.RawRepresentable {}
