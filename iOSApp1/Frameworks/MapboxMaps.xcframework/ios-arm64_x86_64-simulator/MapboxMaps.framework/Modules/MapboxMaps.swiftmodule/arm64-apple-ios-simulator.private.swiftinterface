// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name MapboxMaps
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CoreFoundation.CFCGTypes
import CoreImage.CIFilterBuiltins
import CoreLocation.CLLocation
import CarPlay
import Combine
import CoreFoundation
import CoreGraphics
import CoreImage
import CoreLocation
import DeveloperToolsSupport
import Dispatch
import Foundation
import MapboxCommon.MBXCoordinate2D
@_exported import MapboxCommon
@_exported import MapboxCoreMaps
@_exported import MapboxMaps
import Metal
import MetalKit
import QuartzCore
import RegexBuilder
import Swift
import SwiftUI
@_exported import Turf
import UIKit.UIGeometry
import UIKit.UIGestureRecognizerSubclass
import UIKit
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
import os.log
import os
extension MapboxMaps.Expression {
  public struct Operator : Swift.RawRepresentable, Swift.Codable, Swift.Equatable {
    public static let subtract: MapboxMaps.Expression.Operator
    public static let not: MapboxMaps.Expression.Operator
    public static let neq: MapboxMaps.Expression.Operator
    public static let product: MapboxMaps.Expression.Operator
    public static let division: MapboxMaps.Expression.Operator
    public static let mod: MapboxMaps.Expression.Operator
    public static let pow: MapboxMaps.Expression.Operator
    public static let sum: MapboxMaps.Expression.Operator
    public static let lt: MapboxMaps.Expression.Operator
    public static let lte: MapboxMaps.Expression.Operator
    public static let eq: MapboxMaps.Expression.Operator
    public static let gt: MapboxMaps.Expression.Operator
    public static let gte: MapboxMaps.Expression.Operator
    public static let abs: MapboxMaps.Expression.Operator
    public static let accumulated: MapboxMaps.Expression.Operator
    public static let acos: MapboxMaps.Expression.Operator
    @_spi(Experimental) public static let activeAnchor: MapboxMaps.Expression.Operator
    public static let all: MapboxMaps.Expression.Operator
    public static let any: MapboxMaps.Expression.Operator
    public static let array: MapboxMaps.Expression.Operator
    public static let asin: MapboxMaps.Expression.Operator
    public static let at: MapboxMaps.Expression.Operator
    public static let atan: MapboxMaps.Expression.Operator
    public static let boolean: MapboxMaps.Expression.Operator
    public static let switchCase: MapboxMaps.Expression.Operator
    public static let ceil: MapboxMaps.Expression.Operator
    public static let coalesce: MapboxMaps.Expression.Operator
    public static let collator: MapboxMaps.Expression.Operator
    public static let concat: MapboxMaps.Expression.Operator
    public static let config: MapboxMaps.Expression.Operator
    public static let cos: MapboxMaps.Expression.Operator
    public static let distance: MapboxMaps.Expression.Operator
    public static let distanceFromCenter: MapboxMaps.Expression.Operator
    public static let downcase: MapboxMaps.Expression.Operator
    public static let e: MapboxMaps.Expression.Operator
    public static let featureState: MapboxMaps.Expression.Operator
    public static let floor: MapboxMaps.Expression.Operator
    public static let format: MapboxMaps.Expression.Operator
    public static let geometryType: MapboxMaps.Expression.Operator
    public static let get: MapboxMaps.Expression.Operator
    public static let has: MapboxMaps.Expression.Operator
    public static let heatmapDensity: MapboxMaps.Expression.Operator
    public static let hsl: MapboxMaps.Expression.Operator
    public static let hsla: MapboxMaps.Expression.Operator
    public static let id: MapboxMaps.Expression.Operator
    public static let image: MapboxMaps.Expression.Operator
    public static let inExpression: MapboxMaps.Expression.Operator
    public static let indexOf: MapboxMaps.Expression.Operator
    public static let interpolate: MapboxMaps.Expression.Operator
    public static let isSupportedScript: MapboxMaps.Expression.Operator
    public static let length: MapboxMaps.Expression.Operator
    public static let letExpression: MapboxMaps.Expression.Operator
    public static let lineProgress: MapboxMaps.Expression.Operator
    public static let literal: MapboxMaps.Expression.Operator
    public static let ln: MapboxMaps.Expression.Operator
    public static let ln2: MapboxMaps.Expression.Operator
    public static let log10: MapboxMaps.Expression.Operator
    public static let log2: MapboxMaps.Expression.Operator
    public static let match: MapboxMaps.Expression.Operator
    public static let max: MapboxMaps.Expression.Operator
    public static let measureLight: MapboxMaps.Expression.Operator
    public static let min: MapboxMaps.Expression.Operator
    public static let number: MapboxMaps.Expression.Operator
    public static let numberFormat: MapboxMaps.Expression.Operator
    public static let objectExpression: MapboxMaps.Expression.Operator
    public static let pi: MapboxMaps.Expression.Operator
    public static let pitch: MapboxMaps.Expression.Operator
    public static let properties: MapboxMaps.Expression.Operator
    public static let random: MapboxMaps.Expression.Operator
    public static let rasterParticleSpeed: MapboxMaps.Expression.Operator
    public static let rasterValue: MapboxMaps.Expression.Operator
    public static let resolvedLocale: MapboxMaps.Expression.Operator
    public static let rgb: MapboxMaps.Expression.Operator
    public static let rgba: MapboxMaps.Expression.Operator
    public static let round: MapboxMaps.Expression.Operator
    public static let sin: MapboxMaps.Expression.Operator
    public static let skyRadialProgress: MapboxMaps.Expression.Operator
    public static let slice: MapboxMaps.Expression.Operator
    public static let sqrt: MapboxMaps.Expression.Operator
    public static let step: MapboxMaps.Expression.Operator
    public static let string: MapboxMaps.Expression.Operator
    public static let tan: MapboxMaps.Expression.Operator
    public static let toBoolean: MapboxMaps.Expression.Operator
    public static let toColor: MapboxMaps.Expression.Operator
    public static let toNumber: MapboxMaps.Expression.Operator
    public static let toRgba: MapboxMaps.Expression.Operator
    public static let toString: MapboxMaps.Expression.Operator
    public static let typeofExpression: MapboxMaps.Expression.Operator
    public static let upcase: MapboxMaps.Expression.Operator
    public static let varExpression: MapboxMaps.Expression.Operator
    public static let within: MapboxMaps.Expression.Operator
    public static let zoom: MapboxMaps.Expression.Operator
    public static let linear: MapboxMaps.Expression.Operator
    public static let exponential: MapboxMaps.Expression.Operator
    public static let cubicBezier: MapboxMaps.Expression.Operator
    public let rawValue: Swift.String
    public init(rawValue: Swift.String)
    public typealias RawValue = Swift.String
  }
}
public struct AmbientLight : Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public let id: Swift.String
  public let type: MapboxMaps.LightType
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var intensity: MapboxMaps.Value<Swift.Double>?
  public var intensityTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String = UUID().uuidString)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.AmbientLight, b: MapboxMaps.AmbientLight) -> Swift.Bool
}
extension MapboxMaps.AmbientLight {
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func intensity(_ constant: Swift.Double) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func intensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.AmbientLight
  @_documentation(visibility: public) public func intensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.AmbientLight
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.AmbientLight : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public typealias AnimationCompletion = (UIKit.UIViewAnimatingPosition) -> Swift.Void
public struct AnimationOwner : Swift.RawRepresentable, Swift.Equatable {
  public typealias RawValue = Swift.String
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let gestures: MapboxMaps.AnimationOwner
  public static let unspecified: MapboxMaps.AnimationOwner
  public static let compass: MapboxMaps.AnimationOwner
}
public struct AnnotatedFeature : Swift.Equatable {
  public struct LayerFeature : Swift.Equatable {
    public var layerId: Swift.String
    public var featureId: Swift.String?
    public static func == (a: MapboxMaps.AnnotatedFeature.LayerFeature, b: MapboxMaps.AnnotatedFeature.LayerFeature) -> Swift.Bool
  }
  public var geometry: MapboxMaps.Geometry?
  public var layerFeature: MapboxMaps.AnnotatedFeature.LayerFeature?
  public static func layerFeature(layerId: Swift.String, featureId: Swift.String? = nil) -> MapboxMaps.AnnotatedFeature
  public static func geometry(_ geometry: any Turf.GeometryConvertible) -> MapboxMaps.AnnotatedFeature
  public static func == (a: MapboxMaps.AnnotatedFeature, b: MapboxMaps.AnnotatedFeature) -> Swift.Bool
}
public protocol Annotation {
  var id: Swift.String { get }
  var geometry: MapboxMaps.Geometry { get }
  @available(*, deprecated, message: "Will be deleted in future, for Mapbox-provided annotations see customData instead.")
  var userInfo: [Swift.String : Any]? { get set }
}
public struct AnnotationClusterGestureContext : Swift.Equatable {
  public var point: CoreFoundation.CGPoint
  public var coordinate: CoreLocation.CLLocationCoordinate2D
  public let expansionZoom: CoreFoundation.CGFloat?
  public static func == (a: MapboxMaps.AnnotationClusterGestureContext, b: MapboxMaps.AnnotationClusterGestureContext) -> Swift.Bool
}
extension MapboxMaps.PointAnnotation {
  public struct Image : Swift.Hashable {
    public var image: UIKit.UIImage
    public var name: Swift.String
    public init(image: UIKit.UIImage, name: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: MapboxMaps.PointAnnotation.Image, b: MapboxMaps.PointAnnotation.Image) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
}
public protocol AnnotationManager : AnyObject {
  var id: Swift.String { get }
  var sourceId: Swift.String { get }
  var layerId: Swift.String { get }
  var slot: Swift.String? { get set }
}
public protocol AnnotationInteractionDelegate : AnyObject {
  func annotationManager(_ manager: any MapboxMaps.AnnotationManager, didDetectTappedAnnotations annotations: [any MapboxMaps.Annotation])
}
@_hasMissingDesignatedInitializers final public class AnnotationOrchestrator {
  final public var annotationManagersById: [Swift.String : any MapboxMaps.AnnotationManager] {
    get
  }
  final public func makePointAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil, clusterOptions: MapboxMaps.ClusterOptions? = nil, onClusterTap: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)? = nil, onClusterLongPress: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)? = nil) -> MapboxMaps.PointAnnotationManager
  final public func makePolygonAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil) -> MapboxMaps.PolygonAnnotationManager
  final public func makePolylineAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil) -> MapboxMaps.PolylineAnnotationManager
  final public func makeCircleAnnotationManager(id: Swift.String = String(UUID().uuidString.prefix(5)), layerPosition: MapboxMaps.LayerPosition? = nil) -> MapboxMaps.CircleAnnotationManager
  final public func removeAnnotationManager(withId id: Swift.String)
  @objc deinit
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension MapboxMaps.AnyCancelable {
  public func store(in set: inout Swift.Set<Combine.AnyCancellable>)
  public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == Combine.AnyCancellable
}
@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension Combine.AnyCancellable {
  final public func store(in set: inout Swift.Set<MapboxMaps.AnyCancelable>)
  @available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
  final public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == MapboxMaps.AnyCancelable
}
public class AnyCancelable : MapboxCommon.Cancelable {
  public init(_ closure: @escaping () -> Swift.Void)
  convenience public init<C>(_ canceler: C) where C : MapboxCommon.Cancelable
  convenience public init<S>(_ sequence: S) where S : Swift.Sequence, S.Element : MapboxCommon.Cancelable
  @objc public func cancel()
  @objc deinit
}
extension MapboxMaps.AnyCancelable : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: MapboxMaps.AnyCancelable, rhs: MapboxMaps.AnyCancelable) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxMaps.AnyCancelable {
  public func store(in set: inout Swift.Set<MapboxMaps.AnyCancelable>)
  public func store<C>(in collection: inout C) where C : Swift.RangeReplaceableCollection, C.Element == MapboxMaps.AnyCancelable
}
public protocol AppleLocationProviderDelegate : AnyObject {
  func appleLocationProvider(_ locationProvider: MapboxMaps.AppleLocationProvider, didFailWithError error: any Swift.Error)
  func appleLocationProvider(_ locationProvider: MapboxMaps.AppleLocationProvider, didChangeAccuracyAuthorization accuracyAuthorization: CoreLocation.CLAccuracyAuthorization)
  func appleLocationProviderShouldDisplayHeadingCalibration(_ locationProvider: MapboxMaps.AppleLocationProvider) -> Swift.Bool
}
@_hasMissingDesignatedInitializers final public class AppleLocationProvider {
  public struct Options : Swift.Equatable {
    public var distanceFilter: CoreLocation.CLLocationDistance
    public var desiredAccuracy: CoreLocation.CLLocationAccuracy
    public var activityType: CoreLocation.CLActivityType
    public init(distanceFilter: CoreLocation.CLLocationDistance = kCLDistanceFilterNone, desiredAccuracy: CoreLocation.CLLocationAccuracy = kCLLocationAccuracyBest, activityType: CoreLocation.CLActivityType = .other)
    public static func == (a: MapboxMaps.AppleLocationProvider.Options, b: MapboxMaps.AppleLocationProvider.Options) -> Swift.Bool
  }
  final public var options: MapboxMaps.AppleLocationProvider.Options {
    get
    set
  }
  weak final public var delegate: (any MapboxMaps.AppleLocationProviderDelegate)?
  final public var onLocationUpdate: MapboxMaps.Signal<[MapboxCommon.Location]> {
    get
  }
  @available(visionOS, unavailable)
  final public var onHeadingUpdate: MapboxMaps.Signal<MapboxMaps.Heading> {
    get
  }
  final public var latestLocation: MapboxCommon.Location? {
    get
  }
  convenience public init()
  @objc deinit
  @available(iOS 14.0, *)
  final public func requestTemporaryFullAccuracyAuthorization(withPurposeKey purposeKey: Swift.String)
}
extension MapboxMaps.AppleLocationProvider : MapboxCommon.LocationProvider {
  @objc final public func getLastObservedLocation() -> MapboxCommon.Location?
  @objc final public func addLocationObserver(for observer: any MapboxCommon.LocationObserver)
  @objc final public func removeLocationObserver(for observer: any MapboxCommon.LocationObserver)
}
@available(visionOS, unavailable)
extension MapboxMaps.AppleLocationProvider : MapboxMaps.HeadingProvider {
  @available(visionOS, unavailable)
  final public var latestHeading: MapboxMaps.Heading? {
    get
  }
  @available(visionOS, unavailable)
  final public func add(headingObserver: any MapboxMaps.HeadingObserver)
  @available(visionOS, unavailable)
  final public func remove(headingObserver: any MapboxMaps.HeadingObserver)
}
extension MapboxMaps.AppleLocationProvider {
  final public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateLocations locations: [CoreLocation.CLLocation])
  final public func locationManager(_ manager: CoreLocation.CLLocationManager, didUpdateHeading newHeading: CoreLocation.CLHeading)
  final public func locationManager(_ manager: CoreLocation.CLLocationManager, didFailWithError error: any Swift.Error)
  final public func locationManagerDidChangeAuthorization(_ manager: CoreLocation.CLLocationManager)
  final public func locationManagerShouldDisplayHeadingCalibration(_ manager: CoreLocation.CLLocationManager) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) @_functionBuilder public struct ArrayBuilder<T> {
  @_spi(Experimental) public static func buildExpression(_ expression: T) -> [T]
  @_spi(Experimental) public static func buildOptional(_ component: [T]?) -> [T]
  @_spi(Experimental) public static func buildPartialBlock(first: T) -> [T]
  @_spi(Experimental) public static func buildPartialBlock(first: [T]) -> [T]
  @_spi(Experimental) public static func buildPartialBlock(accumulated: [T], next: T) -> [T]
  @_spi(Experimental) public static func buildPartialBlock(accumulated: [T], next: [T]) -> [T]
  @_spi(Experimental) public static func buildBlock() -> [T]
  @_spi(Experimental) public static func buildEither(first: [T]) -> [T]
  @_spi(Experimental) public static func buildEither(second: [T]) -> [T]
  @_spi(Experimental) public static func buildIf(_ element: [T]?) -> [T]
  @_spi(Experimental) public static func buildPartialBlock(first: Swift.Never) -> [T]
}
public struct Atmosphere : Swift.Codable, Swift.Equatable {
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var highColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var highColorTransition: MapboxMaps.StyleTransition?
  public var horizonBlend: MapboxMaps.Value<Swift.Double>?
  public var horizonBlendTransition: MapboxMaps.StyleTransition?
  public var range: MapboxMaps.Value<[Swift.Double]>?
  public var rangeTransition: MapboxMaps.StyleTransition?
  public var spaceColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var spaceColorTransition: MapboxMaps.StyleTransition?
  public var starIntensity: MapboxMaps.Value<Swift.Double>?
  public var starIntensityTransition: MapboxMaps.StyleTransition?
  public var verticalRange: MapboxMaps.Value<[Swift.Double]>?
  public var verticalRangeTransition: MapboxMaps.StyleTransition?
  public init()
  public static func == (a: MapboxMaps.Atmosphere, b: MapboxMaps.Atmosphere) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.Atmosphere : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_documentation(visibility: public) extension MapboxMaps.Atmosphere {
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColor(_ color: UIKit.UIColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func highColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func horizonBlend(_ constant: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func horizonBlendTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func horizonBlend(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func range(start: Swift.Double, end: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func rangeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func range(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColor(_ color: UIKit.UIColor) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func spaceColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func starIntensity(_ constant: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func starIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func starIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func verticalRange(start: Swift.Double, end: Swift.Double) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func verticalRangeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Atmosphere
  @_documentation(visibility: public) public func verticalRange(_ expression: MapboxMaps.Expression) -> MapboxMaps.Atmosphere
}
public protocol AttributionURLOpener {
  func openAttributionURL(_ url: Foundation.URL)
}
public struct BackgroundLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var backgroundColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var backgroundColorTransition: MapboxMaps.StyleTransition?
  public var backgroundEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var backgroundEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var backgroundOpacity: MapboxMaps.Value<Swift.Double>?
  public var backgroundOpacityTransition: MapboxMaps.StyleTransition?
  public var backgroundPattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.BackgroundLayer, b: MapboxMaps.BackgroundLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.BackgroundLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundColor(_ color: UIKit.UIColor) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundOpacity(_ constant: Swift.Double) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundPattern(_ constant: Swift.String) -> MapboxMaps.BackgroundLayer
  @_spi(Experimental) @_documentation(visibility: public) public func backgroundPattern(_ expression: MapboxMaps.Expression) -> MapboxMaps.BackgroundLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.BackgroundLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_hasMissingDesignatedInitializers final public class BasicCameraAnimator : MapboxMaps.CameraAnimator {
  final public var owner: MapboxMaps.AnimationOwner {
    get
  }
  final public var transition: MapboxMaps.CameraTransition? {
    get
  }
  final public var state: UIKit.UIViewAnimatingState {
    get
  }
  final public var isRunning: Swift.Bool {
    get
  }
  final public var isReversed: Swift.Bool {
    get
    set
  }
  final public var pausesOnCompletion: Swift.Bool {
    get
    set
  }
  final public var fractionComplete: Swift.Double {
    get
    set
  }
  final public var onStarted: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onFinished: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onCancelled: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public func startAnimation()
  final public func startAnimation(afterDelay delay: Foundation.TimeInterval)
  final public func pauseAnimation()
  final public func stopAnimation()
  final public func addCompletion(_ completion: @escaping MapboxMaps.AnimationCompletion)
  final public func continueAnimation(withTimingParameters timingParameters: (any UIKit.UITimingCurveProvider)?, durationFactor: Swift.Double)
  @objc final public func cancel()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class CameraAnimationsManager {
  final public var cameraAnimators: [any MapboxMaps.CameraAnimator] {
    get
  }
  final public func cancelAnimations()
  @discardableResult
  final public func fly(to: MapboxMaps.CameraOptions, duration: Foundation.TimeInterval? = nil, curve: MapboxMaps.TimingCurve = .easeOut, completion: MapboxMaps.AnimationCompletion? = nil) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func ease(to: MapboxMaps.CameraOptions, duration: Foundation.TimeInterval, curve: UIKit.UIView.AnimationCurve = .easeOut, completion: MapboxMaps.AnimationCompletion? = nil) -> any MapboxCommon.Cancelable
  final public func makeAnimator(duration: Foundation.TimeInterval, timingParameters: any UIKit.UITimingCurveProvider, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public func makeAnimator(duration: Foundation.TimeInterval, curve: UIKit.UIView.AnimationCurve, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public func makeAnimator(duration: Foundation.TimeInterval, controlPoint1: CoreFoundation.CGPoint, controlPoint2: CoreFoundation.CGPoint, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public func makeAnimator(duration: Foundation.TimeInterval, dampingRatio: CoreFoundation.CGFloat, animationOwner: MapboxMaps.AnimationOwner = .unspecified, animations: @escaping (inout MapboxMaps.CameraTransition) -> Swift.Void) -> MapboxMaps.BasicCameraAnimator
  final public var onCameraAnimatorStarted: MapboxMaps.Signal<any MapboxMaps.CameraAnimator> {
    get
  }
  final public var onCameraAnimatorFinished: MapboxMaps.Signal<any MapboxMaps.CameraAnimator> {
    get
  }
  final public var onCameraAnimatorCancelled: MapboxMaps.Signal<any MapboxMaps.CameraAnimator> {
    get
  }
  @objc deinit
}
public protocol CameraAnimator : MapboxCommon.Cancelable {
  var owner: MapboxMaps.AnimationOwner { get }
  func stopAnimation()
  var state: UIKit.UIViewAnimatingState { get }
}
extension MapboxMaps.Signal where Payload == any MapboxMaps.CameraAnimator {
  public func owned(by owner: MapboxMaps.AnimationOwner) -> MapboxMaps.Signal<Payload>
}
public struct CameraBounds : Swift.Hashable {
  public let bounds: MapboxCoreMaps.CoordinateBounds
  public let maxZoom: CoreFoundation.CGFloat
  public let minZoom: CoreFoundation.CGFloat
  public let maxPitch: CoreFoundation.CGFloat
  public let minPitch: CoreFoundation.CGFloat
  public static func == (lhs: MapboxMaps.CameraBounds, rhs: MapboxMaps.CameraBounds) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CameraBoundsOptions : Swift.Hashable {
  public var bounds: MapboxCoreMaps.CoordinateBounds?
  public var maxZoom: CoreFoundation.CGFloat?
  public var minZoom: CoreFoundation.CGFloat?
  public var maxPitch: CoreFoundation.CGFloat?
  public var minPitch: CoreFoundation.CGFloat?
  public init(bounds: MapboxCoreMaps.CoordinateBounds? = nil, maxZoom: CoreFoundation.CGFloat? = nil, minZoom: CoreFoundation.CGFloat? = nil, maxPitch: CoreFoundation.CGFloat? = nil, minPitch: CoreFoundation.CGFloat? = nil)
  public static func == (lhs: MapboxMaps.CameraBoundsOptions, rhs: MapboxMaps.CameraBoundsOptions) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxMaps.CameraBoundsOptions {
  public init(cameraBounds: MapboxMaps.CameraBounds)
}
public struct CameraOptions : Swift.Codable, Swift.Hashable {
  public var center: CoreLocation.CLLocationCoordinate2D? {
    get
    set
  }
  public var padding: UIKit.UIEdgeInsets? {
    get
    set
  }
  public var anchor: CoreFoundation.CGPoint? {
    get
    set
  }
  public var zoom: CoreFoundation.CGFloat?
  public var bearing: CoreLocation.CLLocationDirection?
  public var pitch: CoreFoundation.CGFloat?
  public init(center: CoreLocation.CLLocationCoordinate2D? = nil, padding: UIKit.UIEdgeInsets? = nil, anchor: CoreFoundation.CGPoint? = nil, zoom: CoreFoundation.CGFloat? = nil, bearing: CoreLocation.CLLocationDirection? = nil, pitch: CoreFoundation.CGFloat? = nil)
  public init(cameraState: MapboxMaps.CameraState, anchor: CoreFoundation.CGPoint? = nil)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.CameraOptions, b: MapboxMaps.CameraOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct CameraState : Swift.Codable, Swift.Hashable {
  public var center: CoreLocation.CLLocationCoordinate2D {
    get
    set
  }
  public var padding: UIKit.UIEdgeInsets {
    get
    set
  }
  public var zoom: CoreFoundation.CGFloat
  public var bearing: CoreLocation.CLLocationDirection
  public var pitch: CoreFoundation.CGFloat
  public init(center: CoreLocation.CLLocationCoordinate2D, padding: UIKit.UIEdgeInsets, zoom: CoreFoundation.CGFloat, bearing: CoreLocation.CLLocationDirection, pitch: CoreFoundation.CGFloat)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.CameraState, b: MapboxMaps.CameraState) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct CameraTransition : Swift.Equatable {
  public var center: MapboxMaps.CameraTransition.Change<CoreLocation.CLLocationCoordinate2D>
  public var zoom: MapboxMaps.CameraTransition.Change<CoreFoundation.CGFloat>
  public var padding: MapboxMaps.CameraTransition.Change<UIKit.UIEdgeInsets>
  public var anchor: MapboxMaps.CameraTransition.Change<CoreFoundation.CGPoint>
  public var bearing: MapboxMaps.CameraTransition.Change<CoreLocation.CLLocationDirection>
  public var shouldOptimizeBearingPath: Swift.Bool
  public var pitch: MapboxMaps.CameraTransition.Change<CoreFoundation.CGFloat>
  public struct Change<T> : Swift.Equatable where T : Swift.Equatable {
    public var fromValue: T
    public var toValue: T?
    public static func == (a: MapboxMaps.CameraTransition.Change<T>, b: MapboxMaps.CameraTransition.Change<T>) -> Swift.Bool
  }
  public static func == (a: MapboxMaps.CameraTransition, b: MapboxMaps.CameraTransition) -> Swift.Bool
}
public struct CircleAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var point: Turf.Point
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.CircleAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.CircleAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.CircleAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, point: Turf.Point, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public init(id: Swift.String = UUID().uuidString, centerCoordinate: CoreLocation.CLLocationCoordinate2D, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var circleSortKey: Swift.Double?
  public var circleBlur: Swift.Double?
  public var circleColor: MapboxMaps.StyleColor?
  public var circleOpacity: Swift.Double?
  public var circleRadius: Swift.Double?
  public var circleStrokeColor: MapboxMaps.StyleColor?
  public var circleStrokeOpacity: Swift.Double?
  public var circleStrokeWidth: Swift.Double?
  public static func == (a: MapboxMaps.CircleAnnotation, b: MapboxMaps.CircleAnnotation) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.CircleAnnotation {
  @_spi(Experimental) @_documentation(visibility: public) public func circleSortKey(_ newValue: Swift.Double) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleBlur(_ newValue: Swift.Double) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleColor(_ color: UIKit.UIColor) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleOpacity(_ newValue: Swift.Double) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleRadius(_ newValue: Swift.Double) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeColor(_ color: UIKit.UIColor) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeOpacity(_ newValue: Swift.Double) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeWidth(_ newValue: Swift.Double) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.CircleAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.CircleAnnotation
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.CircleAnnotation : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct CircleAnnotationGroup<Data, ID> where Data : Swift.RandomAccessCollection, ID : Swift.Hashable {
  @_spi(Experimental) @_documentation(visibility: public) public init(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, content: @escaping (Data.Element) -> MapboxMaps.CircleAnnotation)
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init(_ data: Data, content: @escaping (Data.Element) -> MapboxMaps.CircleAnnotation) where ID == Data.Element.ID, Data.Element : Swift.Identifiable
  @_spi(Experimental) @_documentation(visibility: public) public init(@MapboxMaps.ArrayBuilder<MapboxMaps.CircleAnnotation> content: @escaping () -> [MapboxMaps.CircleAnnotation?]) where Data == [(Swift.Int, MapboxMaps.CircleAnnotation)], ID == Swift.Int
  @_spi(Experimental) @_documentation(visibility: public) public func circleEmissiveStrength(_ newValue: Swift.Double) -> MapboxMaps.CircleAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func circlePitchAlignment(_ newValue: MapboxMaps.CirclePitchAlignment) -> MapboxMaps.CircleAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func circlePitchScale(_ newValue: MapboxMaps.CirclePitchScale) -> MapboxMaps.CircleAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func circleTranslate(_ newValue: [Swift.Double]) -> MapboxMaps.CircleAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func circleTranslateAnchor(_ newValue: MapboxMaps.CircleTranslateAnchor) -> MapboxMaps.CircleAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: Swift.String) -> MapboxMaps.CircleAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func layerId(_ layerId: Swift.String) -> MapboxMaps.CircleAnnotationGroup<Data, ID>
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.CircleAnnotationGroup : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_hasMissingDesignatedInitializers public class CircleAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.CircleAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var circleEmissiveStrength: Swift.Double? {
    get
    set
  }
  public var circlePitchAlignment: MapboxMaps.CirclePitchAlignment? {
    get
    set
  }
  public var circlePitchScale: MapboxMaps.CirclePitchScale? {
    get
    set
  }
  public var circleTranslate: [Swift.Double]? {
    get
    set
  }
  public var circleTranslateAnchor: MapboxMaps.CircleTranslateAnchor? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @objc deinit
}
public struct CircleLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var circleSortKey: MapboxMaps.Value<Swift.Double>?
  public var circleBlur: MapboxMaps.Value<Swift.Double>?
  public var circleBlurTransition: MapboxMaps.StyleTransition?
  public var circleColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var circleColorTransition: MapboxMaps.StyleTransition?
  public var circleEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var circleEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var circleOpacity: MapboxMaps.Value<Swift.Double>?
  public var circleOpacityTransition: MapboxMaps.StyleTransition?
  public var circlePitchAlignment: MapboxMaps.Value<MapboxMaps.CirclePitchAlignment>?
  public var circlePitchScale: MapboxMaps.Value<MapboxMaps.CirclePitchScale>?
  public var circleRadius: MapboxMaps.Value<Swift.Double>?
  public var circleRadiusTransition: MapboxMaps.StyleTransition?
  public var circleStrokeColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var circleStrokeColorTransition: MapboxMaps.StyleTransition?
  public var circleStrokeOpacity: MapboxMaps.Value<Swift.Double>?
  public var circleStrokeOpacityTransition: MapboxMaps.StyleTransition?
  public var circleStrokeWidth: MapboxMaps.Value<Swift.Double>?
  public var circleStrokeWidthTransition: MapboxMaps.StyleTransition?
  public var circleTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var circleTranslateTransition: MapboxMaps.StyleTransition?
  public var circleTranslateAnchor: MapboxMaps.Value<MapboxMaps.CircleTranslateAnchor>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.CircleLayer, b: MapboxMaps.CircleLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.CircleLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleSortKey(_ constant: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleSortKey(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleBlur(_ constant: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleBlurTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleBlur(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleColor(_ color: UIKit.UIColor) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleOpacity(_ constant: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circlePitchAlignment(_ constant: MapboxMaps.CirclePitchAlignment) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circlePitchAlignment(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circlePitchScale(_ constant: MapboxMaps.CirclePitchScale) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circlePitchScale(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleRadius(_ constant: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeColor(_ color: UIKit.UIColor) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeOpacity(_ constant: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeWidth(_ constant: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeWidthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleStrokeWidth(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleTranslate(x: Swift.Double, y: Swift.Double) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleTranslateTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleTranslate(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleTranslateAnchor(_ constant: MapboxMaps.CircleTranslateAnchor) -> MapboxMaps.CircleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func circleTranslateAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.CircleLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.CircleLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct ClusterOptions : Swift.Equatable {
  public init(circleRadius: MapboxMaps.Value<Swift.Double> = .constant(18), circleColor: MapboxMaps.Value<MapboxMaps.StyleColor> = .constant(StyleColor(.black)), textColor: MapboxMaps.Value<MapboxMaps.StyleColor> = .constant(StyleColor(.white)), textSize: MapboxMaps.Value<Swift.Double> = .constant(12), textField: MapboxMaps.Value<Swift.String> = .expression(Exp(.get) { "point_count" }), clusterRadius: Swift.Double = 50, clusterMaxZoom: Swift.Double = 14, clusterMinPoints: Swift.Double = 2, clusterProperties: [Swift.String : MapboxMaps.Expression]? = nil)
  public static func == (a: MapboxMaps.ClusterOptions, b: MapboxMaps.ClusterOptions) -> Swift.Bool
}
public class CompassDirectionFormatter {
  public enum Style : Swift.Hashable {
    case short
    case long
    public static func == (a: MapboxMaps.CompassDirectionFormatter.Style, b: MapboxMaps.CompassDirectionFormatter.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var style: MapboxMaps.CompassDirectionFormatter.Style
  public init()
  public func string(from direction: CoreLocation.CLLocationDirection) -> Swift.String
  @objc deinit
}
extension MapboxCoreMaps.CoordinateBounds {
  public static var world: MapboxCoreMaps.CoordinateBounds {
    get
  }
  public var south: CoreLocation.CLLocationDegrees {
    get
  }
  public var west: CoreLocation.CLLocationDegrees {
    get
  }
  public var north: CoreLocation.CLLocationDegrees {
    get
  }
  public var east: CoreLocation.CLLocationDegrees {
    get
  }
  public var center: CoreLocation.CLLocationCoordinate2D {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var latitudeSpan: CoreLocation.CLLocationDegrees {
    get
  }
  public var longitudeSpan: CoreLocation.CLLocationDegrees {
    get
  }
  public var northwest: CoreLocation.CLLocationCoordinate2D {
    get
  }
  public var southeast: CoreLocation.CLLocationCoordinate2D {
    get
  }
}
extension MapboxCoreMaps.MapLoadingError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension MapboxCoreMaps.CameraChanged {
  public var cameraState: MapboxMaps.CameraState {
    get
  }
  convenience public init(cameraState: MapboxMaps.CameraState, timestamp: Foundation.Date)
}
extension MapboxCoreMaps.SourceDataLoaded {
  public var loaded: Swift.Bool? {
    get
  }
  convenience public init(sourceId: Swift.String, type: MapboxCoreMaps.SourceDataLoadedType, loaded: Swift.Bool?, tileId: MapboxCoreMaps.CanonicalTileID, dataId: Swift.String?, timeInterval: MapboxCoreMaps.EventTimeInterval)
}
extension MapboxCoreMaps.RequestInfo {
  public var loadingMethod: [MapboxCoreMaps.RequestLoadingMethodType] {
    get
  }
}
public struct CustomGeometrySource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public let options: MapboxCoreMaps.CustomGeometrySourceOptions?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public init(id: Swift.String, options: MapboxCoreMaps.CustomGeometrySourceOptions)
}
extension MapboxMaps.CustomGeometrySource {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) public struct CustomLayer : MapboxMaps.Layer, Swift.Equatable {
  @_spi(Experimental) public var id: Swift.String
  @_spi(Experimental) public let type: MapboxMaps.LayerType
  @_spi(Experimental) public var slot: MapboxMaps.Slot?
  @_spi(Experimental) public var minZoom: Swift.Double?
  @_spi(Experimental) public var maxZoom: Swift.Double?
  @_spi(Experimental) public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  @_spi(Experimental) public var renderer: any MapboxCoreMaps.CustomLayerHost
  @_spi(Experimental) public static func == (lhs: MapboxMaps.CustomLayer, rhs: MapboxMaps.CustomLayer) -> Swift.Bool
  @_spi(Experimental) public init(id: Swift.String, renderer: any MapboxCoreMaps.CustomLayerHost, slot: MapboxMaps.Slot? = nil, minZoom: Swift.Double? = nil, maxZoom: Swift.Double? = nil, visibility: MapboxMaps.Value<MapboxMaps.Visibility> = .constant(.visible))
}
@_spi(Experimental) extension MapboxMaps.CustomLayer {
  @_spi(Experimental) public init(from decoder: any Swift.Decoder) throws
  @_spi(Experimental) public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) extension MapboxMaps.CustomLayer {
  @_spi(Experimental) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.CustomLayer
  @_spi(Experimental) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.CustomLayer
  @_spi(Experimental) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.CustomLayer
  @_spi(Experimental) public func visibility(_ newValue: MapboxMaps.Value<MapboxMaps.Visibility>) -> MapboxMaps.CustomLayer
  @_spi(Experimental) public func renderer(_ newValue: any MapboxCoreMaps.CustomLayerHost) -> MapboxMaps.CustomLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.CustomLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) @_documentation(visibility: public) public func position(_ position: MapboxMaps.LayerPosition) -> MapboxMaps.LayerAtPosition<MapboxMaps.CustomLayer>
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @_documentation(visibility: public) public struct CustomRasterSource : MapboxMaps.Source, Swift.Equatable {
  @_spi(Experimental) @_documentation(visibility: public) public let type: MapboxMaps.SourceType
  @_spi(Experimental) @_documentation(visibility: public) public let id: Swift.String
  @_spi(Experimental) @_documentation(visibility: public) public let options: MapboxCoreMaps.CustomRasterSourceOptions?
  @_spi(Experimental) @_documentation(visibility: public) public init(id: Swift.String, options: MapboxCoreMaps.CustomRasterSourceOptions)
  @_spi(Experimental) public static func == (a: MapboxMaps.CustomRasterSource, b: MapboxMaps.CustomRasterSource) -> Swift.Bool
}
@_spi(Experimental) extension MapboxMaps.CustomRasterSource {
  @_spi(Experimental) public init(from decoder: any Swift.Decoder) throws
  @_spi(Experimental) public func encode(to encoder: any Swift.Encoder) throws
}
extension MapboxCoreMaps.CustomRasterSourceTileData {
  public var image: UIKit.UIImage? {
    get
  }
  convenience public init(tileId: MapboxCoreMaps.CanonicalTileID, image: UIKit.UIImage?)
}
@_hasMissingDesignatedInitializers final public class DefaultViewportTransition {
  final public var options: MapboxMaps.DefaultViewportTransitionOptions
  @objc deinit
}
extension MapboxMaps.DefaultViewportTransition : MapboxMaps.ViewportTransition {
  final public func run(to toState: any MapboxMaps.ViewportState, completion: @escaping (Swift.Bool) -> Swift.Void) -> any MapboxCommon.Cancelable
}
public struct DefaultViewportTransitionOptions : Swift.Hashable {
  public var maxDuration: Foundation.TimeInterval
  public init(maxDuration: Foundation.TimeInterval = 3.5)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.DefaultViewportTransitionOptions, b: MapboxMaps.DefaultViewportTransitionOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public struct DirectionalLight : Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public let id: Swift.String
  public let type: MapboxMaps.LightType
  public var castShadows: MapboxMaps.Value<Swift.Bool>?
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var direction: MapboxMaps.Value<[Swift.Double]>?
  public var directionTransition: MapboxMaps.StyleTransition?
  public var intensity: MapboxMaps.Value<Swift.Double>?
  public var intensityTransition: MapboxMaps.StyleTransition?
  public var shadowIntensity: MapboxMaps.Value<Swift.Double>?
  public var shadowIntensityTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String = UUID().uuidString)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.DirectionalLight, b: MapboxMaps.DirectionalLight) -> Swift.Bool
}
extension MapboxMaps.DirectionalLight {
  @_documentation(visibility: public) public func castShadows(_ constant: Swift.Bool) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func castShadows(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func direction(azimuthal: Swift.Double, polar: Swift.Double) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func directionTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func direction(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func intensity(_ constant: Swift.Double) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func intensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func intensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func shadowIntensity(_ constant: Swift.Double) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func shadowIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.DirectionalLight
  @_documentation(visibility: public) public func shadowIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.DirectionalLight
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.DirectionalLight : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public typealias Exp = MapboxMaps.Expression
public struct Expression : Swift.Codable, Swift.CustomStringConvertible, Swift.Equatable {
  public var `operator`: MapboxMaps.Expression.Operator {
    get
  }
  public var arguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(_ op: MapboxMaps.Expression.Operator, @MapboxMaps.ExpressionArgumentBuilder content: () -> [MapboxMaps.Expression.Argument])
  public init(_ op: MapboxMaps.Expression.Operator)
  public init(operator op: MapboxMaps.Expression.Operator, arguments: [MapboxMaps.Expression.Argument])
  public init(@MapboxMaps.ExpressionArgumentBuilder content: () -> [MapboxMaps.Expression.Argument])
  public init(arguments: [MapboxMaps.Expression.Argument])
  public func encode(to encoder: any Swift.Encoder) throws
  public var description: Swift.String {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
  indirect public enum Element : Swift.Codable, Swift.CustomStringConvertible, Swift.Equatable {
    case `operator`(MapboxMaps.Expression.Operator)
    case argument(MapboxMaps.Expression.Argument)
    public var description: Swift.String {
      get
    }
    public static func == (lhs: MapboxMaps.Expression.Element, rhs: MapboxMaps.Expression.Element) -> Swift.Bool
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
  }
  indirect public enum Argument : Swift.Codable, Swift.CustomStringConvertible, Swift.Equatable {
    case number(Swift.Double)
    case string(Swift.String)
    case boolean(Swift.Bool)
    case numberArray([Swift.Double])
    case stringArray([Swift.String])
    case option(MapboxMaps.Expression.Option)
    case geoJSONObject(Turf.GeoJSONObject)
    case null
    case expression(MapboxMaps.Expression)
    public var description: Swift.String {
      get
    }
    public func encode(to encoder: any Swift.Encoder) throws
    public init(from decoder: any Swift.Decoder) throws
    public static func == (a: MapboxMaps.Expression.Argument, b: MapboxMaps.Expression.Argument) -> Swift.Bool
  }
  public static func == (a: MapboxMaps.Expression, b: MapboxMaps.Expression) -> Swift.Bool
}
@_functionBuilder public struct ExpressionArgumentBuilder {
  public static func buildBlock(_ arguments: any MapboxMaps.ExpressionArgumentConvertible...) -> [MapboxMaps.Expression.Argument]
}
public protocol ExpressionArgumentConvertible {
  var expressionArguments: [MapboxMaps.Expression.Argument] { get }
}
extension Swift.Int : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.UInt : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Double : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.String : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Bool : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Array : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension MapboxMaps.Expression : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Swift.Dictionary : MapboxMaps.ExpressionArgumentConvertible where Key == Swift.Double, Value : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension UIKit.UIColor : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension Turf.GeoJSONObject : MapboxMaps.ExpressionArgumentConvertible {
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
}
extension MapboxMaps.Expression {
  public enum Option : Swift.Codable, Swift.Equatable {
    case format(MapboxMaps.FormatOptions)
    case numberFormat(MapboxMaps.NumberFormatOptions)
    case collator(MapboxMaps.CollatorOptions)
    public init(from decoder: any Swift.Decoder) throws
    public func encode(to encoder: any Swift.Encoder) throws
    public static func == (a: MapboxMaps.Expression.Option, b: MapboxMaps.Expression.Option) -> Swift.Bool
  }
}
public struct FormatOptions : Swift.Codable, Swift.Equatable, MapboxMaps.ExpressionArgumentConvertible {
  public var fontScale: MapboxMaps.Value<Swift.Double>?
  public var textFont: MapboxMaps.Value<[Swift.String]>?
  public var textColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(fontScale: MapboxMaps.Value<Swift.Double>? = nil, textFont: MapboxMaps.Value<[Swift.String]>? = nil, textColor: MapboxMaps.Value<MapboxMaps.StyleColor>? = nil)
  public init()
  public static func == (a: MapboxMaps.FormatOptions, b: MapboxMaps.FormatOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NumberFormatOptions : Swift.Codable, Swift.Equatable, MapboxMaps.ExpressionArgumentConvertible {
  public var locale: Swift.String?
  public var currency: Swift.String?
  public var minFractionDigits: Swift.Int?
  public var maxFractionDigits: Swift.Int?
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(locale: Swift.String?, currency: Swift.String?, minFractionDigits: Swift.Int?, maxFractionDigits: Swift.Int?)
  public static func == (a: MapboxMaps.NumberFormatOptions, b: MapboxMaps.NumberFormatOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct CollatorOptions : Swift.Codable, Swift.Equatable, MapboxMaps.ExpressionArgumentConvertible {
  public var caseSensitive: Swift.Bool?
  public var diacriticSensitive: Swift.Bool?
  public var locale: Swift.String?
  public var expressionArguments: [MapboxMaps.Expression.Argument] {
    get
  }
  public init(caseSensitive: Swift.Bool?, diacriticSensitive: Swift.Bool?, locale: Swift.String?)
  public static func == (a: MapboxMaps.CollatorOptions, b: MapboxMaps.CollatorOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public typealias Feature = Turf.Feature
extension Turf.Feature {
  @_spi(Experimental) public func properties(_ newValue: Turf.JSONObject) -> Turf.Feature
}
extension MapboxCoreMaps.FeatureExtensionValue {
  convenience public init(value: Any?, features: [MapboxMaps.Feature]?)
  public var features: [MapboxMaps.Feature]? {
    get
  }
}
public struct FillExtrusionLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionEdgeRadius: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionAmbientOcclusionGroundAttenuation: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionAmbientOcclusionGroundAttenuationTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionAmbientOcclusionGroundRadius: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionAmbientOcclusionGroundRadiusTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionAmbientOcclusionIntensity: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionAmbientOcclusionIntensityTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionAmbientOcclusionRadius: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionAmbientOcclusionRadiusTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionAmbientOcclusionWallRadius: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionAmbientOcclusionWallRadiusTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionBase: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionBaseTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var fillExtrusionColorTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionCutoffFadeRange: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightColorTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightGroundAttenuation: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightGroundAttenuationTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightGroundRadius: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightGroundRadiusTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightIntensity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightIntensityTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightWallRadius: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionFloodLightWallRadiusTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionHeight: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionHeightTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionOpacity: MapboxMaps.Value<Swift.Double>?
  public var fillExtrusionOpacityTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionPattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionRoundedRoof: MapboxMaps.Value<Swift.Bool>?
  public var fillExtrusionTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var fillExtrusionTranslateTransition: MapboxMaps.StyleTransition?
  public var fillExtrusionTranslateAnchor: MapboxMaps.Value<MapboxMaps.FillExtrusionTranslateAnchor>?
  public var fillExtrusionVerticalGradient: MapboxMaps.Value<Swift.Bool>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionVerticalScale: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var fillExtrusionVerticalScaleTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.FillExtrusionLayer, b: MapboxMaps.FillExtrusionLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.FillExtrusionLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionEdgeRadius(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionEdgeRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionGroundAttenuation(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionGroundAttenuationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionGroundAttenuation(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionGroundRadius(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionGroundRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionGroundRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionIntensity(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionRadius(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionWallRadius(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionWallRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionAmbientOcclusionWallRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionBase(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionBaseTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionBase(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionColor(_ color: UIKit.UIColor) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionCutoffFadeRange(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionCutoffFadeRange(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightColor(_ color: UIKit.UIColor) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightGroundAttenuation(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightGroundAttenuationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightGroundAttenuation(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightGroundRadius(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightGroundRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightGroundRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightIntensity(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightWallRadius(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightWallRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionFloodLightWallRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionHeight(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionHeightTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionHeight(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionOpacity(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionPattern(_ constant: Swift.String) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionPattern(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionRoundedRoof(_ constant: Swift.Bool) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionRoundedRoof(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionTranslate(x: Swift.Double, y: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionTranslateTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionTranslate(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionTranslateAnchor(_ constant: MapboxMaps.FillExtrusionTranslateAnchor) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionTranslateAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionVerticalGradient(_ constant: Swift.Bool) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionVerticalGradient(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionVerticalScale(_ constant: Swift.Double) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionVerticalScaleTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillExtrusionLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillExtrusionVerticalScale(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillExtrusionLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.FillExtrusionLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct FillLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var fillSortKey: MapboxMaps.Value<Swift.Double>?
  public var fillAntialias: MapboxMaps.Value<Swift.Bool>?
  public var fillColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var fillColorTransition: MapboxMaps.StyleTransition?
  public var fillEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var fillEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var fillOpacity: MapboxMaps.Value<Swift.Double>?
  public var fillOpacityTransition: MapboxMaps.StyleTransition?
  public var fillOutlineColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var fillOutlineColorTransition: MapboxMaps.StyleTransition?
  public var fillPattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var fillTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var fillTranslateTransition: MapboxMaps.StyleTransition?
  public var fillTranslateAnchor: MapboxMaps.Value<MapboxMaps.FillTranslateAnchor>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.FillLayer, b: MapboxMaps.FillLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.FillLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillSortKey(_ constant: Swift.Double) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillSortKey(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillAntialias(_ constant: Swift.Bool) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillAntialias(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillColor(_ color: UIKit.UIColor) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillOpacity(_ constant: Swift.Double) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillOutlineColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillOutlineColor(_ color: UIKit.UIColor) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillOutlineColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillOutlineColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillPattern(_ constant: Swift.String) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillPattern(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillTranslate(x: Swift.Double, y: Swift.Double) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillTranslateTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillTranslate(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillTranslateAnchor(_ constant: MapboxMaps.FillTranslateAnchor) -> MapboxMaps.FillLayer
  @_spi(Experimental) @_documentation(visibility: public) public func fillTranslateAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FillLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.FillLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct FlatLight : Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public let id: Swift.String
  public let type: MapboxMaps.LightType
  public var anchor: MapboxMaps.Value<MapboxMaps.Anchor>?
  public var color: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var colorTransition: MapboxMaps.StyleTransition?
  public var intensity: MapboxMaps.Value<Swift.Double>?
  public var intensityTransition: MapboxMaps.StyleTransition?
  public var position: MapboxMaps.Value<[Swift.Double]>?
  public var positionTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String = UUID().uuidString)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.FlatLight, b: MapboxMaps.FlatLight) -> Swift.Bool
}
extension MapboxMaps.FlatLight {
  @_documentation(visibility: public) public func anchor(_ constant: MapboxMaps.Anchor) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func anchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func color(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func color(_ color: UIKit.UIColor) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func colorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func color(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func intensity(_ constant: Swift.Double) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func intensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func intensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func position(radial: Swift.Double, azimuthal: Swift.Double, polar: Swift.Double) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func positionTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.FlatLight
  @_documentation(visibility: public) public func position(_ expression: MapboxMaps.Expression) -> MapboxMaps.FlatLight
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.FlatLight : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_hasMissingDesignatedInitializers final public class FlyToCameraAnimator : MapboxMaps.CameraAnimator {
  final public let owner: MapboxMaps.AnimationOwner
  final public let duration: Foundation.TimeInterval
  final public var state: UIKit.UIViewAnimatingState {
    get
  }
  final public var onStarted: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onFinished: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public var onCancelled: MapboxMaps.Signal<Swift.Void> {
    get
  }
  final public func stopAnimation()
  @objc final public func cancel()
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class FollowPuckViewportState {
  final public var options: MapboxMaps.FollowPuckViewportStateOptions {
    get
    set
  }
  @objc deinit
}
extension MapboxMaps.FollowPuckViewportState : MapboxMaps.ViewportState {
  final public func observeDataSource(with handler: @escaping (MapboxMaps.CameraOptions) -> Swift.Bool) -> any MapboxCommon.Cancelable
  final public func startUpdatingCamera()
  final public func stopUpdatingCamera()
}
public enum FollowPuckViewportStateBearing : Swift.Codable, Swift.Hashable {
  case constant(_: CoreLocation.CLLocationDirection)
  case heading
  case course
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.FollowPuckViewportStateBearing, b: MapboxMaps.FollowPuckViewportStateBearing) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
public struct FollowPuckViewportStateOptions : Swift.Codable, Swift.Hashable {
  public var padding: UIKit.UIEdgeInsets? {
    get
    set
  }
  public var zoom: CoreFoundation.CGFloat?
  public var bearing: MapboxMaps.FollowPuckViewportStateBearing?
  public var pitch: CoreFoundation.CGFloat?
  public init(padding: UIKit.UIEdgeInsets? = nil, zoom: CoreFoundation.CGFloat? = 16.35, bearing: MapboxMaps.FollowPuckViewportStateBearing? = .heading, pitch: CoreFoundation.CGFloat? = 45)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.FollowPuckViewportStateOptions, b: MapboxMaps.FollowPuckViewportStateOptions) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct ForEvery<Content, Data, ID> where Data : Swift.RandomAccessCollection, ID : Swift.Hashable {
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.ForEvery : MapboxMaps.MapContent where Content : MapboxMaps.MapContent {
  @_spi(Experimental) @_documentation(visibility: public) public init(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, @MapboxMaps.MapContentBuilder content: @escaping (Data.Element) -> Content)
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init(_ data: Data, @MapboxMaps.MapContentBuilder content: @escaping (Data.Element) -> Content) where ID == Data.Element.ID, Data.Element : Swift.Identifiable
  @_spi(Experimental) public typealias Body = Swift.Never
}
extension MapboxCoreMaps.FreeCameraOptions {
  public var location: CoreLocation.CLLocationCoordinate2D {
    get
    set
  }
  public var altitude: CoreLocation.CLLocationDistance {
    get
    set
  }
}
public struct GeoJSONSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var data: MapboxMaps.GeoJSONSourceData?
  public var maxzoom: Swift.Double?
  public var attribution: Swift.String?
  public var buffer: Swift.Double?
  public var tolerance: Swift.Double?
  public var cluster: Swift.Bool?
  public var clusterRadius: Swift.Double?
  public var clusterMaxZoom: Swift.Double?
  public var clusterMinPoints: Swift.Double?
  public var clusterProperties: [Swift.String : MapboxMaps.Expression]?
  public var lineMetrics: Swift.Bool?
  public var generateId: Swift.Bool?
  public var promoteId: MapboxMaps.PromoteId?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.GeoJSONSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.GeoJSONSource {
  @_spi(Experimental) @_documentation(visibility: public) public func data(_ newValue: MapboxMaps.GeoJSONSourceData) -> MapboxMaps.GeoJSONSource
  @_spi(Experimental) @_documentation(visibility: public) public func prefetchZoomDelta(_ newValue: Swift.Double) -> MapboxMaps.GeoJSONSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileCacheBudget(_ newValue: MapboxMaps.TileCacheBudgetSize) -> MapboxMaps.GeoJSONSource
}
public enum GeoJSONSourceData : Swift.Codable, Swift.Equatable {
  case string(Swift.String)
  case feature(MapboxMaps.Feature)
  case featureCollection(Turf.FeatureCollection)
  case geometry(MapboxMaps.Geometry)
  @available(*, unavailable, message: "use nil data.")
  case empty
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func url(_ url: Foundation.URL) -> MapboxMaps.GeoJSONSourceData
  public static func == (a: MapboxMaps.GeoJSONSourceData, b: MapboxMaps.GeoJSONSourceData) -> Swift.Bool
}
public typealias Geometry = Turf.Geometry
public protocol GestureManagerDelegate : AnyObject {
  func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didBegin gestureType: MapboxMaps.GestureType)
  func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didEnd gestureType: MapboxMaps.GestureType, willAnimate: Swift.Bool)
  func gestureManager(_ gestureManager: MapboxMaps.GestureManager, didEndAnimatingFor gestureType: MapboxMaps.GestureType)
}
@_hasMissingDesignatedInitializers final public class GestureManager {
  final public var options: MapboxMaps.GestureOptions {
    get
    set
  }
  final public var panGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var pinchGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var rotateGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var pitchGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var doubleTapToZoomInGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var doubleTouchToZoomOutGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var quickZoomGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var singleTapGestureRecognizer: UIKit.UIGestureRecognizer {
    get
  }
  final public var onMapTap: MapboxMaps.Signal<MapboxMaps.MapContentGestureContext> {
    get
  }
  final public var onMapLongPress: MapboxMaps.Signal<MapboxMaps.MapContentGestureContext> {
    get
  }
  final public func onLayerTap(_ layerId: Swift.String, handler: @escaping MapboxMaps.MapLayerGestureHandler) -> MapboxMaps.AnyCancelable
  final public func onLayerLongPress(_ layerId: Swift.String, handler: @escaping MapboxMaps.MapLayerGestureHandler) -> MapboxMaps.AnyCancelable
  weak final public var delegate: (any MapboxMaps.GestureManagerDelegate)?
  @objc deinit
}
public enum PanMode : Swift.String, Swift.Equatable, Swift.CaseIterable {
  case horizontal
  case vertical
  case horizontalAndVertical
  public init?(rawValue: Swift.String)
  public typealias AllCases = [MapboxMaps.PanMode]
  public typealias RawValue = Swift.String
  public static var allCases: [MapboxMaps.PanMode] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
public struct GestureOptions : Swift.Equatable {
  public var panEnabled: Swift.Bool
  public var pinchEnabled: Swift.Bool
  public var rotateEnabled: Swift.Bool
  public var simultaneousRotateAndPinchZoomEnabled: Swift.Bool
  public var pinchZoomEnabled: Swift.Bool
  public var pinchPanEnabled: Swift.Bool
  public var pitchEnabled: Swift.Bool
  public var doubleTapToZoomInEnabled: Swift.Bool
  public var doubleTouchToZoomOutEnabled: Swift.Bool
  public var quickZoomEnabled: Swift.Bool
  public var panMode: MapboxMaps.PanMode
  public var panDecelerationFactor: CoreFoundation.CGFloat
  public var focalPoint: CoreFoundation.CGPoint?
  public init(panEnabled: Swift.Bool = true, pinchEnabled: Swift.Bool = true, rotateEnabled: Swift.Bool = true, simultaneousRotateAndPinchZoomEnabled: Swift.Bool = true, pinchZoomEnabled: Swift.Bool = true, pinchPanEnabled: Swift.Bool = true, pitchEnabled: Swift.Bool = true, doubleTapToZoomInEnabled: Swift.Bool = true, doubleTouchToZoomOutEnabled: Swift.Bool = true, quickZoomEnabled: Swift.Bool = true, panMode: MapboxMaps.PanMode = .horizontalAndVertical, panDecelerationFactor: CoreFoundation.CGFloat = UIScrollView.DecelerationRate.normal.rawValue, focalPoint: CoreFoundation.CGPoint? = nil)
  public static func == (a: MapboxMaps.GestureOptions, b: MapboxMaps.GestureOptions) -> Swift.Bool
}
public enum GestureType : Swift.Hashable, Swift.CaseIterable {
  case pan
  case pinch
  case pitch
  case doubleTapToZoomIn
  case doubleTouchToZoomOut
  case quickZoom
  case singleTap
  case rotation
  public static func == (a: MapboxMaps.GestureType, b: MapboxMaps.GestureType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [MapboxMaps.GestureType]
  public static var allCases: [MapboxMaps.GestureType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
extension MapboxCoreMaps.GlyphsRasterizationOptions {
  convenience public init(rasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode = .ideographsRasterizedLocally, fontFamilies: [Swift.String] = [])
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic open var hash: Swift.Int {
    @objc get
  }
}
public struct Heading : Swift.Equatable {
  public var direction: CoreLocation.CLLocationDirection
  public var accuracy: CoreLocation.CLLocationDirection
  public var timestamp: Foundation.Date
  public init(direction: CoreLocation.CLLocationDirection, accuracy: CoreLocation.CLLocationDirection, timestamp: Foundation.Date = Date())
  @available(visionOS, unavailable)
  public init(from clHeading: CoreLocation.CLHeading)
  public static func == (a: MapboxMaps.Heading, b: MapboxMaps.Heading) -> Swift.Bool
}
public protocol HeadingObserver : AnyObject {
  func onHeadingUpdate(_ heading: MapboxMaps.Heading)
}
public protocol HeadingProvider {
  var latestHeading: MapboxMaps.Heading? { get }
  func add(headingObserver: any MapboxMaps.HeadingObserver)
  func remove(headingObserver: any MapboxMaps.HeadingObserver)
}
public struct HeatmapLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var heatmapColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var heatmapIntensity: MapboxMaps.Value<Swift.Double>?
  public var heatmapIntensityTransition: MapboxMaps.StyleTransition?
  public var heatmapOpacity: MapboxMaps.Value<Swift.Double>?
  public var heatmapOpacityTransition: MapboxMaps.StyleTransition?
  public var heatmapRadius: MapboxMaps.Value<Swift.Double>?
  public var heatmapRadiusTransition: MapboxMaps.StyleTransition?
  public var heatmapWeight: MapboxMaps.Value<Swift.Double>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.HeatmapLayer, b: MapboxMaps.HeatmapLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.HeatmapLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapColor(_ color: UIKit.UIColor) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapIntensity(_ constant: Swift.Double) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapOpacity(_ constant: Swift.Double) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapRadius(_ constant: Swift.Double) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapWeight(_ constant: Swift.Double) -> MapboxMaps.HeatmapLayer
  @_spi(Experimental) @_documentation(visibility: public) public func heatmapWeight(_ expression: MapboxMaps.Expression) -> MapboxMaps.HeatmapLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.HeatmapLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct HillshadeLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var hillshadeAccentColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var hillshadeAccentColorTransition: MapboxMaps.StyleTransition?
  public var hillshadeEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var hillshadeEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var hillshadeExaggeration: MapboxMaps.Value<Swift.Double>?
  public var hillshadeExaggerationTransition: MapboxMaps.StyleTransition?
  public var hillshadeHighlightColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var hillshadeHighlightColorTransition: MapboxMaps.StyleTransition?
  public var hillshadeIlluminationAnchor: MapboxMaps.Value<MapboxMaps.HillshadeIlluminationAnchor>?
  public var hillshadeIlluminationDirection: MapboxMaps.Value<Swift.Double>?
  public var hillshadeShadowColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var hillshadeShadowColorTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.HillshadeLayer, b: MapboxMaps.HillshadeLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.HillshadeLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeAccentColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeAccentColor(_ color: UIKit.UIColor) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeAccentColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeAccentColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeExaggeration(_ constant: Swift.Double) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeExaggerationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeExaggeration(_ expression: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeHighlightColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeHighlightColor(_ color: UIKit.UIColor) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeHighlightColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeHighlightColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeIlluminationAnchor(_ constant: MapboxMaps.HillshadeIlluminationAnchor) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeIlluminationAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeIlluminationDirection(_ constant: Swift.Double) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeIlluminationDirection(_ expression: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeShadowColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeShadowColor(_ color: UIKit.UIColor) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeShadowColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.HillshadeLayer
  @_spi(Experimental) @_documentation(visibility: public) public func hillshadeShadowColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.HillshadeLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.HillshadeLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct ImageSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var coordinates: [[Swift.Double]]?
  public var prefetchZoomDelta: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.ImageSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.ImageSource {
  @_spi(Experimental) @_documentation(visibility: public) public func url(_ newValue: Swift.String) -> MapboxMaps.ImageSource
  @_spi(Experimental) @_documentation(visibility: public) public func coordinates(_ newValue: [[Swift.Double]]) -> MapboxMaps.ImageSource
  @_spi(Experimental) @_documentation(visibility: public) public func prefetchZoomDelta(_ newValue: Swift.Double) -> MapboxMaps.ImageSource
}
@_hasMissingDesignatedInitializers final public class ImmediateViewportTransition : MapboxMaps.ViewportTransition {
  final public func run(to toState: any MapboxMaps.ViewportState, completion: @escaping (Swift.Bool) -> Swift.Void) -> any MapboxCommon.Cancelable
  @objc deinit
}
public enum ImportPosition : Swift.Equatable, Swift.Codable {
  case `default`
  case above(Swift.String)
  case below(Swift.String)
  case at(Swift.Int)
  public static func == (a: MapboxMaps.ImportPosition, b: MapboxMaps.ImportPosition) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public protocol Layer : MapboxMaps.StyleDecodable, MapboxMaps.StyleEncodable, Swift.Decodable, Swift.Encodable {
  var id: Swift.String { get set }
  var type: MapboxMaps.LayerType { get }
  var visibility: MapboxMaps.Value<MapboxMaps.Visibility> { get set }
  var minZoom: Swift.Double? { get set }
  var maxZoom: Swift.Double? { get set }
  var slot: MapboxMaps.Slot? { get set }
}
extension MapboxMaps.Layer {
  public init(jsonObject: [Swift.String : Any]) throws
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct LayerAtPosition<L> : MapboxMaps.MapStyleContent where L : MapboxMaps.Layer, L : Swift.Equatable {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.SlotLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func position(_ position: MapboxMaps.LayerPosition) -> MapboxMaps.LayerAtPosition<MapboxMaps.SlotLayer>
}
public struct LayerInfo {
  public var id: Swift.String
  public var type: MapboxMaps.LayerType
  public init(id: Swift.String, type: MapboxMaps.LayerType)
}
public enum LayerPosition : Swift.Equatable, Swift.Codable {
  case `default`
  case above(Swift.String)
  case below(Swift.String)
  case at(Swift.Int)
  public static func == (a: MapboxMaps.LayerPosition, b: MapboxMaps.LayerPosition) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct LayerType : Swift.ExpressibleByStringLiteral, Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public static let fill: MapboxMaps.LayerType
  public static let line: MapboxMaps.LayerType
  public static let symbol: MapboxMaps.LayerType
  public static let circle: MapboxMaps.LayerType
  public static let heatmap: MapboxMaps.LayerType
  public static let fillExtrusion: MapboxMaps.LayerType
  public static let raster: MapboxMaps.LayerType
  public static let rasterParticle: MapboxMaps.LayerType
  public static let hillshade: MapboxMaps.LayerType
  public static let background: MapboxMaps.LayerType
  public static let locationIndicator: MapboxMaps.LayerType
  public static let sky: MapboxMaps.LayerType
  public static let slot: MapboxMaps.LayerType
  @_spi(Experimental) @_documentation(visibility: public) public static let model: MapboxMaps.LayerType
  public static let custom: MapboxMaps.LayerType
  public init(stringLiteral type: Swift.String)
  public init(rawValue: Swift.String)
  public var layerType: (any MapboxMaps.Layer.Type)? {
    get
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct LightInfo : Swift.Decodable {
  public var id: Swift.String
  public var type: MapboxMaps.LightType
  public init(id: Swift.String, type: MapboxMaps.LightType)
  public init(from decoder: any Swift.Decoder) throws
}
public struct LightType : Swift.RawRepresentable, Swift.Codable, Swift.Equatable {
  public static let flat: MapboxMaps.LightType
  public static let ambient: MapboxMaps.LightType
  public static let directional: MapboxMaps.LightType
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public struct LineLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var lineCap: MapboxMaps.Value<MapboxMaps.LineCap>?
  public var lineJoin: MapboxMaps.Value<MapboxMaps.LineJoin>?
  public var lineMiterLimit: MapboxMaps.Value<Swift.Double>?
  public var lineRoundLimit: MapboxMaps.Value<Swift.Double>?
  public var lineSortKey: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var lineZOffset: MapboxMaps.Value<Swift.Double>?
  public var lineBlur: MapboxMaps.Value<Swift.Double>?
  public var lineBlurTransition: MapboxMaps.StyleTransition?
  public var lineBorderColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var lineBorderColorTransition: MapboxMaps.StyleTransition?
  public var lineBorderWidth: MapboxMaps.Value<Swift.Double>?
  public var lineBorderWidthTransition: MapboxMaps.StyleTransition?
  public var lineColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var lineColorTransition: MapboxMaps.StyleTransition?
  public var lineDasharray: MapboxMaps.Value<[Swift.Double]>?
  public var lineDepthOcclusionFactor: MapboxMaps.Value<Swift.Double>?
  public var lineDepthOcclusionFactorTransition: MapboxMaps.StyleTransition?
  public var lineEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var lineEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var lineGapWidth: MapboxMaps.Value<Swift.Double>?
  public var lineGapWidthTransition: MapboxMaps.StyleTransition?
  public var lineGradient: MapboxMaps.Value<MapboxMaps.StyleColor>?
  @_spi(Experimental) @_documentation(visibility: public) public var lineOcclusionOpacity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var lineOcclusionOpacityTransition: MapboxMaps.StyleTransition?
  public var lineOffset: MapboxMaps.Value<Swift.Double>?
  public var lineOffsetTransition: MapboxMaps.StyleTransition?
  public var lineOpacity: MapboxMaps.Value<Swift.Double>?
  public var lineOpacityTransition: MapboxMaps.StyleTransition?
  public var linePattern: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var lineTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var lineTranslateTransition: MapboxMaps.StyleTransition?
  public var lineTranslateAnchor: MapboxMaps.Value<MapboxMaps.LineTranslateAnchor>?
  public var lineTrimOffset: MapboxMaps.Value<[Swift.Double]>?
  public var lineWidth: MapboxMaps.Value<Swift.Double>?
  public var lineWidthTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.LineLayer, b: MapboxMaps.LineLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.LineLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineCap(_ constant: MapboxMaps.LineCap) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineCap(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineJoin(_ constant: MapboxMaps.LineJoin) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineJoin(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineMiterLimit(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineMiterLimit(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineRoundLimit(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineRoundLimit(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineSortKey(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineSortKey(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineZOffset(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineZOffset(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBlur(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBlurTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBlur(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderColor(_ color: UIKit.UIColor) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderWidth(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderWidthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderWidth(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineColor(_ color: UIKit.UIColor) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineDashArray(_ constant: [Swift.Double]) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineDashArray(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineDepthOcclusionFactor(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineDepthOcclusionFactorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineDepthOcclusionFactor(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineGapWidth(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineGapWidthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineGapWidth(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineGradient(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineGradient(_ color: UIKit.UIColor) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineGradient(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOcclusionOpacity(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOcclusionOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOcclusionOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOffset(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOffsetTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOffset(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOpacity(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func linePattern(_ constant: Swift.String) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func linePattern(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineTranslate(x: Swift.Double, y: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineTranslateTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineTranslate(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineTranslateAnchor(_ constant: MapboxMaps.LineTranslateAnchor) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineTranslateAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineTrimOffset(start: Swift.Double, end: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineTrimOffset(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineWidth(_ constant: Swift.Double) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineWidthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LineLayer
  @_spi(Experimental) @_documentation(visibility: public) public func lineWidth(_ expression: MapboxMaps.Expression) -> MapboxMaps.LineLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.LineLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct LocationIndicatorLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var bearingImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var shadowImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var topImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var accuracyRadius: MapboxMaps.Value<Swift.Double>?
  public var accuracyRadiusTransition: MapboxMaps.StyleTransition?
  public var accuracyRadiusBorderColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var accuracyRadiusBorderColorTransition: MapboxMaps.StyleTransition?
  public var accuracyRadiusColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var accuracyRadiusColorTransition: MapboxMaps.StyleTransition?
  public var bearing: MapboxMaps.Value<Swift.Double>?
  public var bearingTransition: MapboxMaps.StyleTransition?
  public var bearingImageSize: MapboxMaps.Value<Swift.Double>?
  public var bearingImageSizeTransition: MapboxMaps.StyleTransition?
  public var emphasisCircleColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var emphasisCircleColorTransition: MapboxMaps.StyleTransition?
  public var emphasisCircleRadius: MapboxMaps.Value<Swift.Double>?
  public var emphasisCircleRadiusTransition: MapboxMaps.StyleTransition?
  public var imagePitchDisplacement: MapboxMaps.Value<Swift.Double>?
  public var location: MapboxMaps.Value<[Swift.Double]>?
  public var locationTransition: MapboxMaps.StyleTransition?
  public var locationIndicatorOpacity: MapboxMaps.Value<Swift.Double>?
  public var locationIndicatorOpacityTransition: MapboxMaps.StyleTransition?
  public var perspectiveCompensation: MapboxMaps.Value<Swift.Double>?
  public var shadowImageSize: MapboxMaps.Value<Swift.Double>?
  public var shadowImageSizeTransition: MapboxMaps.StyleTransition?
  public var topImageSize: MapboxMaps.Value<Swift.Double>?
  public var topImageSizeTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.LocationIndicatorLayer, b: MapboxMaps.LocationIndicatorLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.LocationIndicatorLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearingImage(_ constant: Swift.String) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearingImage(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func shadowImage(_ constant: Swift.String) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func shadowImage(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func topImage(_ constant: Swift.String) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func topImage(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadius(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusBorderColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusBorderColor(_ color: UIKit.UIColor) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusBorderColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusBorderColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusColor(_ color: UIKit.UIColor) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRadiusColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearing(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearingTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearing(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearingImageSize(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearingImageSizeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func bearingImageSize(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func emphasisCircleColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func emphasisCircleColor(_ color: UIKit.UIColor) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func emphasisCircleColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func emphasisCircleColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func emphasisCircleRadius(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func emphasisCircleRadiusTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func emphasisCircleRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func imagePitchDisplacement(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func imagePitchDisplacement(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func location(_ coordinate: CoreLocation.CLLocationCoordinate2D) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func locationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func location(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func locationIndicatorOpacity(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func locationIndicatorOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func locationIndicatorOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func perspectiveCompensation(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func perspectiveCompensation(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func shadowImageSize(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func shadowImageSizeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func shadowImageSize(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func topImageSize(_ constant: Swift.Double) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func topImageSizeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.LocationIndicatorLayer
  @_spi(Experimental) @_documentation(visibility: public) public func topImageSize(_ expression: MapboxMaps.Expression) -> MapboxMaps.LocationIndicatorLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.LocationIndicatorLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_hasMissingDesignatedInitializers final public class LocationManager {
  final public var onLocationChange: MapboxMaps.Signal<[MapboxCommon.Location]> {
    get
  }
  final public var onHeadingChange: MapboxMaps.Signal<MapboxMaps.Heading> {
    get
  }
  final public let onPuckRender: MapboxMaps.Signal<MapboxMaps.PuckRenderingData>
  final public var options: MapboxMaps.LocationOptions {
    get
    set
  }
  final public func override(locationProvider: MapboxMaps.Signal<[MapboxCommon.Location]>, headingProvider: MapboxMaps.Signal<MapboxMaps.Heading>? = nil)
  final public func override(locationProvider: any MapboxCommon.LocationProvider, headingProvider: (any MapboxMaps.HeadingProvider)? = nil)
  final public func override(provider: any MapboxCommon.LocationProvider & MapboxMaps.HeadingProvider)
  final public var latestLocation: MapboxCommon.Location? {
    get
  }
  @available(*, unavailable, message: "Use override(provider:) instead")
  final public func overrideLocationProvider(with customLocationProvider: any MapboxCommon.LocationProvider)
  @available(*, unavailable, message: "Use onLocationChange")
  final public func addLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use onLocationChange")
  final public func removeLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use onPuckRender")
  final public func addPuckLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use onPuckRender")
  final public func removePuckLocationConsumer(_ consumer: Swift.Void)
  @available(*, unavailable, message: "Use AppleLocationProvider.requestTemporaryFullAccuracyAuthorization(withPurposeKey:) instead")
  final public func requestTemporaryFullAccuracyPermissions(withPurposeKey purposeKey: Swift.String)
  @available(*, unavailable, message: "Use AppleLocationProvider.delegate instead")
  weak final public var delegate: (any MapboxMaps.LocationPermissionsDelegate)? {
    get
  }
  @available(*, unavailable, message: "Use onLocationChange instead")
  final public var locationProvider: (any MapboxCommon.LocationProvider)? {
    get
  }
  @objc deinit
}
public struct LocationOptions : Swift.Equatable {
  @available(*, unavailable, message: "Use AppleLocationProvider.Options.distanceFilter instead")
  public var distanceFilter: CoreLocation.CLLocationDistance {
    get
  }
  @available(*, unavailable, message: "Use AppleLocationProvider.Options.desiredAccuracy instead")
  public var desiredAccuracy: CoreLocation.CLLocationAccuracy {
    get
  }
  @available(*, unavailable, message: "Use AppleLocationProvider.Options.activityType instead")
  public var activityType: CoreLocation.CLActivityType {
    get
  }
  public var puckType: MapboxMaps.PuckType?
  public var puckBearing: MapboxMaps.PuckBearing
  public var puckBearingEnabled: Swift.Bool
  public init(puckType: MapboxMaps.PuckType? = nil, puckBearing: MapboxMaps.PuckBearing = .heading, puckBearingEnabled: Swift.Bool = false)
  public static func == (a: MapboxMaps.LocationOptions, b: MapboxMaps.LocationOptions) -> Swift.Bool
}
public enum PuckBearing : Swift.Equatable {
  case heading
  case course
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.PuckBearing, b: MapboxMaps.PuckBearing) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@available(*, unavailable, renamed: "AppleLocationProviderDelegate")
public protocol LocationPermissionsDelegate : AnyObject {
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) extension MapboxMaps.Map {
  @_spi(Experimental) @_documentation(visibility: public) public func onMapLoaded(action: @escaping (MapboxCoreMaps.MapLoaded) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onMapLoadingError(action: @escaping (MapboxCoreMaps.MapLoadingError) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onStyleLoaded(action: @escaping (MapboxCoreMaps.StyleLoaded) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onStyleDataLoaded(action: @escaping (MapboxCoreMaps.StyleDataLoaded) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onCameraChanged(action: @escaping (MapboxCoreMaps.CameraChanged) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onMapIdle(action: @escaping (MapboxCoreMaps.MapIdle) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onSourceAdded(action: @escaping (MapboxCoreMaps.SourceAdded) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onSourceRemoved(action: @escaping (MapboxCoreMaps.SourceRemoved) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onSourceDataLoaded(action: @escaping (MapboxCoreMaps.SourceDataLoaded) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onStyleImageMissing(action: @escaping (MapboxCoreMaps.StyleImageMissing) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onStyleImageRemoveUnused(action: @escaping (MapboxCoreMaps.StyleImageRemoveUnused) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onRenderFrameStarted(action: @escaping (MapboxCoreMaps.RenderFrameStarted) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onRenderFrameFinished(action: @escaping (MapboxCoreMaps.RenderFrameFinished) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onResourceRequest(action: @escaping (MapboxCoreMaps.ResourceRequest) -> Swift.Void) -> MapboxMaps.Map
}
@_spi(Experimental) @_documentation(visibility: public) public struct MapGestureHandlers {
  @_spi(Experimental) @_documentation(visibility: public) public var onBegin: ((MapboxMaps.GestureType) -> Swift.Void)?
  @_spi(Experimental) @_documentation(visibility: public) public var onEnd: ((MapboxMaps.GestureType, Swift.Bool) -> Swift.Void)?
  @_spi(Experimental) @_documentation(visibility: public) public var onAnimationEnd: ((MapboxMaps.GestureType) -> Swift.Void)?
  @_spi(Experimental) @_documentation(visibility: public) public init(onBegin: ((MapboxMaps.GestureType) -> Swift.Void)? = nil, onEnd: ((MapboxMaps.GestureType, Swift.Bool) -> Swift.Void)? = nil, onEndAnimation: ((MapboxMaps.GestureType) -> Swift.Void)? = nil)
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) extension MapboxMaps.Map {
  @_spi(Experimental) @_documentation(visibility: public) public func onMapTapGesture(perform action: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onMapLongPressGesture(perform action: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onLayerTapGesture(_ layerId: Swift.String, perform action: @escaping MapboxMaps.MapLayerGestureHandler) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func onLayerLongPressGesture(_ layerId: Swift.String, perform action: @escaping MapboxMaps.MapLayerGestureHandler) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func gestureOptions(_ options: MapboxMaps.GestureOptions) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func gestureHandlers(_ handlers: MapboxMaps.MapGestureHandlers) -> MapboxMaps.Map
}
@_spi(Experimental) @available(iOS 13, *)
@_documentation(visibility: public) public typealias MapURLOpener = (Foundation.URL) -> Swift.Void
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct Map : SwiftUI.UIViewControllerRepresentable {
  @_spi(Experimental) @available(iOSApplicationExtension, unavailable)
  @_documentation(visibility: public) public init(viewport: SwiftUI.Binding<MapboxMaps.Viewport>, @MapboxMaps.MapContentBuilder content: @escaping () -> some MapContent)
  @_spi(Experimental) @available(iOSApplicationExtension, unavailable)
  @_documentation(visibility: public) public init(initialViewport: MapboxMaps.Viewport = .styleDefault, @MapboxMaps.MapContentBuilder content: @escaping () -> some MapContent)
  @_spi(Experimental) @_Concurrency.MainActor(unsafe) public func makeCoordinator() -> MapboxMaps.Map.Coordinator
  @_spi(Experimental) @_Concurrency.MainActor(unsafe) public func makeUIViewController(context: MapboxMaps.Map.Context) -> UIKit.UIViewController
  @_spi(Experimental) @_Concurrency.MainActor(unsafe) public func updateUIViewController(_ mapController: UIKit.UIViewController, context: MapboxMaps.Map.Context)
  @_spi(Experimental) public typealias Body = Swift.Never
  @_spi(Experimental) public typealias UIViewControllerType = UIKit.UIViewController
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) extension MapboxMaps.Map {
  @_spi(Experimental) @available(iOSApplicationExtension, unavailable)
  @_documentation(visibility: public) public init(viewport: SwiftUI.Binding<MapboxMaps.Viewport>)
  @_spi(Experimental) @available(iOSApplicationExtension, unavailable)
  @_documentation(visibility: public) public init(initialViewport: MapboxMaps.Viewport = .styleDefault)
  @_spi(Experimental) @_documentation(visibility: public) public init(viewport: SwiftUI.Binding<MapboxMaps.Viewport>, urlOpener: @escaping MapboxMaps.MapURLOpener, @MapboxMaps.MapContentBuilder content: @escaping () -> some MapContent)
  @_spi(Experimental) @_documentation(visibility: public) public init(initialViewport: MapboxMaps.Viewport = .styleDefault, urlOpener: @escaping MapboxMaps.MapURLOpener, @MapboxMaps.MapContentBuilder content: @escaping () -> some MapContent)
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) extension MapboxMaps.Map {
  @_spi(Experimental) @_documentation(visibility: public) public func cameraBounds(_ cameraBounds: MapboxMaps.CameraBoundsOptions) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func mapStyle(_ mapStyle: MapboxMaps.MapStyle) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func constrainMode(_ constrainMode: MapboxCoreMaps.ConstrainMode) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func viewportMode(_ viewportMode: MapboxCoreMaps.ViewportMode) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func northOrientation(_ northOrientation: MapboxCoreMaps.NorthOrientation) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func ornamentOptions(_ options: MapboxMaps.OrnamentOptions) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func debugOptions(_ debugOptions: MapboxMaps.MapViewDebugOptions) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func opaque(_ value: Swift.Bool) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func frameRate(range: Swift.ClosedRange<Swift.Float>? = nil, preferred: Swift.Float? = nil) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func presentsWithTransaction(_ value: Swift.Bool) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func transitionsToIdleUponUserInteraction(_ value: Swift.Bool) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func usesSafeAreaInsetsAsPadding(_ value: Swift.Bool) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func additionalSafeAreaInsets(_ insets: SwiftUI.EdgeInsets) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func collectPerformanceStatistics(_ options: MapboxCoreMaps.PerformanceStatisticsOptions?, callback: @escaping (MapboxCoreMaps.PerformanceStatistics) -> Swift.Void) -> MapboxMaps.Map
  @_spi(Experimental) @_documentation(visibility: public) public func additionalSafeAreaInsets(_ edges: SwiftUI.Edge.Set = .all, _ length: CoreFoundation.CGFloat) -> MapboxMaps.Map
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.Map {
  @_spi(Experimental) @_hasMissingDesignatedInitializers final public class Coordinator {
    @_spi(Experimental) @objc deinit
  }
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public protocol MapContent {
  associatedtype Body : MapboxMaps.MapContent
  @_spi(Experimental) @MapboxMaps.MapContentBuilder var body: Self.Body { get }
}
@_spi(Experimental) @available(iOS 13.0, *)
public struct TupleMapContent<T> : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
public struct ConditionalMapContent<F, S> : MapboxMaps.MapContent where F : MapboxMaps.MapContent, S : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
public struct EmptyMapContent : MapboxMaps.MapContent {
  @_spi(Experimental) public init()
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
public struct OptionalMapContent<T> : MapboxMaps.MapContent where T : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) @_functionBuilder public struct MapContentBuilder {
  @_spi(Experimental) public static func buildExpression<Content>(_ content: Content) -> Content where Content : MapboxMaps.MapContent
  @_spi(Experimental) public static func buildExpression<Content>(_ content: Content) -> some MapboxMaps.MapContent where Content : MapboxMaps.MapStyleContent
  
  @_spi(Experimental) public static func buildBlock() -> MapboxMaps.EmptyMapContent
  #if compiler(>=5.3) && $ParameterPacks
  @_spi(Experimental) public static func buildBlock<each Content>(_ content: repeat each Content) -> MapboxMaps.TupleMapContent<(repeat each Content)> where repeat each Content : MapboxMaps.MapContent
  #endif
  @_spi(Experimental) public static func buildEither<First, Second>(first content: First) -> MapboxMaps.ConditionalMapContent<First, Second> where First : MapboxMaps.MapContent, Second : MapboxMaps.MapContent
  @_spi(Experimental) public static func buildEither<First, Second>(second content: Second) -> MapboxMaps.ConditionalMapContent<First, Second> where First : MapboxMaps.MapContent, Second : MapboxMaps.MapContent
  @_spi(Experimental) public static func buildOptional<T>(_ component: T?) -> MapboxMaps.OptionalMapContent<T> where T : MapboxMaps.MapContent
}
public struct MapContentGestureContext {
  public var point: CoreFoundation.CGPoint
  public var coordinate: CoreLocation.CLLocationCoordinate2D
}
public typealias MapLayerGestureHandler = (MapboxCoreMaps.QueriedFeature, MapboxMaps.MapContentGestureContext) -> Swift.Bool
@available(*, deprecated)
public struct MapEventType<Payload> {
  public static var mapLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.MapLoaded> {
    get
  }
  public static var mapLoadingError: MapboxMaps.MapEventType<MapboxCoreMaps.MapLoadingError> {
    get
  }
  public static var styleLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.StyleLoaded> {
    get
  }
  public static var styleDataLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.StyleDataLoaded> {
    get
  }
  public static var cameraChanged: MapboxMaps.MapEventType<MapboxCoreMaps.CameraChanged> {
    get
  }
  public static var mapIdle: MapboxMaps.MapEventType<MapboxCoreMaps.MapIdle> {
    get
  }
  public static var sourceAdded: MapboxMaps.MapEventType<MapboxCoreMaps.SourceAdded> {
    get
  }
  public static var sourceRemoved: MapboxMaps.MapEventType<MapboxCoreMaps.SourceRemoved> {
    get
  }
  public static var sourceDataLoaded: MapboxMaps.MapEventType<MapboxCoreMaps.SourceDataLoaded> {
    get
  }
  public static var styleImageMissing: MapboxMaps.MapEventType<MapboxCoreMaps.StyleImageMissing> {
    get
  }
  public static var styleImageRemoveUnused: MapboxMaps.MapEventType<MapboxCoreMaps.StyleImageRemoveUnused> {
    get
  }
  public static var renderFrameStarted: MapboxMaps.MapEventType<MapboxCoreMaps.RenderFrameStarted> {
    get
  }
  public static var renderFrameFinished: MapboxMaps.MapEventType<MapboxCoreMaps.RenderFrameFinished> {
    get
  }
  public static var resourceRequest: MapboxMaps.MapEventType<MapboxCoreMaps.ResourceRequest> {
    get
  }
}
extension MapboxCoreMaps.MapLoadingError {
  @available(*, deprecated, message: "Use MapLoadingError fields to access the event data.")
  public var payload: MapboxCoreMaps.MapLoadingError {
    get
  }
  @available(*, deprecated, renamed: "type")
  public var error: MapboxCoreMaps.MapLoadingErrorType {
    get
  }
}
extension MapboxCoreMaps.StyleDataLoaded {
  @available(*, deprecated, message: "Use StyleDataLoaded fields to access the event data.")
  public var payload: MapboxCoreMaps.StyleDataLoaded {
    get
  }
}
extension MapboxCoreMaps.SourceAdded {
  @available(*, deprecated, message: "Use SourceAdded fields to access the event data.")
  public var payload: MapboxCoreMaps.SourceAdded {
    get
  }
  @available(*, deprecated, renamed: "sourceId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.SourceRemoved {
  @available(*, deprecated, message: "Use SourceRemoved fields to access the event data.")
  public var payload: MapboxCoreMaps.SourceRemoved {
    get
  }
  @available(*, deprecated, renamed: "sourceId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.SourceDataLoaded {
  @available(*, deprecated, message: "Use SourceDataLoaded fields to access the event data.")
  public var payload: MapboxCoreMaps.SourceDataLoaded {
    get
  }
  @available(*, deprecated, renamed: "sourceId")
  public var id: Swift.String? {
    get
  }
}
extension MapboxCoreMaps.StyleImageMissing {
  @available(*, deprecated, message: "Use StyleImageMissing fields to access the event data.")
  public var payload: MapboxCoreMaps.StyleImageMissing {
    get
  }
  @available(*, deprecated, renamed: "imageId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.StyleImageRemoveUnused {
  @available(*, deprecated, message: "Use StyleImageRemoveUnused fields to access the event data.")
  public var payload: MapboxCoreMaps.StyleImageRemoveUnused {
    get
  }
  @available(*, deprecated, renamed: "imageId")
  public var id: Swift.String {
    get
  }
}
extension MapboxCoreMaps.RenderFrameFinished {
  @available(*, deprecated, message: "Use RenderFrameFinished fields to access the event data.")
  public var payload: MapboxCoreMaps.RenderFrameFinished {
    get
  }
}
extension MapboxCoreMaps.ResourceRequest {
  @available(*, deprecated, message: "Use ResourceRequest fields to access the event data.")
  public var payload: MapboxCoreMaps.ResourceRequest {
    get
  }
  @available(*, deprecated, renamed: "source")
  public var dataSource: MapboxCoreMaps.RequestDataSourceType? {
    get
  }
}
@objc public protocol MapInitOptionsProvider {
  @objc func mapInitOptions() -> MapboxMaps.MapInitOptions
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class MapInitOptions : ObjectiveC.NSObject {
  final public let mapOptions: MapboxCoreMaps.MapOptions
  final public let styleURI: MapboxMaps.StyleURI?
  final public let styleJSON: Swift.String?
  final public let cameraOptions: MapboxMaps.CameraOptions?
  final public let antialiasingSampleCount: Swift.Int
  public init(mapOptions: MapboxCoreMaps.MapOptions = MapOptions(), cameraOptions: MapboxMaps.CameraOptions? = nil, styleURI: MapboxMaps.StyleURI? = .standard, styleJSON: Swift.String? = nil, antialiasingSampleCount: Swift.Int = 1)
  @objc override final public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override final public var hash: Swift.Int {
    @objc get
  }
  @objc deinit
}
extension MapboxCoreMaps.MapOptions {
  @available(*, unavailable, message: "'optimizeForTerrain' is obsolete and has no effect. Layer order is automatically adjusted for better performance based on the presence of terrain.")
  convenience public init(constrainMode: MapboxCoreMaps.ConstrainMode = .heightOnly, viewportMode: MapboxCoreMaps.ViewportMode = .default, orientation: MapboxCoreMaps.NorthOrientation = .upwards, crossSourceCollisions: Swift.Bool = true, optimizeForTerrain: Swift.Bool = true, size: CoreFoundation.CGSize? = nil, pixelRatio: CoreFoundation.CGFloat? = nil, glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions = GlyphsRasterizationOptions(fontFamilies: []))
  convenience public init(constrainMode: MapboxCoreMaps.ConstrainMode = .heightOnly, viewportMode: MapboxCoreMaps.ViewportMode = .default, orientation: MapboxCoreMaps.NorthOrientation = .upwards, crossSourceCollisions: Swift.Bool = true, size: CoreFoundation.CGSize? = nil, pixelRatio: CoreFoundation.CGFloat? = nil, glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions = GlyphsRasterizationOptions(fontFamilies: []))
  public var crossSourceCollisions: Swift.Bool {
    get
  }
  @available(*, unavailable, message: "Not needed anymore, layer order is automatically adjusted for better performance based on the presence of terrain.")
  public var optimizeForTerrain: Swift.Bool {
    get
  }
  public var size: CoreFoundation.CGSize? {
    get
  }
  @objc override dynamic public func isEqual(_ object: Any?) -> Swift.Bool
  @objc override dynamic open var hash: Swift.Int {
    @objc get
  }
}
public struct MapPlayerOptions {
  public init(playbackCount: Swift.Int, playbackSpeedMultiplier: Swift.Double, avoidPlaybackPauses: Swift.Bool)
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct MapProxy {
  @_spi(Experimental) @_documentation(visibility: public) public var camera: MapboxMaps.CameraAnimationsManager? {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var map: MapboxMaps.MapboxMap? {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var viewport: MapboxMaps.ViewportManager? {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var location: MapboxMaps.LocationManager? {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public func captureSnapshot(includeOverlays: Swift.Bool = false) -> UIKit.UIImage?
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct MapReader<Content> : SwiftUI.View where Content : SwiftUI.View {
  @_spi(Experimental) @_documentation(visibility: public) public typealias ContentProvider = (MapboxMaps.MapProxy) -> Content
  @_spi(Experimental) public var content: MapboxMaps.MapReader<Content>.ContentProvider
  @_spi(Experimental) @_documentation(visibility: public) public init(content: @escaping MapboxMaps.MapReader<Content>.ContentProvider)
  @_spi(Experimental) @_Concurrency.MainActor(unsafe) public var body: some SwiftUI.View {
    @_spi(Experimental) get
  }
  @_spi(Experimental) public typealias Body = @_opaqueReturnTypeOf("$s10MapboxMaps9MapReaderV4bodyQrvp", 0) __<Content>
}
@_spi(Experimental) @_hasMissingDesignatedInitializers final public class MapRecorder {
  @_spi(Experimental) final public func start(options: MapboxMaps.MapRecorderOptions = MapRecorderOptions(timeWindow: nil, loggingEnabled: false, compressed: false))
  @_spi(Experimental) final public func stop() -> Foundation.Data
  @_spi(Experimental) final public func replay(recordedSequence: Foundation.Data, options: MapboxMaps.MapPlayerOptions = MapPlayerOptions(playbackCount: 1, playbackSpeedMultiplier: 1.0, avoidPlaybackPauses: false), completion: @escaping () -> Swift.Void)
  @_spi(Experimental) final public func togglePauseReplay()
  @_spi(Experimental) final public func playbackState() -> Swift.String
  @_spi(Experimental) @objc deinit
}
public struct MapRecorderOptions {
  public init(timeWindow: Swift.Int?, loggingEnabled: Swift.Bool, compressed: Swift.Bool)
}
public struct MapSnapshotOptions {
  public var size: CoreFoundation.CGSize
  public var pixelRatio: CoreFoundation.CGFloat
  public var glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions
  public var showsLogo: Swift.Bool
  public var showsAttribution: Swift.Bool
  public init(size: CoreFoundation.CGSize, pixelRatio: CoreFoundation.CGFloat, glyphsRasterizationOptions: MapboxCoreMaps.GlyphsRasterizationOptions = GlyphsRasterizationOptions(), showsLogo: Swift.Bool = true, showsAttribution: Swift.Bool = true)
}
@_spi(Experimental) @_documentation(visibility: public) public struct MapStyle : Swift.Equatable {
  @_spi(Experimental) @_documentation(visibility: public) public init(json: Swift.String, configuration: Turf.JSONObject? = nil)
  @_spi(Experimental) @_documentation(visibility: public) public init(uri: MapboxMaps.StyleURI, configuration: Turf.JSONObject? = nil)
  @_spi(Experimental) @_documentation(visibility: public) public static var standard: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var streets: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var outdoors: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var light: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var dark: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var satellite: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var satelliteStreets: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var empty: MapboxMaps.MapStyle {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static func standard(lightPreset: MapboxMaps.StandardLightPreset?, font: Swift.String? = nil, showPointOfInterestLabels: Swift.Bool? = nil, showTransitLabels: Swift.Bool? = nil, showPlaceLabels: Swift.Bool? = nil, showRoadLabels: Swift.Bool? = nil) -> MapboxMaps.MapStyle
  @_spi(Experimental) public static func == (a: MapboxMaps.MapStyle, b: MapboxMaps.MapStyle) -> Swift.Bool
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public protocol MapStyleContent {
  associatedtype Body : MapboxMaps.MapStyleContent
  @_spi(Experimental) @MapboxMaps.MapStyleContentBuilder var body: Self.Body { get }
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct EmptyMapStyleContent : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public init()
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct TupleMapStyleContent<T> : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct ConditionalMapStyleContent<F, S> : MapboxMaps.MapStyleContent where F : MapboxMaps.MapStyleContent, S : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct OptionalMapStyleContent<T> : MapboxMaps.MapStyleContent where T : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) @_functionBuilder public struct MapStyleContentBuilder {
  @_spi(Experimental) public static func buildExpression<Content>(_ content: Content) -> Content where Content : MapboxMaps.MapStyleContent
  @_spi(Experimental) public static func buildBlock<Content>(_ content: Content) -> Content where Content : MapboxMaps.MapStyleContent
  @_spi(Experimental) public static func buildBlock() -> MapboxMaps.EmptyMapStyleContent
  #if compiler(>=5.3) && $ParameterPacks
  @_spi(Experimental) public static func buildBlock<each Content>(_ content: repeat each Content) -> MapboxMaps.TupleMapStyleContent<(repeat each Content)> where repeat each Content : MapboxMaps.MapStyleContent
  #endif
  @_spi(Experimental) public static func buildEither<First, Second>(first content: First) -> MapboxMaps.ConditionalMapStyleContent<First, Second> where First : MapboxMaps.MapStyleContent, Second : MapboxMaps.MapStyleContent
  @_spi(Experimental) public static func buildEither<First, Second>(second content: Second) -> MapboxMaps.ConditionalMapStyleContent<First, Second> where First : MapboxMaps.MapStyleContent, Second : MapboxMaps.MapStyleContent
  @_spi(Experimental) public static func buildOptional<T>(_ component: T?) -> MapboxMaps.OptionalMapStyleContent<T> where T : MapboxMaps.MapStyleContent
}
extension MapboxMaps.MapView {
  public struct SnapshotError : Swift.Error, Swift.Equatable {
    public let message: Swift.String
    public static let noMetalView: MapboxMaps.MapView.SnapshotError
    public static let missingImageData: MapboxMaps.MapView.SnapshotError
    public static func == (a: MapboxMaps.MapView.SnapshotError, b: MapboxMaps.MapView.SnapshotError) -> Swift.Bool
  }
  @_Concurrency.MainActor(unsafe) public func snapshot(includeOverlays: Swift.Bool = false) throws -> UIKit.UIImage
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class MapView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open class var layerClass: Swift.AnyClass {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) public var mapboxMap: MapboxMaps.MapboxMap! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var gestures: MapboxMaps.GestureManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var ornaments: MapboxMaps.OrnamentsManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var camera: MapboxMaps.CameraAnimationsManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var location: MapboxMaps.LocationManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var annotations: MapboxMaps.AnnotationOrchestrator! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var viewAnnotations: MapboxMaps.ViewAnnotationManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var viewport: MapboxMaps.ViewportManager! {
    get
  }
  @_Concurrency.MainActor(unsafe) public var presentsWithTransaction: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isOpaque: Swift.Bool {
    @objc get
    @objc set
  }
  @available(iOS, deprecated: 15, message: "Use preferredFrameRateRange instead.")
  @_Concurrency.MainActor(unsafe) public var preferredFramesPerSecond: Swift.Int {
    get
    set
  }
  @available(iOS 15.0, *)
  @_Concurrency.MainActor(unsafe) public var preferredFrameRateRange: QuartzCore.CAFrameRateRange {
    get
    set
  }
  @_spi(Metrics) @_Concurrency.MainActor(unsafe) public var displayLinkTimestamp: CoreFoundation.CFTimeInterval? {
    get
  }
  @_spi(Metrics) @_Concurrency.MainActor(unsafe) public var displayLinkDuration: CoreFoundation.CFTimeInterval? {
    get
  }
  @available(*, deprecated, renamed: "mapboxMap.cameraState")
  @_Concurrency.MainActor(unsafe) public var cameraState: MapboxMaps.CameraState {
    get
  }
  @available(*, deprecated, renamed: "mapboxMap.anchor")
  @_Concurrency.MainActor(unsafe) public var anchor: CoreFoundation.CGPoint {
    get
  }
  @_Concurrency.MainActor(unsafe) public var debugOptions: MapboxMaps.MapViewDebugOptions {
    get
    set
  }
  @available(iOSApplicationExtension, unavailable)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, mapInitOptions: MapboxMaps.MapInitOptions = MapInitOptions())
  @available(iOS, unavailable, message: "Use init(frame:mapInitOptions:urlOpener:) instead")
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, mapInitOptions: MapboxMaps.MapInitOptions = MapInitOptions(), orientationProvider: Swift.Void, urlOpener: any MapboxMaps.AttributionURLOpener)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, mapInitOptions: MapboxMaps.MapInitOptions = MapInitOptions(), urlOpener: any MapboxMaps.AttributionURLOpener)
  @available(iOSApplicationExtension, unavailable)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_spi(Metrics) @_Concurrency.MainActor(unsafe) public var metricsReporter: (any MapboxMaps.MapViewMetricsReporter)?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct MapViewAnnotation {
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init<Content>(coordinate: CoreLocation.CLLocationCoordinate2D, @SwiftUI.ViewBuilder content: @escaping () -> Content) where Content : SwiftUI.View
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init<Content>(layerId: Swift.String, featureId: Swift.String? = nil, @SwiftUI.ViewBuilder content: @escaping () -> Content) where Content : SwiftUI.View
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init<Content>(annotatedFeature: MapboxMaps.AnnotatedFeature, @SwiftUI.ViewBuilder content: @escaping () -> Content) where Content : SwiftUI.View
  @_spi(Experimental) @_documentation(visibility: public) public func allowOverlap(_ allowOverlap: Swift.Bool) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func allowHitTesting(_ allowHitTesting: Swift.Bool) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func allowOverlapWithPuck(_ allowOverlapWithPuck: Swift.Bool) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func ignoreCameraPadding(_ ignoreCameraPadding: Swift.Bool) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func visible(_ visible: Swift.Bool) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func selected(_ selected: Swift.Bool = false) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func variableAnchors(_ variableAnchors: [MapboxCoreMaps.ViewAnnotationAnchorConfig]) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onAnchorChanged(action: @escaping (MapboxCoreMaps.ViewAnnotationAnchorConfig) -> Swift.Void) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onVisibilityChanged(action: @escaping (Swift.Bool) -> Swift.Void) -> MapboxMaps.MapViewAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onAnchorCoordinateChanged(action: @escaping (CoreLocation.CLLocationCoordinate2D) -> Swift.Void) -> MapboxMaps.MapViewAnnotation
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.MapViewAnnotation : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct MapViewDebugOptions : Swift.OptionSet, Swift.Hashable {
  public let rawValue: Swift.Int
  public static let tileBorders: MapboxMaps.MapViewDebugOptions
  public static let parseStatus: MapboxMaps.MapViewDebugOptions
  public static let timestamps: MapboxMaps.MapViewDebugOptions
  public static let collision: MapboxMaps.MapViewDebugOptions
  public static let overdraw: MapboxMaps.MapViewDebugOptions
  public static let stencilClip: MapboxMaps.MapViewDebugOptions
  public static let depthBuffer: MapboxMaps.MapViewDebugOptions
  public static let modelBounds: MapboxMaps.MapViewDebugOptions
  public static let light: MapboxMaps.MapViewDebugOptions
  public static let camera: MapboxMaps.MapViewDebugOptions
  public static let padding: MapboxMaps.MapViewDebugOptions
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = MapboxMaps.MapViewDebugOptions
  public typealias Element = MapboxMaps.MapViewDebugOptions
  public typealias RawValue = Swift.Int
}
@_spi(Metrics) public protocol MapViewMetricsReporter : AnyObject {
  @_spi(Metrics) func beforeDisplayLinkCallback(displayLink: QuartzCore.CADisplayLink)
  @_spi(Metrics) func afterDisplayLinkCallback(displayLink: QuartzCore.CADisplayLink)
  @_spi(Metrics) func beforeMetalViewDrawCallback()
  @_spi(Metrics) func afterMetalViewDrawCallback()
}
@_hasMissingDesignatedInitializers final public class MapboxMap : MapboxMaps.StyleManager {
  @available(*, deprecated, message: "Access style APIs directly from MapboxMap instance instead")
  final public var style: MapboxMaps.StyleManager {
    get
  }
  @objc deinit
  final public func triggerRepaint()
  final public func loadStyle(_ styleURI: MapboxMaps.StyleURI, transition: MapboxMaps.TransitionOptions? = nil, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "loadStyle")
  final public func loadStyleURI(_ styleURI: MapboxMaps.StyleURI, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  final public func loadStyle(_ JSON: Swift.String, transition: MapboxMaps.TransitionOptions? = nil, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  @available(*, deprecated, renamed: "loadStyle")
  final public func loadStyleJSON(_ JSON: Swift.String, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  final public var prefetchZoomDelta: Swift.UInt8 {
    get
    set
  }
  final public func reduceMemoryUse()
  final public func setTileCacheBudget(size: MapboxMaps.TileCacheBudgetSize?)
  @available(*, deprecated, message: "Use .setTileCacheBudget(size: TileCacheBudgetSize?) instead.")
  final public func setTileCacheBudget(_ tileCacheBudget: MapboxCoreMaps.TileCacheBudget?)
  final public var shouldRenderWorldCopies: Swift.Bool {
    get
    set
  }
  final public func elevation(at coordinate: CoreLocation.CLLocationCoordinate2D) -> Swift.Double?
  final public func coordinateBounds(for rect: CoreFoundation.CGRect) -> MapboxCoreMaps.CoordinateBounds
  final public func rect(for coordinateBounds: MapboxCoreMaps.CoordinateBounds) -> CoreFoundation.CGRect
  @available(*, deprecated, message: "Use MapView.debugOptions instead.")
  final public var debugOptions: [MapboxCoreMaps.MapDebugOptions] {
    get
    set
  }
  final public var options: MapboxCoreMaps.MapOptions {
    get
  }
  final public func setNorthOrientation(_ northOrientation: MapboxCoreMaps.NorthOrientation)
  final public func setConstrainMode(_ constrainMode: MapboxCoreMaps.ConstrainMode)
  final public func setViewportMode(_ viewportMode: MapboxCoreMaps.ViewportMode)
  @_spi(Experimental) @_documentation(visibility: public) final public func collectPerformanceStatistics(_ options: MapboxCoreMaps.PerformanceStatisticsOptions, callback: @escaping (MapboxCoreMaps.PerformanceStatistics) -> Swift.Void) -> MapboxMaps.AnyCancelable
  @available(*, deprecated, renamed: "camera(for:camera:coordinatesPadding:maxZoom:offset:)", message: "Use camera(for:camera:coordinatesPadding:maxZoom:offset:) instead.")
  final public func camera(for coordinateBounds: MapboxCoreMaps.CoordinateBounds, padding: UIKit.UIEdgeInsets?, bearing: Swift.Double?, pitch: Swift.Double?, maxZoom: Swift.Double?, offset: CoreFoundation.CGPoint?) -> MapboxMaps.CameraOptions
  @available(*, deprecated, renamed: "camera(for:camera:coordinatesPadding:maxZoom:offset:)", message: "Use camera(for:camera:coordinatesPadding:maxZoom:offset:) instead.")
  final public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], padding: UIKit.UIEdgeInsets?, bearing: Swift.Double?, pitch: Swift.Double?) -> MapboxMaps.CameraOptions
  final public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], camera: MapboxMaps.CameraOptions, rect: CoreFoundation.CGRect) -> MapboxMaps.CameraOptions
  final public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], camera: MapboxMaps.CameraOptions, coordinatesPadding: UIKit.UIEdgeInsets?, maxZoom: Swift.Double?, offset: CoreFoundation.CGPoint?) throws -> MapboxMaps.CameraOptions
  @available(*, deprecated, renamed: "camera(for:camera:coordinatesPadding:maxZoom:offset:)", message: "Use camera(for:camera:coordinatesPadding:maxZoom:offset:) method instead.")
  final public func camera(for geometry: MapboxMaps.Geometry, padding: UIKit.UIEdgeInsets, bearing: CoreFoundation.CGFloat?, pitch: CoreFoundation.CGFloat?) -> MapboxMaps.CameraOptions
  final public func coordinateBounds(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBounds
  final public func coordinateBoundsUnwrapped(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBounds
  final public func coordinateBoundsZoom(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBoundsZoom
  final public func coordinateBoundsZoomUnwrapped(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBoundsZoom
  final public func coordinate(for point: CoreFoundation.CGPoint) -> CoreLocation.CLLocationCoordinate2D
  final public func point(for coordinate: CoreLocation.CLLocationCoordinate2D) -> CoreFoundation.CGPoint
  final public func points(for coordinates: [CoreLocation.CLLocationCoordinate2D]) -> [CoreFoundation.CGPoint]
  final public func coordinates(for points: [CoreFoundation.CGPoint]) -> [CoreLocation.CLLocationCoordinate2D]
  final public func coordinateInfo(for point: CoreFoundation.CGPoint) -> MapboxCoreMaps.CoordinateInfo
  final public func coordinatesInfo(for points: [CoreFoundation.CGPoint]) -> [MapboxCoreMaps.CoordinateInfo]
  final public func setCamera(to cameraOptions: MapboxMaps.CameraOptions)
  final public var cameraState: MapboxMaps.CameraState {
    get
  }
  final public var freeCameraOptions: MapboxCoreMaps.FreeCameraOptions {
    get
    set
  }
  final public var cameraBounds: MapboxMaps.CameraBounds {
    get
  }
  final public func setCameraBounds(with options: MapboxMaps.CameraBoundsOptions) throws
  final public func dragCameraOptions(from: CoreFoundation.CGPoint, to: CoreFoundation.CGPoint) -> MapboxMaps.CameraOptions
  final public var isAnimationInProgress: Swift.Bool {
    get
  }
  final public func beginAnimation()
  final public func endAnimation()
  final public var centerAltitudeMode: MapboxCoreMaps.MapCenterAltitudeMode {
    get
    set
  }
  final public var isGestureInProgress: Swift.Bool {
    get
  }
  final public func beginGesture()
  final public func endGesture()
}
extension MapboxMaps.MapboxMap {
  @discardableResult
  final public func queryRenderedFeatures(with shape: [CoreFoundation.CGPoint], options: MapboxCoreMaps.RenderedQueryOptions? = nil, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedRenderedFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func queryRenderedFeatures(with rect: CoreFoundation.CGRect, options: MapboxCoreMaps.RenderedQueryOptions? = nil, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedRenderedFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func queryRenderedFeatures(with point: CoreFoundation.CGPoint, options: MapboxCoreMaps.RenderedQueryOptions? = nil, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedRenderedFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func querySourceFeatures(for sourceId: Swift.String, options: MapboxCoreMaps.SourceQueryOptions, completion: @escaping (Swift.Result<[MapboxCoreMaps.QueriedSourceFeature], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getGeoJsonClusterLeaves(forSourceId sourceId: Swift.String, feature: MapboxMaps.Feature, limit: Swift.UInt64 = 10, offset: Swift.UInt64 = 0, completion: @escaping (Swift.Result<MapboxCoreMaps.FeatureExtensionValue, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getGeoJsonClusterChildren(forSourceId sourceId: Swift.String, feature: MapboxMaps.Feature, completion: @escaping (Swift.Result<MapboxCoreMaps.FeatureExtensionValue, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getGeoJsonClusterExpansionZoom(forSourceId sourceId: Swift.String, feature: MapboxMaps.Feature, completion: @escaping (Swift.Result<MapboxCoreMaps.FeatureExtensionValue, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.MapboxMap {
  final public var onMapLoaded: MapboxMaps.Signal<MapboxCoreMaps.MapLoaded> {
    get
  }
  final public var onMapLoadingError: MapboxMaps.Signal<MapboxCoreMaps.MapLoadingError> {
    get
  }
  final public var onStyleLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleLoaded> {
    get
  }
  final public var onStyleDataLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleDataLoaded> {
    get
  }
  final public var onCameraChanged: MapboxMaps.Signal<MapboxCoreMaps.CameraChanged> {
    get
  }
  final public var onMapIdle: MapboxMaps.Signal<MapboxCoreMaps.MapIdle> {
    get
  }
  final public var onSourceAdded: MapboxMaps.Signal<MapboxCoreMaps.SourceAdded> {
    get
  }
  final public var onSourceRemoved: MapboxMaps.Signal<MapboxCoreMaps.SourceRemoved> {
    get
  }
  final public var onSourceDataLoaded: MapboxMaps.Signal<MapboxCoreMaps.SourceDataLoaded> {
    get
  }
  final public var onStyleImageMissing: MapboxMaps.Signal<MapboxCoreMaps.StyleImageMissing> {
    get
  }
  final public var onStyleImageRemoveUnused: MapboxMaps.Signal<MapboxCoreMaps.StyleImageRemoveUnused> {
    get
  }
  final public var onRenderFrameStarted: MapboxMaps.Signal<MapboxCoreMaps.RenderFrameStarted> {
    get
  }
  final public var onRenderFrameFinished: MapboxMaps.Signal<MapboxCoreMaps.RenderFrameFinished> {
    get
  }
  final public var onResourceRequest: MapboxMaps.Signal<MapboxCoreMaps.ResourceRequest> {
    get
  }
  @_spi(Experimental) @_documentation(visibility: public) final public subscript(eventName: Swift.String) -> MapboxMaps.Signal<MapboxCoreMaps.GenericEvent> {
    get
  }
  @available(*, deprecated, message: "Use mapboxMap.on<eventType>.observeNext instead.")
  @discardableResult
  final public func onNext<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
  @available(*, deprecated, message: "Use mapboxMap.on<eventType>.observe instead.")
  @discardableResult
  final public func onEvery<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.MapboxMap {
  public static func clearData(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
}
extension MapboxMaps.MapboxMap {
  @discardableResult
  final public func setFeatureState(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, featureId: Swift.String, state: [Swift.String : Any], callback: @escaping (Swift.Result<Foundation.NSNull, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func getFeatureState(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, featureId: Swift.String, callback: @escaping (Swift.Result<[Swift.String : Any], any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func removeFeatureState(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, featureId: Swift.String, stateKey: Swift.String? = nil, callback: @escaping (Swift.Result<Foundation.NSNull, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  final public func resetFeatureStates(sourceId: Swift.String, sourceLayerId: Swift.String? = nil, callback: @escaping (Swift.Result<Foundation.NSNull, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.MapboxMap {
  @_spi(Experimental) @_documentation(visibility: public) final public func tileCover(for options: MapboxMaps.TileCoverOptions) -> [MapboxCoreMaps.CanonicalTileID]
}
extension MapboxMaps.MapboxMap {
  @_spi(Experimental) final public func makeRecorder() throws -> MapboxMaps.MapRecorder
}
public enum MapboxMapsOptions {
  public static var baseURL: Foundation.URL {
    get
    set
  }
  public static var dataPath: Foundation.URL {
    get
    set
  }
  public static var assetPath: Foundation.URL {
    get
    set
  }
  public static var tileStoreUsageMode: MapboxCoreMaps.TileStoreUsageMode {
    get
    set
  }
  public static var tileStore: MapboxCommon.TileStore? {
    get
    set
  }
}
@_spi(Experimental) @_documentation(visibility: public) public struct ModelLayer : MapboxMaps.Layer, Swift.Equatable {
  @_spi(Experimental) @_documentation(visibility: public) public var id: Swift.String
  @_spi(Experimental) @_documentation(visibility: public) public let type: MapboxMaps.LayerType
  @_spi(Experimental) @_documentation(visibility: public) public var filter: MapboxMaps.Expression?
  @_spi(Experimental) @_documentation(visibility: public) public var source: Swift.String?
  @_spi(Experimental) @_documentation(visibility: public) public var sourceLayer: Swift.String?
  @_spi(Experimental) @_documentation(visibility: public) public var slot: MapboxMaps.Slot?
  @_spi(Experimental) @_documentation(visibility: public) public var minZoom: Swift.Double?
  @_spi(Experimental) @_documentation(visibility: public) public var maxZoom: Swift.Double?
  @_spi(Experimental) @_documentation(visibility: public) public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  @_spi(Experimental) @_documentation(visibility: public) public var modelId: MapboxMaps.Value<Swift.String>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelAmbientOcclusionIntensity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelAmbientOcclusionIntensityTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelCastShadows: MapboxMaps.Value<Swift.Bool>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelColorTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelColorMixIntensity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelColorMixIntensityTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelCutoffFadeRange: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelFrontCutoff: MapboxMaps.Value<[Swift.Double]>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelHeightBasedEmissiveStrengthMultiplier: MapboxMaps.Value<[Swift.Double]>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelHeightBasedEmissiveStrengthMultiplierTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelOpacity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelOpacityTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelReceiveShadows: MapboxMaps.Value<Swift.Bool>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelRotation: MapboxMaps.Value<[Swift.Double]>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelRotationTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelRoughness: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelRoughnessTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelScale: MapboxMaps.Value<[Swift.Double]>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelScaleTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelScaleMode: MapboxMaps.Value<MapboxMaps.ModelScaleMode>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelTranslation: MapboxMaps.Value<[Swift.Double]>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelTranslationTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var modelType: MapboxMaps.Value<MapboxMaps.ModelType>?
  @_spi(Experimental) @_documentation(visibility: public) public init(id: Swift.String, source: Swift.String)
  @_spi(Experimental) public func encode(to encoder: any Swift.Encoder) throws
  @_spi(Experimental) public init(from decoder: any Swift.Decoder) throws
  @_spi(Experimental) public static func == (a: MapboxMaps.ModelLayer, b: MapboxMaps.ModelLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.ModelLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelId(_ constant: Swift.String) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelId(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelAmbientOcclusionIntensity(_ constant: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelAmbientOcclusionIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelAmbientOcclusionIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelCastShadows(_ constant: Swift.Bool) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelCastShadows(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelColor(_ color: UIKit.UIColor) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelColorMixIntensity(_ constant: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelColorMixIntensityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelColorMixIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelCutoffFadeRange(_ constant: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelCutoffFadeRange(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelFrontCutoff(start: Swift.Double, range: Swift.Double, end: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelFrontCutoff(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelHeightBasedEmissiveStrengthMultiplier(gradientBegin: Swift.Double, gradientEnd: Swift.Double, valueAtBegin: Swift.Double, valueAtEnd: Swift.Double, gradientCurvePower: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelHeightBasedEmissiveStrengthMultiplierTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelHeightBasedEmissiveStrengthMultiplier(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelOpacity(_ constant: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelReceiveShadows(_ constant: Swift.Bool) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelReceiveShadows(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelRotation(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelRotationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelRotation(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelRoughness(_ constant: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelRoughnessTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelRoughness(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelScale(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelScaleTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelScale(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelScaleMode(_ constant: MapboxMaps.ModelScaleMode) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelScaleMode(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelTranslation(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelTranslationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelTranslation(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelType(_ constant: MapboxMaps.ModelType) -> MapboxMaps.ModelLayer
  @_spi(Experimental) @_documentation(visibility: public) public func modelType(_ expression: MapboxMaps.Expression) -> MapboxMaps.ModelLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.ModelLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct Model : Swift.Equatable, Swift.Codable {
  public var id: Swift.String?
  public var uri: Foundation.URL?
  public var position: [Swift.Double]?
  public var orientation: [Swift.Double]?
  public init(id: Swift.String? = nil, uri: Foundation.URL? = nil, position: [Swift.Double]? = nil, orientation: [Swift.Double]? = nil)
  public static func == (a: MapboxMaps.Model, b: MapboxMaps.Model) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.Model : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.StyleImport : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public enum TileRegionError : Foundation.LocalizedError, Swift.Equatable {
  case canceled(Swift.String)
  case doesNotExist(Swift.String)
  case tilesetDescriptor(Swift.String)
  case diskFull(Swift.String)
  case other(Swift.String)
  case tileCountExceeded(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: MapboxMaps.TileRegionError, b: MapboxMaps.TileRegionError) -> Swift.Bool
}
public enum StylePackError : Foundation.LocalizedError, Swift.Equatable {
  case canceled(Swift.String)
  case doesNotExist(Swift.String)
  case diskFull(Swift.String)
  case other(Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
  public static func == (a: MapboxMaps.StylePackError, b: MapboxMaps.StylePackError) -> Swift.Bool
}
extension MapboxCoreMaps.OfflineManager {
  @discardableResult
  public func loadStylePack(for styleURI: MapboxMaps.StyleURI, loadOptions: MapboxCoreMaps.StylePackLoadOptions, progress: MapboxCoreMaps.StylePackLoadProgressCallback? = nil, completion: @escaping (Swift.Result<MapboxCoreMaps.StylePack, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  public func allStylePacks(completion: @escaping (Swift.Result<[MapboxCoreMaps.StylePack], any Swift.Error>) -> Swift.Void)
  public func stylePack(for styleURI: MapboxMaps.StyleURI, completion: @escaping (Swift.Result<MapboxCoreMaps.StylePack, any Swift.Error>) -> Swift.Void)
  public func stylePackMetadata(for styleURI: MapboxMaps.StyleURI, completion: @escaping (Swift.Result<Swift.AnyObject, any Swift.Error>) -> Swift.Void)
  public func removeStylePack(for styleURI: MapboxMaps.StyleURI, completion: ((Swift.Result<MapboxCoreMaps.StylePack, any Swift.Error>) -> Swift.Void)? = nil)
}
@available(*, deprecated)
extension MapboxCoreMaps.OfflineRegion {
  public func invalidate(completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  public func purge(completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  public func setMetadata(_ metadata: Foundation.Data, completion: @escaping (Swift.Result<Swift.Void, any Swift.Error>) -> Swift.Void)
  public func getStatus(completion: @escaping (Swift.Result<MapboxCoreMaps.OfflineRegionStatus, any Swift.Error>) -> Swift.Void)
}
@available(*, deprecated)
extension MapboxCoreMaps.OfflineRegionGeometryDefinition {
  convenience public init(styleURL: Swift.String, geometry: MapboxMaps.Geometry, minZoom: Swift.Double, maxZoom: Swift.Double, pixelRatio: Swift.Float, glyphsRasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode)
  public var geometry: MapboxMaps.Geometry? {
    get
  }
}
@available(*, deprecated)
extension MapboxCoreMaps.OfflineRegionManager {
  public func offlineRegions(completion: @escaping (Swift.Result<[MapboxCoreMaps.OfflineRegion], any Swift.Error>) -> Swift.Void)
  public func createOfflineRegion(for geometryDefinition: MapboxCoreMaps.OfflineRegionGeometryDefinition, completion: @escaping (Swift.Result<MapboxCoreMaps.OfflineRegion, any Swift.Error>) -> Swift.Void)
  public func createOfflineRegion(for tilePyramidDefinition: MapboxCoreMaps.OfflineRegionTilePyramidDefinition, completion: @escaping (Swift.Result<MapboxCoreMaps.OfflineRegion, any Swift.Error>) -> Swift.Void)
  @available(iOS, deprecated, message: "use mergeOfflineDatabase(forPath:completion) instead")
  public func mergeOfflineDatabase(for filePath: Swift.String, completion: @escaping (_ result: Swift.Result<MapboxCoreMaps.OfflineRegion, any Swift.Error>) -> Swift.Void)
  public func mergeOfflineDatabase(forPath filePath: Swift.String, completion: @escaping (Swift.Result<[MapboxCoreMaps.OfflineRegion], any Swift.Error>) -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class OfflineSwitch {
  public static var shared: MapboxMaps.OfflineSwitch
  public var isMapboxStackConnected: Swift.Bool {
    get
    set
  }
  @objc deinit
}
public struct OrnamentOptions : Swift.Equatable {
  public var scaleBar: MapboxMaps.ScaleBarViewOptions
  public var compass: MapboxMaps.CompassViewOptions
  public var logo: MapboxMaps.LogoViewOptions
  public var attributionButton: MapboxMaps.AttributionButtonOptions
  public init(scaleBar: MapboxMaps.ScaleBarViewOptions = .init(), compass: MapboxMaps.CompassViewOptions = .init(), logo: MapboxMaps.LogoViewOptions = .init(), attributionButton: MapboxMaps.AttributionButtonOptions = .init())
  public static func == (a: MapboxMaps.OrnamentOptions, b: MapboxMaps.OrnamentOptions) -> Swift.Bool
}
public struct ScaleBarViewOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  public var visibility: MapboxMaps.OrnamentVisibility
  public var useMetricUnits: Swift.Bool
  public init(position: MapboxMaps.OrnamentPosition = .topLeading, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0), visibility: MapboxMaps.OrnamentVisibility = .adaptive, useMetricUnits: Swift.Bool = Locale.current.usesMetricSystem)
  public static func == (a: MapboxMaps.ScaleBarViewOptions, b: MapboxMaps.ScaleBarViewOptions) -> Swift.Bool
}
public struct CompassViewOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  public var image: UIKit.UIImage?
  public var visibility: MapboxMaps.OrnamentVisibility
  public init(position: MapboxMaps.OrnamentPosition = .topTrailing, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0), image: UIKit.UIImage? = nil, visibility: MapboxMaps.OrnamentVisibility = .adaptive)
  public static func == (a: MapboxMaps.CompassViewOptions, b: MapboxMaps.CompassViewOptions) -> Swift.Bool
}
public struct AttributionButtonOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  @_spi(Restricted) public var visibility: MapboxMaps.OrnamentVisibility
  public init(position: MapboxMaps.OrnamentPosition = .bottomTrailing, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0))
  public static func == (a: MapboxMaps.AttributionButtonOptions, b: MapboxMaps.AttributionButtonOptions) -> Swift.Bool
}
public struct LogoViewOptions : Swift.Equatable {
  public var position: MapboxMaps.OrnamentPosition
  public var margins: CoreFoundation.CGPoint
  @_spi(Restricted) public var visibility: MapboxMaps.OrnamentVisibility
  public init(position: MapboxMaps.OrnamentPosition = .bottomLeading, margins: CoreFoundation.CGPoint = .init(x: 8.0, y: 8.0))
  public static func == (a: MapboxMaps.LogoViewOptions, b: MapboxMaps.LogoViewOptions) -> Swift.Bool
}
public enum OrnamentPosition : Swift.String, Swift.Equatable {
  case topLeft
  case topRight
  case bottomRight
  case bottomLeft
  case topLeading
  case topTrailing
  case bottomLeading
  case bottomTrailing
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum OrnamentVisibility : Swift.String, Swift.Equatable {
  case adaptive
  case hidden
  case visible
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers final public class OrnamentsManager {
  final public var options: MapboxMaps.OrnamentOptions {
    get
    set
  }
  final public var logoView: UIKit.UIView {
    get
  }
  final public var scaleBarView: UIKit.UIView {
    get
  }
  final public var compassView: UIKit.UIView {
    get
  }
  final public var attributionButton: UIKit.UIView {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class OverviewViewportState {
  final public var options: MapboxMaps.OverviewViewportStateOptions {
    get
    set
  }
  @objc deinit
}
extension MapboxMaps.OverviewViewportState : MapboxMaps.ViewportState {
  final public func observeDataSource(with handler: @escaping (MapboxMaps.CameraOptions) -> Swift.Bool) -> any MapboxCommon.Cancelable
  final public func startUpdatingCamera()
  final public func stopUpdatingCamera()
}
public struct OverviewViewportStateOptions : Swift.Equatable {
  public var geometry: MapboxMaps.Geometry
  public var geometryPadding: UIKit.UIEdgeInsets
  public var bearing: CoreLocation.CLLocationDirection?
  public var pitch: CoreFoundation.CGFloat?
  public var padding: UIKit.UIEdgeInsets?
  public var maxZoom: Swift.Double?
  public var offset: CoreFoundation.CGPoint?
  public var animationDuration: Foundation.TimeInterval
  public init(geometry: any Turf.GeometryConvertible, geometryPadding: UIKit.UIEdgeInsets = .zero, bearing: CoreLocation.CLLocationDirection? = 0, pitch: CoreFoundation.CGFloat? = 0, padding: UIKit.UIEdgeInsets? = nil, maxZoom: Swift.Double? = nil, offset: CoreFoundation.CGPoint? = nil, animationDuration: Foundation.TimeInterval = 1)
  public static func == (a: MapboxMaps.OverviewViewportStateOptions, b: MapboxMaps.OverviewViewportStateOptions) -> Swift.Bool
}
@_spi(Experimental) extension MapboxCoreMaps.PerformanceStatisticsOptions {
  @_spi(Experimental) public struct SamplerOptions : Swift.OptionSet, Swift.Hashable {
    @_spi(Experimental) public static let cumulative: MapboxCoreMaps.PerformanceStatisticsOptions.SamplerOptions
    @_spi(Experimental) public static let perFrame: MapboxCoreMaps.PerformanceStatisticsOptions.SamplerOptions
    @_spi(Experimental) public let rawValue: Swift.Int
    @_spi(Experimental) public init(rawValue: Swift.Int)
    @_spi(Experimental) public typealias ArrayLiteralElement = MapboxCoreMaps.PerformanceStatisticsOptions.SamplerOptions
    @_spi(Experimental) public typealias Element = MapboxCoreMaps.PerformanceStatisticsOptions.SamplerOptions
    @_spi(Experimental) public typealias RawValue = Swift.Int
  }
  @_spi(Experimental) public var samplerOptions: MapboxCoreMaps.PerformanceStatisticsOptions.SamplerOptions {
    @_spi(Experimental) get
  }
  @_spi(Experimental) convenience public init(_ samplerOptions: MapboxCoreMaps.PerformanceStatisticsOptions.SamplerOptions, samplingDurationMillis: Swift.Double)
  @_spi(Experimental) convenience public init(_ samplerOptions: MapboxCoreMaps.PerformanceStatisticsOptions.SamplerOptions)
}
extension MapboxCoreMaps.CumulativeRenderingStatistics {
  public var drawCalls: Swift.UInt? {
    get
  }
  public var textureBytes: Swift.UInt? {
    get
  }
  public var vertexBytes: Swift.UInt? {
    get
  }
}
public struct PointAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var point: Turf.Point
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.PointAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.PointAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.PointAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, point: Turf.Point, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public init(id: Swift.String = UUID().uuidString, coordinate: CoreLocation.CLLocationCoordinate2D, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var iconAnchor: MapboxMaps.IconAnchor?
  public var iconImage: Swift.String?
  public var iconOffset: [Swift.Double]?
  public var iconRotate: Swift.Double?
  public var iconSize: Swift.Double?
  public var iconTextFit: MapboxMaps.IconTextFit?
  public var iconTextFitPadding: [Swift.Double]?
  public var symbolSortKey: Swift.Double?
  public var textAnchor: MapboxMaps.TextAnchor?
  public var textField: Swift.String?
  public var textJustify: MapboxMaps.TextJustify?
  public var textLetterSpacing: Swift.Double?
  public var textLineHeight: Swift.Double?
  public var textMaxWidth: Swift.Double?
  public var textOffset: [Swift.Double]?
  public var textRadialOffset: Swift.Double?
  public var textRotate: Swift.Double?
  public var textSize: Swift.Double?
  public var textTransform: MapboxMaps.TextTransform?
  public var iconColor: MapboxMaps.StyleColor?
  public var iconEmissiveStrength: Swift.Double?
  public var iconHaloBlur: Swift.Double?
  public var iconHaloColor: MapboxMaps.StyleColor?
  public var iconHaloWidth: Swift.Double?
  public var iconImageCrossFade: Swift.Double?
  public var iconOpacity: Swift.Double?
  public var textColor: MapboxMaps.StyleColor?
  public var textEmissiveStrength: Swift.Double?
  public var textHaloBlur: Swift.Double?
  public var textHaloColor: MapboxMaps.StyleColor?
  public var textHaloWidth: Swift.Double?
  public var textOpacity: Swift.Double?
  public var image: MapboxMaps.PointAnnotation.Image? {
    get
    set
  }
  public static func == (a: MapboxMaps.PointAnnotation, b: MapboxMaps.PointAnnotation) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.PointAnnotation {
  @_spi(Experimental) @_documentation(visibility: public) public func iconAnchor(_ newValue: MapboxMaps.IconAnchor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconImage(_ newValue: Swift.String) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconOffset(x: Swift.Double, y: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconRotate(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconSize(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconTextFit(_ newValue: MapboxMaps.IconTextFit) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconTextFitPadding(_ padding: UIKit.UIEdgeInsets) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func symbolSortKey(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textAnchor(_ newValue: MapboxMaps.TextAnchor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textField(_ newValue: Swift.String) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textJustify(_ newValue: MapboxMaps.TextJustify) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textLetterSpacing(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textLineHeight(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textMaxWidth(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textOffset(x: Swift.Double, y: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textRadialOffset(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textRotate(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textSize(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textTransform(_ newValue: MapboxMaps.TextTransform) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconColor(_ color: UIKit.UIColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconEmissiveStrength(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloBlur(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloColor(_ color: UIKit.UIColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloWidth(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconImageCrossFade(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func iconOpacity(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textColor(_ color: UIKit.UIColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textEmissiveStrength(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloBlur(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloColor(_ color: UIKit.UIColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloWidth(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func textOpacity(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func image(_ image: MapboxMaps.PointAnnotation.Image?) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) public func image(named name: Swift.String) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.PointAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.PointAnnotation
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.PointAnnotation : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct PointAnnotationGroup<Data, ID> where Data : Swift.RandomAccessCollection, ID : Swift.Hashable {
  @_spi(Experimental) @_documentation(visibility: public) public init(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, content: @escaping (Data.Element) -> MapboxMaps.PointAnnotation)
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init(_ data: Data, content: @escaping (Data.Element) -> MapboxMaps.PointAnnotation) where ID == Data.Element.ID, Data.Element : Swift.Identifiable
  @_spi(Experimental) @_documentation(visibility: public) public init(@MapboxMaps.ArrayBuilder<MapboxMaps.PointAnnotation> content: @escaping () -> [MapboxMaps.PointAnnotation?]) where Data == [(Swift.Int, MapboxMaps.PointAnnotation)], ID == Swift.Int
  @_spi(Experimental) @_documentation(visibility: public) public func iconAllowOverlap(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconIgnorePlacement(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconKeepUpright(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconOptional(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconPadding(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconPitchAlignment(_ newValue: MapboxMaps.IconPitchAlignment) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconRotationAlignment(_ newValue: MapboxMaps.IconRotationAlignment) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func symbolAvoidEdges(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func symbolPlacement(_ newValue: MapboxMaps.SymbolPlacement) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func symbolSpacing(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func symbolZElevate(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func symbolZOrder(_ newValue: MapboxMaps.SymbolZOrder) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textAllowOverlap(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textFont(_ newValue: [Swift.String]) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textIgnorePlacement(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textKeepUpright(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textMaxAngle(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textOptional(_ newValue: Swift.Bool) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textPadding(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textPitchAlignment(_ newValue: MapboxMaps.TextPitchAlignment) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textRotationAlignment(_ newValue: MapboxMaps.TextRotationAlignment) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textVariableAnchor(_ newValue: [MapboxMaps.TextAnchor]) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textWritingMode(_ newValue: [MapboxMaps.TextWritingMode]) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconColorSaturation(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconOcclusionOpacity(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconTranslate(_ newValue: [Swift.Double]) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func iconTranslateAnchor(_ newValue: MapboxMaps.IconTranslateAnchor) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textOcclusionOpacity(_ newValue: Swift.Double) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textTranslate(_ newValue: [Swift.Double]) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func textTranslateAnchor(_ newValue: MapboxMaps.TextTranslateAnchor) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: Swift.String) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func clusterOptions(_ newValue: MapboxMaps.ClusterOptions) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func onClusterTapGesture(perform action: @escaping (MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func onClusterLongPressGesture(perform action: @escaping (MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void) -> MapboxMaps.PointAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func layerId(_ layerId: Swift.String) -> MapboxMaps.PointAnnotationGroup<Data, ID>
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.PointAnnotationGroup : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_hasMissingDesignatedInitializers public class PointAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.PointAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var onClusterTap: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)?
  public var onClusterLongPress: ((MapboxMaps.AnnotationClusterGestureContext) -> Swift.Void)?
  public var iconAllowOverlap: Swift.Bool? {
    get
    set
  }
  public var iconIgnorePlacement: Swift.Bool? {
    get
    set
  }
  public var iconKeepUpright: Swift.Bool? {
    get
    set
  }
  public var iconOptional: Swift.Bool? {
    get
    set
  }
  public var iconPadding: Swift.Double? {
    get
    set
  }
  public var iconPitchAlignment: MapboxMaps.IconPitchAlignment? {
    get
    set
  }
  public var iconRotationAlignment: MapboxMaps.IconRotationAlignment? {
    get
    set
  }
  public var symbolAvoidEdges: Swift.Bool? {
    get
    set
  }
  public var symbolPlacement: MapboxMaps.SymbolPlacement? {
    get
    set
  }
  public var symbolSpacing: Swift.Double? {
    get
    set
  }
  public var symbolZElevate: Swift.Bool? {
    get
    set
  }
  public var symbolZOrder: MapboxMaps.SymbolZOrder? {
    get
    set
  }
  public var textAllowOverlap: Swift.Bool? {
    get
    set
  }
  public var textFont: [Swift.String]? {
    get
    set
  }
  public var textIgnorePlacement: Swift.Bool? {
    get
    set
  }
  public var textKeepUpright: Swift.Bool? {
    get
    set
  }
  public var textMaxAngle: Swift.Double? {
    get
    set
  }
  public var textOptional: Swift.Bool? {
    get
    set
  }
  public var textPadding: Swift.Double? {
    get
    set
  }
  public var textPitchAlignment: MapboxMaps.TextPitchAlignment? {
    get
    set
  }
  public var textRotationAlignment: MapboxMaps.TextRotationAlignment? {
    get
    set
  }
  public var textVariableAnchor: [MapboxMaps.TextAnchor]? {
    get
    set
  }
  public var textWritingMode: [MapboxMaps.TextWritingMode]? {
    get
    set
  }
  public var iconColorSaturation: Swift.Double? {
    get
    set
  }
  public var iconOcclusionOpacity: Swift.Double? {
    get
    set
  }
  public var iconTranslate: [Swift.Double]? {
    get
    set
  }
  public var iconTranslateAnchor: MapboxMaps.IconTranslateAnchor? {
    get
    set
  }
  public var textOcclusionOpacity: Swift.Double? {
    get
    set
  }
  public var textTranslate: [Swift.Double]? {
    get
    set
  }
  public var textTranslateAnchor: MapboxMaps.TextTranslateAnchor? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @available(*, deprecated, message: "icon-text-fit property is now data driven, use `PointAnnotation.iconTextFit` instead.")
  public var iconTextFit: MapboxMaps.IconTextFit? {
    get
    set
  }
  @available(*, deprecated, message: "icon-text-fit-padding property is now data driven, use `PointAnnotation.iconTextFitPadding` instead.")
  public var iconTextFitPadding: [Swift.Double]? {
    get
    set
  }
  @objc deinit
}
@_documentation(visibility: internal) public typealias Polygon = Turf.Polygon
public struct PolygonAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var polygon: MapboxMaps.Polygon
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.PolygonAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.PolygonAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.PolygonAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, polygon: MapboxMaps.Polygon, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var fillSortKey: Swift.Double?
  public var fillColor: MapboxMaps.StyleColor?
  public var fillOpacity: Swift.Double?
  public var fillOutlineColor: MapboxMaps.StyleColor?
  public var fillPattern: Swift.String?
  public static func == (a: MapboxMaps.PolygonAnnotation, b: MapboxMaps.PolygonAnnotation) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.PolygonAnnotation {
  @_spi(Experimental) @_documentation(visibility: public) public func fillSortKey(_ newValue: Swift.Double) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func fillColor(_ color: UIKit.UIColor) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func fillColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func fillOpacity(_ newValue: Swift.Double) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func fillOutlineColor(_ color: UIKit.UIColor) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func fillOutlineColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func fillPattern(_ newValue: Swift.String) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.PolygonAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.PolygonAnnotation
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.PolygonAnnotation : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct PolygonAnnotationGroup<Data, ID> where Data : Swift.RandomAccessCollection, ID : Swift.Hashable {
  @_spi(Experimental) @_documentation(visibility: public) public init(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, content: @escaping (Data.Element) -> MapboxMaps.PolygonAnnotation)
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init(_ data: Data, content: @escaping (Data.Element) -> MapboxMaps.PolygonAnnotation) where ID == Data.Element.ID, Data.Element : Swift.Identifiable
  @_spi(Experimental) @_documentation(visibility: public) public init(@MapboxMaps.ArrayBuilder<MapboxMaps.PolygonAnnotation> content: @escaping () -> [MapboxMaps.PolygonAnnotation?]) where Data == [(Swift.Int, MapboxMaps.PolygonAnnotation)], ID == Swift.Int
  @_spi(Experimental) @_documentation(visibility: public) public func fillAntialias(_ newValue: Swift.Bool) -> MapboxMaps.PolygonAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func fillEmissiveStrength(_ newValue: Swift.Double) -> MapboxMaps.PolygonAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func fillTranslate(_ newValue: [Swift.Double]) -> MapboxMaps.PolygonAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func fillTranslateAnchor(_ newValue: MapboxMaps.FillTranslateAnchor) -> MapboxMaps.PolygonAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: Swift.String) -> MapboxMaps.PolygonAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func layerId(_ layerId: Swift.String) -> MapboxMaps.PolygonAnnotationGroup<Data, ID>
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.PolygonAnnotationGroup : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_hasMissingDesignatedInitializers public class PolygonAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.PolygonAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var fillAntialias: Swift.Bool? {
    get
    set
  }
  public var fillEmissiveStrength: Swift.Double? {
    get
    set
  }
  public var fillTranslate: [Swift.Double]? {
    get
    set
  }
  public var fillTranslateAnchor: MapboxMaps.FillTranslateAnchor? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @objc deinit
}
public struct PolylineAnnotation : MapboxMaps.Annotation, Swift.Equatable {
  public var id: Swift.String {
    get
  }
  public var geometry: MapboxMaps.Geometry {
    get
  }
  public var lineString: Turf.LineString
  public var isSelected: Swift.Bool
  public var isDraggable: Swift.Bool
  public var tapHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var longPressHandler: ((MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragBeginHandler: ((inout MapboxMaps.PolylineAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Bool)? {
    get
    set
  }
  public var dragChangeHandler: ((inout MapboxMaps.PolylineAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var dragEndHandler: ((inout MapboxMaps.PolylineAnnotation, MapboxMaps.MapContentGestureContext) -> Swift.Void)? {
    get
    set
  }
  public var customData: Turf.JSONObject
  @available(*, deprecated, message: "Use customData instead.")
  public var userInfo: [Swift.String : Any]? {
    get
    set
  }
  public init(id: Swift.String = UUID().uuidString, lineString: Turf.LineString, isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public init(id: Swift.String = UUID().uuidString, lineCoordinates: [CoreLocation.CLLocationCoordinate2D], isSelected: Swift.Bool = false, isDraggable: Swift.Bool = false)
  public var lineJoin: MapboxMaps.LineJoin?
  public var lineSortKey: Swift.Double?
  public var lineZOffset: Swift.Double?
  public var lineBlur: Swift.Double?
  public var lineBorderColor: MapboxMaps.StyleColor?
  public var lineBorderWidth: Swift.Double?
  public var lineColor: MapboxMaps.StyleColor?
  public var lineGapWidth: Swift.Double?
  public var lineOffset: Swift.Double?
  public var lineOpacity: Swift.Double?
  public var linePattern: Swift.String?
  public var lineWidth: Swift.Double?
  public static func == (a: MapboxMaps.PolylineAnnotation, b: MapboxMaps.PolylineAnnotation) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.PolylineAnnotation {
  @_spi(Experimental) @_documentation(visibility: public) public func lineJoin(_ newValue: MapboxMaps.LineJoin) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineSortKey(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineZOffset(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineBlur(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderColor(_ color: UIKit.UIColor) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineBorderWidth(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineColor(_ color: UIKit.UIColor) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineColor(_ newValue: MapboxMaps.StyleColor) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineGapWidth(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineOffset(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineOpacity(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func linePattern(_ newValue: Swift.String) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func lineWidth(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onTapGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping (MapboxMaps.MapContentGestureContext) -> Swift.Bool) -> MapboxMaps.PolylineAnnotation
  @_spi(Experimental) @_documentation(visibility: public) public func onLongPressGesture(handler: @escaping () -> Swift.Void) -> MapboxMaps.PolylineAnnotation
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.PolylineAnnotation : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct PolylineAnnotationGroup<Data, ID> where Data : Swift.RandomAccessCollection, ID : Swift.Hashable {
  @_spi(Experimental) @_documentation(visibility: public) public init(_ data: Data, id: Swift.KeyPath<Data.Element, ID>, content: @escaping (Data.Element) -> MapboxMaps.PolylineAnnotation)
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public init(_ data: Data, content: @escaping (Data.Element) -> MapboxMaps.PolylineAnnotation) where ID == Data.Element.ID, Data.Element : Swift.Identifiable
  @_spi(Experimental) @_documentation(visibility: public) public init(@MapboxMaps.ArrayBuilder<MapboxMaps.PolylineAnnotation> content: @escaping () -> [MapboxMaps.PolylineAnnotation?]) where Data == [(Swift.Int, MapboxMaps.PolylineAnnotation)], ID == Swift.Int
  @_spi(Experimental) @_documentation(visibility: public) public func lineCap(_ newValue: MapboxMaps.LineCap) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineMiterLimit(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineRoundLimit(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineDasharray(_ newValue: [Swift.Double]) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineDepthOcclusionFactor(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineEmissiveStrength(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineOcclusionOpacity(_ newValue: Swift.Double) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineTranslate(_ newValue: [Swift.Double]) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineTranslateAnchor(_ newValue: MapboxMaps.LineTranslateAnchor) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func lineTrimOffset(_ newValue: [Swift.Double]) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: Swift.String) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
  @_spi(Experimental) @_documentation(visibility: public) public func layerId(_ layerId: Swift.String) -> MapboxMaps.PolylineAnnotationGroup<Data, ID>
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.PolylineAnnotationGroup : MapboxMaps.MapContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_hasMissingDesignatedInitializers public class PolylineAnnotationManager {
  public var sourceId: Swift.String {
    get
  }
  public var layerId: Swift.String {
    get
  }
  final public let id: Swift.String
  public var annotations: [MapboxMaps.PolylineAnnotation] {
    get
    set
  }
  @available(*, deprecated, message: "Use tapHandler property of Annotation")
  weak public var delegate: (any MapboxMaps.AnnotationInteractionDelegate)? {
    get
    set
  }
  public var lineCap: MapboxMaps.LineCap? {
    get
    set
  }
  public var lineMiterLimit: Swift.Double? {
    get
    set
  }
  public var lineRoundLimit: Swift.Double? {
    get
    set
  }
  public var lineDasharray: [Swift.Double]? {
    get
    set
  }
  public var lineDepthOcclusionFactor: Swift.Double? {
    get
    set
  }
  public var lineEmissiveStrength: Swift.Double? {
    get
    set
  }
  public var lineOcclusionOpacity: Swift.Double? {
    get
    set
  }
  public var lineTranslate: [Swift.Double]? {
    get
    set
  }
  public var lineTranslateAnchor: MapboxMaps.LineTranslateAnchor? {
    get
    set
  }
  public var lineTrimOffset: [Swift.Double]? {
    get
    set
  }
  public var slot: Swift.String? {
    get
    set
  }
  @objc deinit
}
@_spi(Experimental) extension Swift.Never : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public var body: Swift.Never {
    @_spi(Experimental) get
  }
}
@_spi(Experimental) extension Swift.Never : MapboxMaps.MapContent {
  @_spi(Experimental) public var content: Swift.Never {
    @_spi(Experimental) get
  }
}
@_hasMissingDesignatedInitializers final public class Projection {
  public static let latitudeMax: CoreLocation.CLLocationDegrees
  public static let latitudeMin: Swift.Double
  public static let latitudeRange: (Swift.ClosedRange<CoreLocation.CLLocationDegrees>)
  public static func metersPerPoint(for latitude: CoreLocation.CLLocationDegrees, zoom: CoreFoundation.CGFloat) -> Swift.Double
  public static func projectedMeters(for coordinate: CoreLocation.CLLocationCoordinate2D) -> MapboxCoreMaps.ProjectedMeters
  public static func coordinate(for projectedMeters: MapboxCoreMaps.ProjectedMeters) -> CoreLocation.CLLocationCoordinate2D
  public static func project(_ coordinate: CoreLocation.CLLocationCoordinate2D, zoomScale: CoreFoundation.CGFloat) -> MapboxCoreMaps.MercatorCoordinate
  public static func unproject(_ mercatorCoordinate: MapboxCoreMaps.MercatorCoordinate, zoomScale: CoreFoundation.CGFloat) -> CoreLocation.CLLocationCoordinate2D
  @objc deinit
}
public enum PromoteId : Swift.Equatable, Swift.Codable {
  case string(Swift.String)
  case object([Swift.String : Swift.String])
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: MapboxMaps.PromoteId, b: MapboxMaps.PromoteId) -> Swift.Bool
}
public enum Visibility : Swift.String, Swift.Codable {
  case visible
  case none
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct LineCap : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let butt: MapboxMaps.LineCap
  public static let round: MapboxMaps.LineCap
  public static let square: MapboxMaps.LineCap
  public typealias RawValue = Swift.String
}
public struct LineJoin : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let bevel: MapboxMaps.LineJoin
  public static let round: MapboxMaps.LineJoin
  public static let miter: MapboxMaps.LineJoin
  public static let none: MapboxMaps.LineJoin
  public typealias RawValue = Swift.String
}
public struct IconAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let center: MapboxMaps.IconAnchor
  public static let left: MapboxMaps.IconAnchor
  public static let right: MapboxMaps.IconAnchor
  public static let top: MapboxMaps.IconAnchor
  public static let bottom: MapboxMaps.IconAnchor
  public static let topLeft: MapboxMaps.IconAnchor
  public static let topRight: MapboxMaps.IconAnchor
  public static let bottomLeft: MapboxMaps.IconAnchor
  public static let bottomRight: MapboxMaps.IconAnchor
  public typealias RawValue = Swift.String
}
public struct IconPitchAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.IconPitchAlignment
  public static let viewport: MapboxMaps.IconPitchAlignment
  public static let auto: MapboxMaps.IconPitchAlignment
  public typealias RawValue = Swift.String
}
public struct IconRotationAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.IconRotationAlignment
  public static let viewport: MapboxMaps.IconRotationAlignment
  public static let auto: MapboxMaps.IconRotationAlignment
  public typealias RawValue = Swift.String
}
public struct IconTextFit : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let none: MapboxMaps.IconTextFit
  public static let width: MapboxMaps.IconTextFit
  public static let height: MapboxMaps.IconTextFit
  public static let both: MapboxMaps.IconTextFit
  public typealias RawValue = Swift.String
}
public struct SymbolPlacement : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let point: MapboxMaps.SymbolPlacement
  public static let line: MapboxMaps.SymbolPlacement
  public static let lineCenter: MapboxMaps.SymbolPlacement
  public typealias RawValue = Swift.String
}
public struct SymbolZOrder : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let auto: MapboxMaps.SymbolZOrder
  public static let viewportY: MapboxMaps.SymbolZOrder
  public static let source: MapboxMaps.SymbolZOrder
  public typealias RawValue = Swift.String
}
public struct TextAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let center: MapboxMaps.TextAnchor
  public static let left: MapboxMaps.TextAnchor
  public static let right: MapboxMaps.TextAnchor
  public static let top: MapboxMaps.TextAnchor
  public static let bottom: MapboxMaps.TextAnchor
  public static let topLeft: MapboxMaps.TextAnchor
  public static let topRight: MapboxMaps.TextAnchor
  public static let bottomLeft: MapboxMaps.TextAnchor
  public static let bottomRight: MapboxMaps.TextAnchor
  public typealias RawValue = Swift.String
}
public struct TextJustify : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let auto: MapboxMaps.TextJustify
  public static let left: MapboxMaps.TextJustify
  public static let center: MapboxMaps.TextJustify
  public static let right: MapboxMaps.TextJustify
  public typealias RawValue = Swift.String
}
public struct TextPitchAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.TextPitchAlignment
  public static let viewport: MapboxMaps.TextPitchAlignment
  public static let auto: MapboxMaps.TextPitchAlignment
  public typealias RawValue = Swift.String
}
public struct TextRotationAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.TextRotationAlignment
  public static let viewport: MapboxMaps.TextRotationAlignment
  public static let auto: MapboxMaps.TextRotationAlignment
  public typealias RawValue = Swift.String
}
public struct TextTransform : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let none: MapboxMaps.TextTransform
  public static let uppercase: MapboxMaps.TextTransform
  public static let lowercase: MapboxMaps.TextTransform
  public typealias RawValue = Swift.String
}
public struct FillTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.FillTranslateAnchor
  public static let viewport: MapboxMaps.FillTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct LineTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.LineTranslateAnchor
  public static let viewport: MapboxMaps.LineTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct IconTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.IconTranslateAnchor
  public static let viewport: MapboxMaps.IconTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct TextTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.TextTranslateAnchor
  public static let viewport: MapboxMaps.TextTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct CirclePitchAlignment : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.CirclePitchAlignment
  public static let viewport: MapboxMaps.CirclePitchAlignment
  public typealias RawValue = Swift.String
}
public struct CirclePitchScale : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.CirclePitchScale
  public static let viewport: MapboxMaps.CirclePitchScale
  public typealias RawValue = Swift.String
}
public struct CircleTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.CircleTranslateAnchor
  public static let viewport: MapboxMaps.CircleTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct FillExtrusionTranslateAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.FillExtrusionTranslateAnchor
  public static let viewport: MapboxMaps.FillExtrusionTranslateAnchor
  public typealias RawValue = Swift.String
}
public struct RasterResampling : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let linear: MapboxMaps.RasterResampling
  public static let nearest: MapboxMaps.RasterResampling
  public typealias RawValue = Swift.String
}
public struct HillshadeIlluminationAnchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.HillshadeIlluminationAnchor
  public static let viewport: MapboxMaps.HillshadeIlluminationAnchor
  public typealias RawValue = Swift.String
}
public struct ModelScaleMode : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.ModelScaleMode
  public static let viewport: MapboxMaps.ModelScaleMode
  public typealias RawValue = Swift.String
}
public struct ModelType : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let common3d: MapboxMaps.ModelType
  public static let locationIndicator: MapboxMaps.ModelType
  public typealias RawValue = Swift.String
}
public struct SkyType : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let gradient: MapboxMaps.SkyType
  public static let atmosphere: MapboxMaps.SkyType
  public typealias RawValue = Swift.String
}
public struct Anchor : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let map: MapboxMaps.Anchor
  public static let viewport: MapboxMaps.Anchor
  public typealias RawValue = Swift.String
}
public struct StyleProjectionName : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let mercator: MapboxMaps.StyleProjectionName
  public static let globe: MapboxMaps.StyleProjectionName
  public typealias RawValue = Swift.String
}
public struct TextWritingMode : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let horizontal: MapboxMaps.TextWritingMode
  public static let vertical: MapboxMaps.TextWritingMode
  public typealias RawValue = Swift.String
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct Puck2D : MapboxMaps.MapContent {
  @_spi(Experimental) @_documentation(visibility: public) public init(bearing: MapboxMaps.PuckBearing? = nil)
  @_spi(Experimental) @_documentation(visibility: public) public func opacity(_ opacity: Swift.Double) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func topImage(_ topImage: UIKit.UIImage?) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func bearingImage(_ bearingImage: UIKit.UIImage?) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func shadowImage(_ shadowImage: UIKit.UIImage?) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func scale(_ scale: Swift.Double) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func scale(_ scale: MapboxMaps.Expression) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func pulsing(_ pulsing: MapboxMaps.Puck2DConfiguration.Pulsing?) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func showsAccuracyRing(_ showsAccuracyRing: Swift.Bool) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRingColor(_ accuracyRingColor: UIKit.UIColor) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func accuracyRingBorderColor(_ accuracyRingBorderColor: UIKit.UIColor) -> MapboxMaps.Puck2D
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ slot: MapboxMaps.Slot?) -> MapboxMaps.Puck2D
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct Puck3D : MapboxMaps.MapContent {
  @_spi(Experimental) @_documentation(visibility: public) public init(model: MapboxMaps.Model, bearing: MapboxMaps.PuckBearing?)
  @_spi(Experimental) @_documentation(visibility: public) public func modelScale(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelRotation(x: Swift.Double, y: Swift.Double, z: Swift.Double) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelOpacity(_ modelOpacity: Swift.Double) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelCastShadows(_ modelCastShadows: Swift.Bool) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelReceiveShadows(_ modelReceiveShadows: Swift.Bool) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelScaleMode(_ modelScaleMode: MapboxMaps.ModelScaleMode) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelEmissiveStrength(_ modelEmissiveStrength: Swift.Double) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelScale(_ modelScale: MapboxMaps.Expression) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelRotation(_ modelRotation: MapboxMaps.Expression) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelOpacity(_ modelOpacity: MapboxMaps.Expression) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelCastShadows(_ modelCastShadows: MapboxMaps.Expression) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelReceiveShadows(_ modelReceiveShadows: MapboxMaps.Expression) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelScaleMode(_ modelScaleMode: MapboxMaps.Expression) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func modelEmissiveStrength(_ modelEmissiveStrength: MapboxMaps.Expression) -> MapboxMaps.Puck3D
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ slot: MapboxMaps.Slot?) -> MapboxMaps.Puck3D
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct PuckRenderingData : Swift.Equatable {
  public var location: MapboxCommon.Location
  public var heading: MapboxMaps.Heading?
  public init(location: MapboxCommon.Location, heading: MapboxMaps.Heading? = nil)
  public static func == (a: MapboxMaps.PuckRenderingData, b: MapboxMaps.PuckRenderingData) -> Swift.Bool
}
public enum PuckType : Swift.Equatable {
  case puck2D(_: MapboxMaps.Puck2DConfiguration = Puck2DConfiguration())
  case puck3D(MapboxMaps.Puck3DConfiguration)
  public static func == (a: MapboxMaps.PuckType, b: MapboxMaps.PuckType) -> Swift.Bool
}
public struct Puck2DConfiguration : Swift.Equatable {
  public struct Pulsing : Swift.Equatable {
    public static let `default`: MapboxMaps.Puck2DConfiguration.Pulsing
    public enum Radius : Swift.Equatable {
      case constant(Swift.Double)
      case accuracy
      public static func == (a: MapboxMaps.Puck2DConfiguration.Pulsing.Radius, b: MapboxMaps.Puck2DConfiguration.Pulsing.Radius) -> Swift.Bool
    }
    public var isEnabled: Swift.Bool
    public var color: UIKit.UIColor
    public var radius: MapboxMaps.Puck2DConfiguration.Pulsing.Radius
    public init(color: UIKit.UIColor = UIColor(red: 0.29, green: 0.565, blue: 0.886, alpha: 1), radius: MapboxMaps.Puck2DConfiguration.Pulsing.Radius = .constant(30))
    public static func == (a: MapboxMaps.Puck2DConfiguration.Pulsing, b: MapboxMaps.Puck2DConfiguration.Pulsing) -> Swift.Bool
  }
  public var opacity: Swift.Double
  public var topImage: UIKit.UIImage?
  public var bearingImage: UIKit.UIImage?
  public var shadowImage: UIKit.UIImage?
  public var scale: MapboxMaps.Value<Swift.Double>?
  public var pulsing: MapboxMaps.Puck2DConfiguration.Pulsing?
  public var showsAccuracyRing: Swift.Bool
  public var accuracyRingColor: UIKit.UIColor
  public var accuracyRingBorderColor: UIKit.UIColor
  public var slot: MapboxMaps.Slot?
  public var layerPosition: MapboxMaps.LayerPosition?
  public init(topImage: UIKit.UIImage? = nil, bearingImage: UIKit.UIImage? = nil, shadowImage: UIKit.UIImage? = nil, scale: MapboxMaps.Value<Swift.Double>? = nil, pulsing: MapboxMaps.Puck2DConfiguration.Pulsing? = nil, showsAccuracyRing: Swift.Bool = false, opacity: Swift.Double = 1)
  public init(topImage: UIKit.UIImage? = nil, bearingImage: UIKit.UIImage? = nil, shadowImage: UIKit.UIImage? = nil, scale: MapboxMaps.Value<Swift.Double>? = nil, showsAccuracyRing: Swift.Bool = false, accuracyRingColor: UIKit.UIColor = UIColor(red: 0.537, green: 0.812, blue: 0.941, alpha: 0.3), accuracyRingBorderColor: UIKit.UIColor = UIColor(red: 0.537, green: 0.812, blue: 0.941, alpha: 0.3), opacity: Swift.Double = 1, layerPosition: MapboxMaps.LayerPosition? = nil)
  public static func makeDefault(showBearing: Swift.Bool = false) -> MapboxMaps.Puck2DConfiguration
  public static func == (a: MapboxMaps.Puck2DConfiguration, b: MapboxMaps.Puck2DConfiguration) -> Swift.Bool
}
public struct Puck3DConfiguration : Swift.Equatable {
  public var model: MapboxMaps.Model
  public var modelScale: MapboxMaps.Value<[Swift.Double]>?
  public var modelRotation: MapboxMaps.Value<[Swift.Double]>?
  public var modelOpacity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelCastShadows: MapboxMaps.Value<Swift.Bool>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelReceiveShadows: MapboxMaps.Value<Swift.Bool>?
  @_spi(Experimental) @_documentation(visibility: public) public var modelScaleMode: MapboxMaps.Value<MapboxMaps.ModelScaleMode>?
  public var modelEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var slot: MapboxMaps.Slot?
  public var layerPosition: MapboxMaps.LayerPosition?
  public init(model: MapboxMaps.Model, modelScale: MapboxMaps.Value<[Swift.Double]>? = nil, modelRotation: MapboxMaps.Value<[Swift.Double]>? = nil, modelOpacity: MapboxMaps.Value<Swift.Double>? = nil, layerPosition: MapboxMaps.LayerPosition? = nil)
  @_spi(Experimental) @_documentation(visibility: public) public init(model: MapboxMaps.Model, modelScale: MapboxMaps.Value<[Swift.Double]>? = nil, modelRotation: MapboxMaps.Value<[Swift.Double]>? = nil, modelOpacity: MapboxMaps.Value<Swift.Double>? = nil, modelCastShadows: MapboxMaps.Value<Swift.Bool>? = nil, modelReceiveShadows: MapboxMaps.Value<Swift.Bool>? = nil, modelScaleMode: MapboxMaps.Value<MapboxMaps.ModelScaleMode>? = nil, modelEmissiveStrength: MapboxMaps.Value<Swift.Double> = .constant(1), layerPosition: MapboxMaps.LayerPosition? = nil)
  public static func == (a: MapboxMaps.Puck3DConfiguration, b: MapboxMaps.Puck3DConfiguration) -> Swift.Bool
}
extension MapboxCoreMaps.QueriedFeature {
  public var feature: MapboxMaps.Feature {
    get
  }
}
@_spi(Experimental) extension MapboxMaps.RasterArraySource {
  @_spi(Experimental) @_documentation(visibility: public) public struct RasterDataLayer : Swift.Equatable, Swift.Codable {
    @_spi(Experimental) @_documentation(visibility: public) public let layerId: Swift.String
    @_spi(Experimental) @_documentation(visibility: public) public let bands: [Swift.String]
    @_spi(Experimental) public static func == (a: MapboxMaps.RasterArraySource.RasterDataLayer, b: MapboxMaps.RasterArraySource.RasterDataLayer) -> Swift.Bool
    @_spi(Experimental) public func encode(to encoder: any Swift.Encoder) throws
    @_spi(Experimental) public init(from decoder: any Swift.Decoder) throws
  }
}
@_spi(Experimental) @_documentation(visibility: public) public struct RasterArraySource : MapboxMaps.Source {
  @_spi(Experimental) @_documentation(visibility: public) public let type: MapboxMaps.SourceType
  @_spi(Experimental) @_documentation(visibility: public) public let id: Swift.String
  @_spi(Experimental) @_documentation(visibility: public) public var url: Swift.String?
  @_spi(Experimental) @_documentation(visibility: public) public var tiles: [Swift.String]?
  @_spi(Experimental) @_documentation(visibility: public) public var bounds: [Swift.Double]? {
    get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var minzoom: Swift.Double?
  @_spi(Experimental) @_documentation(visibility: public) public var maxzoom: Swift.Double?
  @_spi(Experimental) @_documentation(visibility: public) public var tileSize: Swift.Double? {
    get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var attribution: Swift.String? {
    get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var rasterLayers: [MapboxMaps.RasterArraySource.RasterDataLayer]? {
    get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  @_spi(Experimental) @_documentation(visibility: public) public init(id: Swift.String)
  @_spi(Experimental) public init(from decoder: any Swift.Decoder) throws
}
@_spi(Experimental) extension MapboxMaps.RasterArraySource {
  @_spi(Experimental) public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.RasterArraySource {
  @_spi(Experimental) @_documentation(visibility: public) public func url(_ newValue: Swift.String) -> MapboxMaps.RasterArraySource
  @_spi(Experimental) @_documentation(visibility: public) public func tiles(_ newValue: [Swift.String]) -> MapboxMaps.RasterArraySource
  @_spi(Experimental) @_documentation(visibility: public) public func minzoom(_ newValue: Swift.Double) -> MapboxMaps.RasterArraySource
  @_spi(Experimental) @_documentation(visibility: public) public func maxzoom(_ newValue: Swift.Double) -> MapboxMaps.RasterArraySource
  @_spi(Experimental) @_documentation(visibility: public) public func tileCacheBudget(_ newValue: MapboxMaps.TileCacheBudgetSize) -> MapboxMaps.RasterArraySource
}
public struct RasterDemSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var tiles: [Swift.String]?
  public var bounds: [Swift.Double]?
  public var minzoom: Swift.Double?
  public var maxzoom: Swift.Double?
  public var tileSize: Swift.Double?
  public var attribution: Swift.String?
  public var encoding: MapboxMaps.Encoding?
  public var volatile: Swift.Bool?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public var minimumTileUpdateInterval: Swift.Double?
  public var maxOverscaleFactorForParentTiles: Swift.Double?
  public var tileRequestsDelay: Swift.Double?
  public var tileNetworkRequestsDelay: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.RasterDemSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.RasterDemSource {
  @_spi(Experimental) @_documentation(visibility: public) public func url(_ newValue: Swift.String) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func tiles(_ newValue: [Swift.String]) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func minzoom(_ newValue: Swift.Double) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func maxzoom(_ newValue: Swift.Double) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func volatile(_ newValue: Swift.Bool) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func prefetchZoomDelta(_ newValue: Swift.Double) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileCacheBudget(_ newValue: MapboxMaps.TileCacheBudgetSize) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func minimumTileUpdateInterval(_ newValue: Swift.Double) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func maxOverscaleFactorForParentTiles(_ newValue: Swift.Double) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileRequestsDelay(_ newValue: Swift.Double) -> MapboxMaps.RasterDemSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileNetworkRequestsDelay(_ newValue: Swift.Double) -> MapboxMaps.RasterDemSource
}
public struct RasterLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  @_spi(Experimental) @_documentation(visibility: public) public var rasterArrayBand: MapboxMaps.Value<Swift.String>?
  public var rasterBrightnessMax: MapboxMaps.Value<Swift.Double>?
  public var rasterBrightnessMaxTransition: MapboxMaps.StyleTransition?
  public var rasterBrightnessMin: MapboxMaps.Value<Swift.Double>?
  public var rasterBrightnessMinTransition: MapboxMaps.StyleTransition?
  public var rasterColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var rasterColorMix: MapboxMaps.Value<[Swift.Double]>?
  public var rasterColorMixTransition: MapboxMaps.StyleTransition?
  public var rasterColorRange: MapboxMaps.Value<[Swift.Double]>?
  public var rasterColorRangeTransition: MapboxMaps.StyleTransition?
  public var rasterContrast: MapboxMaps.Value<Swift.Double>?
  public var rasterContrastTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterElevation: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterElevationTransition: MapboxMaps.StyleTransition?
  public var rasterEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var rasterEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var rasterFadeDuration: MapboxMaps.Value<Swift.Double>?
  public var rasterHueRotate: MapboxMaps.Value<Swift.Double>?
  public var rasterHueRotateTransition: MapboxMaps.StyleTransition?
  public var rasterOpacity: MapboxMaps.Value<Swift.Double>?
  public var rasterOpacityTransition: MapboxMaps.StyleTransition?
  public var rasterResampling: MapboxMaps.Value<MapboxMaps.RasterResampling>?
  public var rasterSaturation: MapboxMaps.Value<Swift.Double>?
  public var rasterSaturationTransition: MapboxMaps.StyleTransition?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.RasterLayer, b: MapboxMaps.RasterLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.RasterLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterArrayBand(_ constant: Swift.String) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterArrayBand(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterBrightnessMax(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterBrightnessMaxTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterBrightnessMax(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterBrightnessMin(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterBrightnessMinTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterBrightnessMin(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColor(_ color: UIKit.UIColor) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColorMix(red: Swift.Double, green: Swift.Double, blue: Swift.Double, offset: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColorMixTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColorMix(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColorRange(min: Swift.Double, max: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColorRangeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterColorRange(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterContrast(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterContrastTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterContrast(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterElevation(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterElevationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterElevation(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterFadeDuration(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterFadeDuration(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterHueRotate(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterHueRotateTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterHueRotate(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterOpacity(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterResampling(_ constant: MapboxMaps.RasterResampling) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterResampling(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterSaturation(_ constant: Swift.Double) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterSaturationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterSaturation(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.RasterLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @_documentation(visibility: public) public struct RasterParticleLayer : MapboxMaps.Layer, Swift.Equatable {
  @_spi(Experimental) @_documentation(visibility: public) public var id: Swift.String
  @_spi(Experimental) @_documentation(visibility: public) public let type: MapboxMaps.LayerType
  @_spi(Experimental) @_documentation(visibility: public) public var filter: MapboxMaps.Expression?
  @_spi(Experimental) @_documentation(visibility: public) public var source: Swift.String?
  @_spi(Experimental) @_documentation(visibility: public) public var sourceLayer: Swift.String?
  @_spi(Experimental) @_documentation(visibility: public) public var slot: MapboxMaps.Slot?
  @_spi(Experimental) @_documentation(visibility: public) public var minZoom: Swift.Double?
  @_spi(Experimental) @_documentation(visibility: public) public var maxZoom: Swift.Double?
  @_spi(Experimental) @_documentation(visibility: public) public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleArrayBand: MapboxMaps.Value<Swift.String>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleCount: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleFadeOpacityFactor: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleFadeOpacityFactorTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleMaxSpeed: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleResetRateFactor: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleSpeedFactor: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var rasterParticleSpeedFactorTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public init(id: Swift.String, source: Swift.String)
  @_spi(Experimental) public func encode(to encoder: any Swift.Encoder) throws
  @_spi(Experimental) public init(from decoder: any Swift.Decoder) throws
  @_spi(Experimental) public static func == (a: MapboxMaps.RasterParticleLayer, b: MapboxMaps.RasterParticleLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.RasterParticleLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleArrayBand(_ constant: Swift.String) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleArrayBand(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleColor(_ color: UIKit.UIColor) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleCount(_ constant: Swift.Double) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleCount(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleFadeOpacityFactor(_ constant: Swift.Double) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleFadeOpacityFactorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleFadeOpacityFactor(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleMaxSpeed(_ constant: Swift.Double) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleMaxSpeed(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleResetRateFactor(_ constant: Swift.Double) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleResetRateFactor(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleSpeedFactor(_ constant: Swift.Double) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleSpeedFactorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.RasterParticleLayer
  @_spi(Experimental) @_documentation(visibility: public) public func rasterParticleSpeedFactor(_ expression: MapboxMaps.Expression) -> MapboxMaps.RasterParticleLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.RasterParticleLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct RasterSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var tiles: [Swift.String]?
  public var bounds: [Swift.Double]?
  public var minzoom: Swift.Double?
  public var maxzoom: Swift.Double?
  public var tileSize: Swift.Double?
  public var scheme: MapboxMaps.Scheme?
  public var attribution: Swift.String?
  public var volatile: Swift.Bool?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public var minimumTileUpdateInterval: Swift.Double?
  public var maxOverscaleFactorForParentTiles: Swift.Double?
  public var tileRequestsDelay: Swift.Double?
  public var tileNetworkRequestsDelay: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.RasterSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.RasterSource {
  @_spi(Experimental) @_documentation(visibility: public) public func url(_ newValue: Swift.String) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func tiles(_ newValue: [Swift.String]) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func minzoom(_ newValue: Swift.Double) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func maxzoom(_ newValue: Swift.Double) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func volatile(_ newValue: Swift.Bool) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func prefetchZoomDelta(_ newValue: Swift.Double) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileCacheBudget(_ newValue: MapboxMaps.TileCacheBudgetSize) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func minimumTileUpdateInterval(_ newValue: Swift.Double) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func maxOverscaleFactorForParentTiles(_ newValue: Swift.Double) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileRequestsDelay(_ newValue: Swift.Double) -> MapboxMaps.RasterSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileNetworkRequestsDelay(_ newValue: Swift.Double) -> MapboxMaps.RasterSource
}
extension MapboxCoreMaps.RenderedQueryOptions {
  convenience public init(layerIds: [Swift.String]?, filter: MapboxMaps.Expression?)
  public var filter: MapboxMaps.Expression? {
    get
  }
}
public enum ResolvedImage : Swift.Codable {
  case name(Swift.String)
  case data(MapboxMaps.ResolvedImageData)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ResolvedImageData : Swift.Codable, Swift.Equatable {
  public var available: Swift.Bool
  public var name: Swift.String
  public static func == (a: MapboxMaps.ResolvedImageData, b: MapboxMaps.ResolvedImageData) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.ResolvedImage : Swift.Equatable {
  public static func == (lhs: MapboxMaps.ResolvedImage, rhs: MapboxMaps.ResolvedImage) -> Swift.Bool
}
@available(iOS 13.0, *)
extension MapboxMaps.Signal : Combine.Publisher {
  public typealias Output = Payload
  public typealias Failure = Swift.Never
  public func receive<S>(subscriber: S) where Payload == S.Input, S : Combine.Subscriber, S.Failure == Swift.Never
}
@available(iOS 13.0, *)
extension Combine.Publisher where Self.Failure == Swift.Never {
  public func eraseToSignal() -> MapboxMaps.Signal<Self.Output>
}
public struct Signal<Payload> {
  public typealias Handler = (Payload) -> Swift.Void
  public typealias ObserveImpl = (@escaping MapboxMaps.Signal<Payload>.Handler) -> MapboxMaps.AnyCancelable
  public func observe(_ handler: @escaping MapboxMaps.Signal<Payload>.Handler) -> MapboxMaps.AnyCancelable
  public init(observeImpl: @escaping MapboxMaps.Signal<Payload>.ObserveImpl)
}
extension MapboxMaps.Signal {
  public init(just constant: Payload)
  public func observeNext(_ handler: @escaping MapboxMaps.Signal<Payload>.Handler) -> MapboxMaps.AnyCancelable
}
public struct SkyLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var skyAtmosphereColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var skyAtmosphereHaloColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var skyAtmosphereSun: MapboxMaps.Value<[Swift.Double]>?
  public var skyAtmosphereSunIntensity: MapboxMaps.Value<Swift.Double>?
  public var skyGradient: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var skyGradientCenter: MapboxMaps.Value<[Swift.Double]>?
  public var skyGradientRadius: MapboxMaps.Value<Swift.Double>?
  public var skyOpacity: MapboxMaps.Value<Swift.Double>?
  public var skyOpacityTransition: MapboxMaps.StyleTransition?
  public var skyType: MapboxMaps.Value<MapboxMaps.SkyType>?
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.SkyLayer, b: MapboxMaps.SkyLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.SkyLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereColor(_ color: UIKit.UIColor) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereHaloColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereHaloColor(_ color: UIKit.UIColor) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereHaloColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereSun(azimuthal: Swift.Double, polar: Swift.Double) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereSun(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereSunIntensity(_ constant: Swift.Double) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyAtmosphereSunIntensity(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyGradient(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyGradient(_ color: UIKit.UIColor) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyGradient(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyGradientCenter(azimuthal: Swift.Double, polar: Swift.Double) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyGradientCenter(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyGradientRadius(_ constant: Swift.Double) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyGradientRadius(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyOpacity(_ constant: Swift.Double) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyType(_ constant: MapboxMaps.SkyType) -> MapboxMaps.SkyLayer
  @_spi(Experimental) @_documentation(visibility: public) public func skyType(_ expression: MapboxMaps.Expression) -> MapboxMaps.SkyLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.SkyLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct Slot : Swift.Hashable, Swift.Codable, Swift.RawRepresentable, Swift.ExpressibleByStringLiteral {
  public static let top: MapboxMaps.Slot?
  public static let middle: MapboxMaps.Slot?
  public static let bottom: MapboxMaps.Slot?
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init(stringLiteral value: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
public struct SlotLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public init(id: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.SlotLayer, b: MapboxMaps.SlotLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.SlotLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.SlotLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.SlotLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct SnapshotOverlay {
  public var context: CoreGraphics.CGContext {
    get
  }
  public var scale: CoreFoundation.CGFloat {
    get
  }
  public var pointForCoordinate: ((CoreLocation.CLLocationCoordinate2D) -> CoreFoundation.CGPoint) {
    get
  }
  public var coordinateForPoint: ((CoreFoundation.CGPoint) -> CoreLocation.CLLocationCoordinate2D) {
    get
  }
}
public typealias SnapshotOverlayHandler = ((MapboxMaps.SnapshotOverlay) -> Swift.Void)
@_hasMissingDesignatedInitializers public class Snapshotter : MapboxMaps.StyleManager {
  @available(*, deprecated, message: "Access style APIs directly from Snapshotter instance instead")
  public var style: MapboxMaps.StyleManager {
    get
  }
  convenience public init(options: MapboxMaps.MapSnapshotOptions)
  public var snapshotSize: CoreFoundation.CGSize {
    get
    set(newSize)
  }
  public var cameraState: MapboxMaps.CameraState {
    get
  }
  public func setCamera(to cameraOptions: MapboxMaps.CameraOptions)
  public func start(overlayHandler: MapboxMaps.SnapshotOverlayHandler?, completion: @escaping (Swift.Result<UIKit.UIImage, MapboxMaps.Snapshotter.SnapshotError>) -> Swift.Void)
  public func cancel()
  public enum SnapshotError : Swift.Error {
    case unknown
    case snapshotFailed(reason: Swift.String?)
  }
  public func coordinateBounds(for camera: MapboxMaps.CameraOptions) -> MapboxCoreMaps.CoordinateBounds
  public func camera(for coordinates: [CoreLocation.CLLocationCoordinate2D], padding: UIKit.UIEdgeInsets?, bearing: Swift.Double?, pitch: Swift.Double?) -> MapboxMaps.CameraOptions
  @_spi(Experimental) @_documentation(visibility: public) public func tileCover(for options: MapboxMaps.TileCoverOptions) -> [MapboxCoreMaps.CanonicalTileID]
  @objc deinit
}
extension MapboxMaps.Snapshotter {
  public var onMapLoadingError: MapboxMaps.Signal<MapboxCoreMaps.MapLoadingError> {
    get
  }
  public var onStyleLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleLoaded> {
    get
  }
  public var onStyleDataLoaded: MapboxMaps.Signal<MapboxCoreMaps.StyleDataLoaded> {
    get
  }
  public var onStyleImageMissing: MapboxMaps.Signal<MapboxCoreMaps.StyleImageMissing> {
    get
  }
  @available(*, deprecated, message: "Use snapshotter.on<eventType>.observeNext instead.")
  @discardableResult
  public func onNext<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
  @available(*, deprecated, message: "Use snapshotter.on<eventType>.observe instead.")
  @discardableResult
  public func onEvery<Payload>(event: MapboxMaps.MapEventType<Payload>, handler: @escaping (Payload) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.Snapshotter {
  public func clearData(completion: @escaping ((any Swift.Error)?) -> Swift.Void)
}
public protocol Source : MapboxMaps.StyleDecodable, MapboxMaps.StyleEncodable, Swift.Decodable, Swift.Encodable {
  var type: MapboxMaps.SourceType { get }
  var id: Swift.String { get }
}
extension MapboxMaps.Source {
  public init(jsonObject: [Swift.String : Any]) throws
}
public struct SourceInfo {
  public var id: Swift.String
  public var type: MapboxMaps.SourceType
  public init(id: Swift.String, type: MapboxMaps.SourceType)
}
public struct Scheme : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let xyz: MapboxMaps.Scheme
  public static let tms: MapboxMaps.Scheme
  public typealias RawValue = Swift.String
}
public struct Encoding : Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public static let terrarium: MapboxMaps.Encoding
  public static let mapbox: MapboxMaps.Encoding
  public typealias RawValue = Swift.String
}
public struct SourceType : Swift.ExpressibleByStringLiteral, Swift.RawRepresentable, Swift.Codable, Swift.Hashable {
  public let rawValue: Swift.String
  public static let vector: MapboxMaps.SourceType
  public static let raster: MapboxMaps.SourceType
  public static let rasterDem: MapboxMaps.SourceType
  public static let geoJson: MapboxMaps.SourceType
  public static let image: MapboxMaps.SourceType
  public static let model: MapboxMaps.SourceType
  @_spi(Experimental) public static let rasterArray: MapboxMaps.SourceType
  public static let customGeometry: MapboxMaps.SourceType
  @_spi(Experimental) public static let customRaster: MapboxMaps.SourceType
  public init(stringLiteral type: Swift.String)
  public init(rawValue: Swift.String)
  public var sourceType: (any MapboxMaps.Source.Type)? {
    get
  }
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias RawValue = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.VectorSource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.RasterSource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.RasterDemSource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.RasterArraySource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.ImageSource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.GeoJSONSource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.CustomGeometrySource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.CustomRasterSource : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @_documentation(visibility: public) public struct StandardLightPreset : Swift.RawRepresentable, Swift.Hashable {
  @_spi(Experimental) @_documentation(visibility: public) public let rawValue: Swift.String
  @_spi(Experimental) @_documentation(visibility: public) public init(rawValue: Swift.String)
  @_spi(Experimental) @_documentation(visibility: public) public static let day: MapboxMaps.StandardLightPreset
  @_spi(Experimental) @_documentation(visibility: public) public static let night: MapboxMaps.StandardLightPreset
  @_spi(Experimental) @_documentation(visibility: public) public static let dusk: MapboxMaps.StandardLightPreset
  @_spi(Experimental) @_documentation(visibility: public) public static let dawn: MapboxMaps.StandardLightPreset
  @_spi(Experimental) public typealias RawValue = Swift.String
}
@_documentation(visibility: internal) extension MapboxMaps.StyleManager {
  @available(*, deprecated, renamed: "styleURI")
  public var uri: MapboxMaps.StyleURI? {
    get
    set
  }
  @available(*, deprecated, renamed: "styleJSON")
  public var JSON: Swift.String {
    get
    set
  }
  @available(*, deprecated, renamed: "styleTransition")
  public var transition: MapboxMaps.TransitionOptions {
    get
    set
  }
  @available(*, deprecated, renamed: "isStyleLoaded")
  public var isLoaded: Swift.Bool {
    get
  }
  @available(*, deprecated, renamed: "styleDefaultCamera")
  public var defaultCamera: MapboxMaps.CameraOptions {
    get
  }
}
extension MapboxMaps.StyleManager {
  public func localizeLabels(into locale: Foundation.Locale, forLayerIds layerIds: [Swift.String]? = nil) throws
}
public struct StyleColor : Swift.Codable, Swift.Equatable, Swift.RawRepresentable, Swift.ExpressibleByStringInterpolation {
  public let rawValue: Swift.String
  @available(*, unavailable, message: "Inspect color components by accessing the 'rawValue' property.")
  public var red: Swift.Double {
    get
  }
  @available(*, unavailable, message: "Inspect color components by accessing the 'rawValue' property.")
  public var green: Swift.Double {
    get
  }
  @available(*, unavailable, message: "Inspect color components by accessing the 'rawValue' property.")
  public var blue: Swift.Double {
    get
  }
  public init?(red: Swift.Double, green: Swift.Double, blue: Swift.Double)
  public init?(red: Swift.Double, green: Swift.Double, blue: Swift.Double, alpha: Swift.Double)
  public init?(hue: Swift.Double, saturation: Swift.Double, lightness: Swift.Double)
  public init?(hue: Swift.Double, saturation: Swift.Double, lightness: Swift.Double, alpha: Swift.Double)
  public init(_ color: UIKit.UIColor)
  public init(rawValue: Swift.String)
  public init(stringLiteral value: Swift.StringLiteralType)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public typealias ExtendedGraphemeClusterLiteralType = Swift.StringLiteralType
  public typealias RawValue = Swift.String
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
  public typealias StringLiteralType = Swift.StringLiteralType
  public typealias UnicodeScalarLiteralType = Swift.StringLiteralType
}
public protocol StyleEncodable {
  func jsonObject() throws -> [Swift.String : Any]
}
public protocol StyleDecodable {
  init(jsonObject: [Swift.String : Any]) throws
}
extension MapboxMaps.StyleEncodable where Self : Swift.Encodable {
  public func jsonObject() throws -> [Swift.String : Any]
  public func allStyleProperties() throws -> [Swift.String : Any]
}
public struct StyleError : Swift.RawRepresentable, Foundation.LocalizedError {
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public var errorDescription: Swift.String? {
    get
  }
}
public struct CancelError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public struct TypeConversionError : Swift.Error, Swift.Equatable {
  public let message: Swift.String
  public static let invalidObject: MapboxMaps.TypeConversionError
  public static let unexpectedType: MapboxMaps.TypeConversionError
  public static let unsuccessfulConversion: MapboxMaps.TypeConversionError
  public static func == (a: MapboxMaps.TypeConversionError, b: MapboxMaps.TypeConversionError) -> Swift.Bool
}
public struct MapError : Foundation.LocalizedError {
  public var errorDescription: Swift.String {
    get
  }
}
@_spi(Experimental) public struct StyleImage : Swift.Equatable {
  @_spi(Experimental) public init(id: Swift.String, image: UIKit.UIImage, sdf: Swift.Bool = false, contentInsets: UIKit.UIEdgeInsets = .zero)
  @_spi(Experimental) public static func == (a: MapboxMaps.StyleImage, b: MapboxMaps.StyleImage) -> Swift.Bool
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.StyleImage : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.StyleImage {
  @_spi(Experimental) @_documentation(visibility: public) public func sdf(_ newValue: Swift.Bool) -> MapboxMaps.StyleImage
  @_spi(Experimental) @_documentation(visibility: public) public func contentInsets(_ newValue: UIKit.UIEdgeInsets) -> MapboxMaps.StyleImage
}
@_spi(Experimental) @_documentation(visibility: public) public struct StyleImport {
  @_spi(Experimental) @_documentation(visibility: public) public init(id: Swift.String? = nil, json: Swift.String, configuration: Turf.JSONObject? = nil)
  @_spi(Experimental) @_documentation(visibility: public) public init(id: Swift.String? = nil, uri: MapboxMaps.StyleURI, configuration: Turf.JSONObject? = nil)
  @_spi(Experimental) @_documentation(visibility: public) public init(id: Swift.String? = nil, style: MapboxMaps.MapStyle)
}
@_hasMissingDesignatedInitializers public class StyleManager {
  public func addLayer(_ layer: any MapboxMaps.Layer, layerPosition: MapboxMaps.LayerPosition? = nil) throws
  public func addPersistentLayer(_ layer: any MapboxMaps.Layer, layerPosition: MapboxMaps.LayerPosition? = nil) throws
  public func layer<T>(withId id: Swift.String, type: T.Type) throws -> T where T : MapboxMaps.Layer
  public func layer(withId id: Swift.String) throws -> any MapboxMaps.Layer
  public func updateLayer<T>(withId id: Swift.String, type: T.Type, update: (inout T) throws -> Swift.Void) throws where T : MapboxMaps.Layer
  public func addSource(_ source: any MapboxMaps.Source, dataId: Swift.String? = nil) throws
  public func source<T>(withId id: Swift.String, type: T.Type) throws -> T where T : MapboxMaps.Source
  public func source(withId id: Swift.String) throws -> any MapboxMaps.Source
  public func updateGeoJSONSource(withId id: Swift.String, data: MapboxMaps.GeoJSONSourceData, dataId: Swift.String? = nil)
  public func updateGeoJSONSource(withId id: Swift.String, geoJSON: Turf.GeoJSONObject, dataId: Swift.String? = nil)
  public func addGeoJSONSourceFeatures(forSourceId sourceId: Swift.String, features: [MapboxMaps.Feature], dataId: Swift.String? = nil)
  public func updateGeoJSONSourceFeatures(forSourceId sourceId: Swift.String, features: [MapboxMaps.Feature], dataId: Swift.String? = nil)
  public func removeGeoJSONSourceFeatures(forSourceId sourceId: Swift.String, featureIds: [Swift.String], dataId: Swift.String? = nil)
  public var isStyleLoaded: Swift.Bool {
    get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var mapStyle: MapboxMaps.MapStyle? {
    get
    set
  }
  @_spi(Experimental) @available(iOS 13.0, *)
  @_documentation(visibility: public) public func setMapStyleContent(@MapboxMaps.MapStyleContentBuilder content: () -> some MapStyleContent)
  public var styleURI: MapboxMaps.StyleURI? {
    get
    set
  }
  public var styleJSON: Swift.String {
    get
    set
  }
  @_spi(Experimental) @_documentation(visibility: public) public func load(mapStyle: MapboxMaps.MapStyle, transition: MapboxMaps.TransitionOptions? = nil, completion: (((any Swift.Error)?) -> Swift.Void)? = nil)
  public var styleDefaultCamera: MapboxMaps.CameraOptions {
    get
  }
  public var styleTransition: MapboxMaps.TransitionOptions {
    get
    set
  }
  public var styleImports: [MapboxCoreMaps.StyleObjectInfo] {
    get
  }
  public func getStyleImportSchema(for importId: Swift.String) throws -> Any
  public func getStyleImportConfigProperties(for importId: Swift.String) throws -> [Swift.String : MapboxCoreMaps.StylePropertyValue]
  public func getStyleImportConfigProperty(for importId: Swift.String, config: Swift.String) throws -> MapboxCoreMaps.StylePropertyValue
  public func setStyleImportConfigProperties(for importId: Swift.String, configs: [Swift.String : Any]) throws
  public func setStyleImportConfigProperty(for importId: Swift.String, config: Swift.String, value: Any) throws
  public func addLayer(with properties: [Swift.String : Any], layerPosition: MapboxMaps.LayerPosition?) throws
  public func moveLayer(withId id: Swift.String, to position: MapboxMaps.LayerPosition) throws
  public func addPersistentLayer(with properties: [Swift.String : Any], layerPosition: MapboxMaps.LayerPosition?) throws
  public func isPersistentLayer(id: Swift.String) throws -> Swift.Bool
  public func addPersistentCustomLayer(withId id: Swift.String, layerHost: any MapboxCoreMaps.CustomLayerHost, layerPosition: MapboxMaps.LayerPosition?) throws
  public func addCustomLayer(withId id: Swift.String, layerHost: any MapboxCoreMaps.CustomLayerHost, layerPosition: MapboxMaps.LayerPosition?) throws
  public func removeLayer(withId id: Swift.String) throws
  public func layerExists(withId id: Swift.String) -> Swift.Bool
  @_spi(Experimental) public var allSlotIdentifiers: [MapboxMaps.Slot] {
    get
  }
  public var allLayerIdentifiers: [MapboxMaps.LayerInfo] {
    get
  }
  public func layerPropertyValue(for layerId: Swift.String, property: Swift.String) -> Any
  public func layerProperty(for layerId: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setLayerProperty(for layerId: Swift.String, property: Swift.String, value: Any) throws
  public static func layerPropertyDefaultValue(for layerType: MapboxMaps.LayerType, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func layerProperties(for layerId: Swift.String) throws -> [Swift.String : Any]
  public func setLayerProperties(for layerId: Swift.String, properties: [Swift.String : Any]) throws
  public func addSource(withId id: Swift.String, properties: [Swift.String : Any]) throws
  public func removeSource(withId id: Swift.String) throws
  public func sourceExists(withId id: Swift.String) -> Swift.Bool
  public var allSourceIdentifiers: [MapboxMaps.SourceInfo] {
    get
  }
  public func sourceProperty(for sourceId: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setSourceProperty(for sourceId: Swift.String, property: Swift.String, value: Any) throws
  public func sourceProperties(for sourceId: Swift.String) throws -> [Swift.String : Any]
  public func setSourceProperties(for sourceId: Swift.String, properties: [Swift.String : Any]) throws
  public static func sourcePropertyDefaultValue(for sourceType: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func updateImageSource(withId id: Swift.String, image: UIKit.UIImage) throws
  public func addImage(_ image: UIKit.UIImage, id: Swift.String, sdf: Swift.Bool = false, stretchX: [MapboxCoreMaps.ImageStretches], stretchY: [MapboxCoreMaps.ImageStretches], content: MapboxCoreMaps.ImageContent? = nil) throws
  public func addImage(_ image: UIKit.UIImage, id: Swift.String, sdf: Swift.Bool = false, contentInsets: UIKit.UIEdgeInsets = .zero) throws
  public func removeImage(withId id: Swift.String) throws
  public func imageExists(withId id: Swift.String) -> Swift.Bool
  public func image(withId id: Swift.String) -> UIKit.UIImage?
  public var allLightIdentifiers: [MapboxMaps.LightInfo] {
    get
  }
  public func lightProperty(for lightId: Swift.String, property: Swift.String) -> Any
  public func lightPropertyValue(for lightId: Swift.String, property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setLights(_ flatLight: MapboxMaps.FlatLight) throws
  public func setLights(ambient ambientLight: MapboxMaps.AmbientLight, directional directionalLight: MapboxMaps.DirectionalLight) throws
  public func setLightProperty(for lightId: Swift.String, property: Swift.String, value: Any) throws
  public func setTerrain(_ terrain: MapboxMaps.Terrain) throws
  public func removeTerrain()
  public func setTerrain(properties: [Swift.String : Any]) throws
  public func setTerrainProperty(_ property: Swift.String, value: Any) throws
  public func terrainProperty(_ property: Swift.String) -> Any
  public func terrainProperty(_ property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  public func setAtmosphere(_ atmosphere: MapboxMaps.Atmosphere) throws
  public func removeAtmosphere() throws
  public func setAtmosphere(properties: [Swift.String : Any]) throws
  public func setAtmosphereProperty(_ property: Swift.String, value: Any) throws
  public func atmosphereProperty(_ property: Swift.String) -> MapboxCoreMaps.StylePropertyValue
  @_spi(Experimental) @_documentation(visibility: public) public func addStyleModel(modelId: Swift.String, modelUri: Swift.String) throws
  @_spi(Experimental) @_documentation(visibility: public) public func removeStyleModel(modelId: Swift.String) throws
  @_spi(Experimental) @_documentation(visibility: public) public func hasStyleModel(modelId: Swift.String) -> Swift.Bool
  public func addCustomGeometrySource(withId id: Swift.String, options: MapboxCoreMaps.CustomGeometrySourceOptions) throws
  public func setCustomGeometrySourceTileData(forSourceId sourceId: Swift.String, tileId: MapboxCoreMaps.CanonicalTileID, features: [MapboxMaps.Feature]) throws
  public func invalidateCustomGeometrySourceTile(forSourceId sourceId: Swift.String, tileId: MapboxCoreMaps.CanonicalTileID) throws
  public func invalidateCustomGeometrySourceRegion(forSourceId sourceId: Swift.String, bounds: MapboxCoreMaps.CoordinateBounds) throws
  @_spi(Experimental) public func addCustomRasterSource(forSourceId sourceId: Swift.String, options: MapboxCoreMaps.CustomRasterSourceOptions) throws
  @_spi(Experimental) public func setCustomRasterSourceTileData(forSourceId sourceId: Swift.String, tiles: [MapboxCoreMaps.CustomRasterSourceTileData]) throws
  public func addStyleImport(withId id: Swift.String, uri: MapboxMaps.StyleURI, config: [Swift.String : Any]? = nil, importPosition: MapboxMaps.ImportPosition? = nil) throws
  public func addStyleImport(withId id: Swift.String, json: Swift.String, config: [Swift.String : Any]? = nil, importPosition: MapboxMaps.ImportPosition? = nil) throws
  public func updateStyleImport(withId id: Swift.String, uri: MapboxMaps.StyleURI, config: [Swift.String : Any]? = nil) throws
  public func updateStyleImport(withId id: Swift.String, json: Swift.String, config: [Swift.String : Any]? = nil) throws
  public func moveStyleImport(withId id: Swift.String, to position: MapboxMaps.ImportPosition) throws
  public func removeStyleImport(withId id: Swift.String) throws
  @available(*, deprecated, renamed: "removeStyleImport(withId:)", message: "Please use the removeStyleImport(withId:) version.")
  public func removeStyleImport(for importId: Swift.String) throws
  @objc deinit
}
extension MapboxMaps.StyleManager {
  public func setProjection(_ projection: MapboxMaps.StyleProjection) throws
  public var projection: MapboxMaps.StyleProjection? {
    get
  }
}
public struct StyleTransition : Swift.Codable, Swift.Equatable {
  public static let zero: MapboxMaps.StyleTransition
  public var duration: Swift.Double
  public var delay: Swift.Double
  public init(duration: Foundation.TimeInterval, delay: Foundation.TimeInterval)
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: MapboxMaps.StyleTransition, b: MapboxMaps.StyleTransition) -> Swift.Bool
}
extension MapboxCoreMaps.StylePackLoadOptions {
  convenience public init?(glyphsRasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode?, metadata: Any? = nil, acceptExpired: Swift.Bool = false, extraOptions: Any? = nil)
  public var glyphsRasterizationMode: MapboxCoreMaps.GlyphsRasterizationMode? {
    get
  }
}
public struct StyleProjection : Swift.Hashable, Swift.Codable, MapboxMaps.StyleEncodable, Swift.Equatable {
  public var name: MapboxMaps.StyleProjectionName
  public init(name: MapboxMaps.StyleProjectionName)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.StyleProjection, b: MapboxMaps.StyleProjection) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public var hashValue: Swift.Int {
    get
  }
  public init(from decoder: any Swift.Decoder) throws
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.StyleProjection : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct StyleURI : Swift.Hashable, Swift.RawRepresentable {
  public typealias RawValue = Swift.String
  public let rawValue: Swift.String
  public init?(rawValue: Swift.String)
  public init?(url: Foundation.URL)
  public static let streets: MapboxMaps.StyleURI
  public static let outdoors: MapboxMaps.StyleURI
  public static let light: MapboxMaps.StyleURI
  public static let dark: MapboxMaps.StyleURI
  public static let satellite: MapboxMaps.StyleURI
  public static let satelliteStreets: MapboxMaps.StyleURI
  public static let standard: MapboxMaps.StyleURI
}
public struct SymbolLayer : MapboxMaps.Layer, Swift.Equatable {
  public var id: Swift.String
  public let type: MapboxMaps.LayerType
  public var filter: MapboxMaps.Expression?
  public var source: Swift.String?
  public var sourceLayer: Swift.String?
  public var slot: MapboxMaps.Slot?
  public var minZoom: Swift.Double?
  public var maxZoom: Swift.Double?
  public var visibility: MapboxMaps.Value<MapboxMaps.Visibility>
  public var iconAllowOverlap: MapboxMaps.Value<Swift.Bool>?
  public var iconAnchor: MapboxMaps.Value<MapboxMaps.IconAnchor>?
  public var iconIgnorePlacement: MapboxMaps.Value<Swift.Bool>?
  public var iconImage: MapboxMaps.Value<MapboxMaps.ResolvedImage>?
  public var iconKeepUpright: MapboxMaps.Value<Swift.Bool>?
  public var iconOffset: MapboxMaps.Value<[Swift.Double]>?
  public var iconOptional: MapboxMaps.Value<Swift.Bool>?
  public var iconPadding: MapboxMaps.Value<Swift.Double>?
  public var iconPitchAlignment: MapboxMaps.Value<MapboxMaps.IconPitchAlignment>?
  public var iconRotate: MapboxMaps.Value<Swift.Double>?
  public var iconRotationAlignment: MapboxMaps.Value<MapboxMaps.IconRotationAlignment>?
  public var iconSize: MapboxMaps.Value<Swift.Double>?
  public var iconTextFit: MapboxMaps.Value<MapboxMaps.IconTextFit>?
  public var iconTextFitPadding: MapboxMaps.Value<[Swift.Double]>?
  public var symbolAvoidEdges: MapboxMaps.Value<Swift.Bool>?
  public var symbolPlacement: MapboxMaps.Value<MapboxMaps.SymbolPlacement>?
  public var symbolSortKey: MapboxMaps.Value<Swift.Double>?
  public var symbolSpacing: MapboxMaps.Value<Swift.Double>?
  public var symbolZElevate: MapboxMaps.Value<Swift.Bool>?
  public var symbolZOrder: MapboxMaps.Value<MapboxMaps.SymbolZOrder>?
  public var textAllowOverlap: MapboxMaps.Value<Swift.Bool>?
  public var textAnchor: MapboxMaps.Value<MapboxMaps.TextAnchor>?
  public var textField: MapboxMaps.Value<Swift.String>?
  public var textFont: MapboxMaps.Value<[Swift.String]>?
  public var textIgnorePlacement: MapboxMaps.Value<Swift.Bool>?
  public var textJustify: MapboxMaps.Value<MapboxMaps.TextJustify>?
  public var textKeepUpright: MapboxMaps.Value<Swift.Bool>?
  public var textLetterSpacing: MapboxMaps.Value<Swift.Double>?
  public var textLineHeight: MapboxMaps.Value<Swift.Double>?
  public var textMaxAngle: MapboxMaps.Value<Swift.Double>?
  public var textMaxWidth: MapboxMaps.Value<Swift.Double>?
  public var textOffset: MapboxMaps.Value<[Swift.Double]>?
  public var textOptional: MapboxMaps.Value<Swift.Bool>?
  public var textPadding: MapboxMaps.Value<Swift.Double>?
  public var textPitchAlignment: MapboxMaps.Value<MapboxMaps.TextPitchAlignment>?
  public var textRadialOffset: MapboxMaps.Value<Swift.Double>?
  public var textRotate: MapboxMaps.Value<Swift.Double>?
  public var textRotationAlignment: MapboxMaps.Value<MapboxMaps.TextRotationAlignment>?
  public var textSize: MapboxMaps.Value<Swift.Double>?
  public var textTransform: MapboxMaps.Value<MapboxMaps.TextTransform>?
  public var textVariableAnchor: MapboxMaps.Value<[MapboxMaps.TextAnchor]>?
  public var textWritingMode: MapboxMaps.Value<[MapboxMaps.TextWritingMode]>?
  public var iconColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var iconColorTransition: MapboxMaps.StyleTransition?
  public var iconColorSaturation: MapboxMaps.Value<Swift.Double>?
  public var iconColorSaturationTransition: MapboxMaps.StyleTransition?
  public var iconEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var iconEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var iconHaloBlur: MapboxMaps.Value<Swift.Double>?
  public var iconHaloBlurTransition: MapboxMaps.StyleTransition?
  public var iconHaloColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var iconHaloColorTransition: MapboxMaps.StyleTransition?
  public var iconHaloWidth: MapboxMaps.Value<Swift.Double>?
  public var iconHaloWidthTransition: MapboxMaps.StyleTransition?
  public var iconImageCrossFade: MapboxMaps.Value<Swift.Double>?
  public var iconImageCrossFadeTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var iconOcclusionOpacity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var iconOcclusionOpacityTransition: MapboxMaps.StyleTransition?
  public var iconOpacity: MapboxMaps.Value<Swift.Double>?
  public var iconOpacityTransition: MapboxMaps.StyleTransition?
  public var iconTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var iconTranslateTransition: MapboxMaps.StyleTransition?
  public var iconTranslateAnchor: MapboxMaps.Value<MapboxMaps.IconTranslateAnchor>?
  public var textColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var textColorTransition: MapboxMaps.StyleTransition?
  public var textEmissiveStrength: MapboxMaps.Value<Swift.Double>?
  public var textEmissiveStrengthTransition: MapboxMaps.StyleTransition?
  public var textHaloBlur: MapboxMaps.Value<Swift.Double>?
  public var textHaloBlurTransition: MapboxMaps.StyleTransition?
  public var textHaloColor: MapboxMaps.Value<MapboxMaps.StyleColor>?
  public var textHaloColorTransition: MapboxMaps.StyleTransition?
  public var textHaloWidth: MapboxMaps.Value<Swift.Double>?
  public var textHaloWidthTransition: MapboxMaps.StyleTransition?
  @_spi(Experimental) @_documentation(visibility: public) public var textOcclusionOpacity: MapboxMaps.Value<Swift.Double>?
  @_spi(Experimental) @_documentation(visibility: public) public var textOcclusionOpacityTransition: MapboxMaps.StyleTransition?
  public var textOpacity: MapboxMaps.Value<Swift.Double>?
  public var textOpacityTransition: MapboxMaps.StyleTransition?
  public var textTranslate: MapboxMaps.Value<[Swift.Double]>?
  public var textTranslateTransition: MapboxMaps.StyleTransition?
  public var textTranslateAnchor: MapboxMaps.Value<MapboxMaps.TextTranslateAnchor>?
  public init(id: Swift.String, source: Swift.String)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
  public static func == (a: MapboxMaps.SymbolLayer, b: MapboxMaps.SymbolLayer) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.SymbolLayer {
  @_spi(Experimental) @_documentation(visibility: public) public func filter(_ newValue: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func source(_ newValue: Swift.String) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func sourceLayer(_ newValue: Swift.String) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func slot(_ newValue: MapboxMaps.Slot?) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func minZoom(_ newValue: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func maxZoom(_ newValue: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconAllowOverlap(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconAllowOverlap(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconAnchor(_ constant: MapboxMaps.IconAnchor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconIgnorePlacement(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconIgnorePlacement(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconImage(_ constant: Swift.String) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconImage(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconKeepUpright(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconKeepUpright(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOffset(x: Swift.Double, y: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOffset(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOptional(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOptional(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconPadding(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconPadding(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconPitchAlignment(_ constant: MapboxMaps.IconPitchAlignment) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconPitchAlignment(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconRotate(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconRotate(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconRotationAlignment(_ constant: MapboxMaps.IconRotationAlignment) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconRotationAlignment(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconSize(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconSize(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTextFit(_ constant: MapboxMaps.IconTextFit) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTextFit(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTextFitPadding(_ padding: UIKit.UIEdgeInsets) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTextFitPadding(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolAvoidEdges(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolAvoidEdges(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolPlacement(_ constant: MapboxMaps.SymbolPlacement) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolPlacement(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolSortKey(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolSortKey(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolSpacing(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolSpacing(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolZElevate(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolZElevate(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolZOrder(_ constant: MapboxMaps.SymbolZOrder) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func symbolZOrder(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textAllowOverlap(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textAllowOverlap(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textAnchor(_ constant: MapboxMaps.TextAnchor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textField(_ constant: Swift.String) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textField(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textFont(_ constant: [Swift.String]) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textFont(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textIgnorePlacement(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textIgnorePlacement(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textJustify(_ constant: MapboxMaps.TextJustify) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textJustify(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textKeepUpright(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textKeepUpright(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textLetterSpacing(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textLetterSpacing(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textLineHeight(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textLineHeight(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textMaxAngle(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textMaxAngle(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textMaxWidth(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textMaxWidth(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOffset(x: Swift.Double, y: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOffset(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOptional(_ constant: Swift.Bool) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOptional(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textPadding(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textPadding(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textPitchAlignment(_ constant: MapboxMaps.TextPitchAlignment) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textPitchAlignment(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textRadialOffset(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textRadialOffset(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textRotate(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textRotate(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textRotationAlignment(_ constant: MapboxMaps.TextRotationAlignment) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textRotationAlignment(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textSize(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textSize(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textTransform(_ constant: MapboxMaps.TextTransform) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textTransform(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textVariableAnchor(_ constant: [MapboxMaps.TextAnchor]) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textVariableAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textWritingMode(_ constant: [MapboxMaps.TextWritingMode]) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textWritingMode(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconColor(_ color: UIKit.UIColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconColorSaturation(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconColorSaturationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconColorSaturation(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloBlur(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloBlurTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloBlur(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloColor(_ color: UIKit.UIColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloWidth(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloWidthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconHaloWidth(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconImageCrossFade(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconImageCrossFadeTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconImageCrossFade(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOcclusionOpacity(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOcclusionOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOcclusionOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOpacity(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTranslate(x: Swift.Double, y: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTranslateTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTranslate(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTranslateAnchor(_ constant: MapboxMaps.IconTranslateAnchor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func iconTranslateAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textColor(_ color: UIKit.UIColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textEmissiveStrength(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textEmissiveStrengthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textEmissiveStrength(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloBlur(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloBlurTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloBlur(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloColor(_ constant: MapboxMaps.StyleColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloColor(_ color: UIKit.UIColor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloColorTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloColor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloWidth(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloWidthTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textHaloWidth(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOcclusionOpacity(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOcclusionOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOcclusionOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOpacity(_ constant: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOpacityTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textOpacity(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textTranslate(x: Swift.Double, y: Swift.Double) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textTranslateTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textTranslate(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textTranslateAnchor(_ constant: MapboxMaps.TextTranslateAnchor) -> MapboxMaps.SymbolLayer
  @_spi(Experimental) @_documentation(visibility: public) public func textTranslateAnchor(_ expression: MapboxMaps.Expression) -> MapboxMaps.SymbolLayer
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.SymbolLayer : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public struct Terrain : Swift.Codable, Swift.Equatable {
  public var source: Swift.String
  public init(sourceId: Swift.String)
  public var exaggeration: MapboxMaps.Value<Swift.Double>?
  public var exaggerationTransition: MapboxMaps.StyleTransition?
  public static func == (a: MapboxMaps.Terrain, b: MapboxMaps.Terrain) -> Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.Terrain {
  @_spi(Experimental) @_documentation(visibility: public) public func exaggeration(_ constant: Swift.Double) -> MapboxMaps.Terrain
  @_spi(Experimental) @_documentation(visibility: public) public func exaggerationTransition(_ transition: MapboxMaps.StyleTransition) -> MapboxMaps.Terrain
  @_spi(Experimental) @_documentation(visibility: public) public func exaggeration(_ expression: MapboxMaps.Expression) -> MapboxMaps.Terrain
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.Terrain : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public enum TileCacheBudgetSize {
  case tiles(Swift.Int)
  case megabytes(Swift.Int)
}
extension MapboxMaps.TileCacheBudgetSize : Swift.Codable, Swift.Equatable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
  public static func == (a: MapboxMaps.TileCacheBudgetSize, b: MapboxMaps.TileCacheBudgetSize) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) public struct TileCoverOptions {
  @_spi(Experimental) @_documentation(visibility: public) public var tileSize: Swift.UInt16?
  @_spi(Experimental) @_documentation(visibility: public) public var minZoom: Swift.UInt8?
  @_spi(Experimental) @_documentation(visibility: public) public var maxZoom: Swift.UInt8?
  @_spi(Experimental) @_documentation(visibility: public) public var roundZoom: Swift.Bool?
  @_spi(Experimental) @_documentation(visibility: public) public init(tileSize: Swift.UInt16? = nil, minZoom: Swift.UInt8? = nil, maxZoom: Swift.UInt8? = nil, roundZoom: Swift.Bool? = nil)
}
extension MapboxCommon.TileRegionLoadOptions {
  convenience public init?(geometry: MapboxMaps.Geometry?, descriptors: [MapboxCommon.TilesetDescriptor]? = nil, metadata: Any? = nil, acceptExpired: Swift.Bool = false, networkRestriction: MapboxCommon.NetworkRestriction = .none, averageBytesPerSecond: Swift.Int? = nil, extraOptions: Any? = nil)
  public var averageBytesPerSecond: Swift.Int? {
    get
  }
  public var geometry: MapboxMaps.Geometry? {
    get
  }
}
extension MapboxCommon.TileStore {
  public static var `default`: MapboxCommon.TileStore {
    get
  }
  public static func shared(for filePathURL: Foundation.URL) -> MapboxCommon.TileStore
  @discardableResult
  public func loadTileRegion(forId id: Swift.String, loadOptions: MapboxCommon.TileRegionLoadOptions, progress: MapboxCommon.TileRegionLoadProgressCallback? = nil, completion: @escaping (Swift.Result<MapboxCommon.TileRegion, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  @discardableResult
  public func estimateTileRegion(forId id: Swift.String, loadOptions: MapboxCommon.TileRegionLoadOptions, estimateOptions: MapboxCommon.TileRegionEstimateOptions? = nil, progress: @escaping MapboxCommon.TileRegionEstimateProgressCallback, completion: @escaping (Swift.Result<MapboxCommon.TileRegionEstimateResult, any Swift.Error>) -> Swift.Void) -> any MapboxCommon.Cancelable
  public func tileRegionContainsDescriptors(forId id: Swift.String, descriptors: [MapboxCommon.TilesetDescriptor], completion: @escaping (Swift.Result<Swift.Bool, any Swift.Error>) -> Swift.Void)
  public func allTileRegions(completion: @escaping (Swift.Result<[MapboxCommon.TileRegion], any Swift.Error>) -> Swift.Void)
  public func tileRegion(forId id: Swift.String, completion: @escaping (Swift.Result<MapboxCommon.TileRegion, any Swift.Error>) -> Swift.Void)
  public func tileRegionGeometry(forId id: Swift.String, completion: @escaping (Swift.Result<MapboxMaps.Geometry, any Swift.Error>) -> Swift.Void)
  public func tileRegionMetadata(forId id: Swift.String, completion: @escaping (Swift.Result<Any, any Swift.Error>) -> Swift.Void)
  public func subscribe(_ observer: any MapboxMaps.TileStoreObserver) -> any MapboxCommon.Cancelable
  public func removeRegion(forId id: Swift.String, completion: @escaping (Swift.Result<MapboxCommon.TileRegion, any Swift.Error>) -> Swift.Void)
}
public protocol TileStoreObserver : AnyObject {
  func onRegionLoadProgress(forId id: Swift.String, progress: MapboxCommon.TileRegionLoadProgress)
  func onRegionLoadFinished(forId id: Swift.String, region: Swift.Result<MapboxCommon.TileRegion, any Swift.Error>)
  func onRegionRemoved(forId id: Swift.String)
  func onRegionGeometryChanged(forId id: Swift.String, geometry: MapboxMaps.Geometry?)
  func onRegionMetadataChanged(forId id: Swift.String, value: Any)
}
extension MapboxCoreMaps.TilesetDescriptorOptions {
  convenience public init(styleURI: MapboxMaps.StyleURI, zoomRange: Swift.ClosedRange<Swift.UInt8>, pixelRatio: Swift.Float? = nil, tilesets: [Swift.String]?, stylePackOptions: MapboxCoreMaps.StylePackLoadOptions? = nil, extraOptions: Any? = nil)
}
public struct TimingCurve : Swift.Equatable {
  public static let easeInOut: MapboxMaps.TimingCurve
  public static let easeIn: MapboxMaps.TimingCurve
  public static let easeOut: MapboxMaps.TimingCurve
  public static let linear: MapboxMaps.TimingCurve
  public static func == (a: MapboxMaps.TimingCurve, b: MapboxMaps.TimingCurve) -> Swift.Bool
}
public struct Tracing : Swift.OptionSet {
  public static let disabled: MapboxMaps.Tracing
  public static let platform: MapboxMaps.Tracing
  public static let core: MapboxMaps.Tracing
  public static let enabled: MapboxMaps.Tracing
  public static let environmentVariableName: Swift.String
  public static var status: MapboxMaps.Tracing {
    get
    set
  }
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  public typealias ArrayLiteralElement = MapboxMaps.Tracing
  public typealias Element = MapboxMaps.Tracing
  public typealias RawValue = Swift.Int
}
public struct TransitionOptions : Swift.Equatable {
  public init(duration: Foundation.TimeInterval? = nil, delay: Foundation.TimeInterval? = nil, enablePlacementTransitions: Swift.Bool? = nil)
  public var duration: Foundation.TimeInterval?
  public var delay: Foundation.TimeInterval?
  public var enablePlacementTransitions: Swift.Bool?
  public static func == (a: MapboxMaps.TransitionOptions, b: MapboxMaps.TransitionOptions) -> Swift.Bool
}
@_spi(Experimental) @available(iOS 13.0, *)
extension MapboxMaps.TransitionOptions : MapboxMaps.MapStyleContent {
  @_spi(Experimental) public typealias Body = Swift.Never
}
public enum Value<T> : Swift.Codable where T : Swift.Decodable, T : Swift.Encodable {
  case constant(T)
  case expression(MapboxMaps.Expression)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.Value : Swift.Equatable where T : Swift.Equatable {
  public static func == (a: MapboxMaps.Value<T>, b: MapboxMaps.Value<T>) -> Swift.Bool
}
public struct VectorSource : MapboxMaps.Source {
  public let type: MapboxMaps.SourceType
  public let id: Swift.String
  public var url: Swift.String?
  public var tiles: [Swift.String]?
  public var bounds: [Swift.Double]?
  public var scheme: MapboxMaps.Scheme?
  public var minzoom: Swift.Double?
  public var maxzoom: Swift.Double?
  public var attribution: Swift.String?
  public var promoteId: MapboxMaps.PromoteId?
  public var volatile: Swift.Bool?
  public var prefetchZoomDelta: Swift.Double?
  public var tileCacheBudget: MapboxMaps.TileCacheBudgetSize?
  public var minimumTileUpdateInterval: Swift.Double?
  public var maxOverscaleFactorForParentTiles: Swift.Double?
  public var tileRequestsDelay: Swift.Double?
  public var tileNetworkRequestsDelay: Swift.Double?
  public init(id: Swift.String)
  public init(from decoder: any Swift.Decoder) throws
}
extension MapboxMaps.VectorSource {
  public func encode(to encoder: any Swift.Encoder) throws
}
@_spi(Experimental) @_documentation(visibility: public) extension MapboxMaps.VectorSource {
  @_spi(Experimental) @_documentation(visibility: public) public func url(_ newValue: Swift.String) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func tiles(_ newValue: [Swift.String]) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func minzoom(_ newValue: Swift.Double) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func maxzoom(_ newValue: Swift.Double) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func volatile(_ newValue: Swift.Bool) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func prefetchZoomDelta(_ newValue: Swift.Double) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileCacheBudget(_ newValue: MapboxMaps.TileCacheBudgetSize) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func minimumTileUpdateInterval(_ newValue: Swift.Double) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func maxOverscaleFactorForParentTiles(_ newValue: Swift.Double) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileRequestsDelay(_ newValue: Swift.Double) -> MapboxMaps.VectorSource
  @_spi(Experimental) @_documentation(visibility: public) public func tileNetworkRequestsDelay(_ newValue: Swift.Double) -> MapboxMaps.VectorSource
}
final public class ViewAnnotation {
  final public let view: UIKit.UIView
  final public var annotatedFeature: MapboxMaps.AnnotatedFeature {
    get
    set
  }
  final public var allowOverlap: Swift.Bool {
    get
    set
  }
  final public var allowOverlapWithPuck: Swift.Bool {
    get
    set
  }
  final public var ignoreCameraPadding: Swift.Bool {
    get
    set
  }
  final public var visible: Swift.Bool {
    get
    set
  }
  final public var selected: Swift.Bool {
    get
    set
  }
  final public var variableAnchors: [MapboxCoreMaps.ViewAnnotationAnchorConfig] {
    get
    set
  }
  final public var onVisibilityChanged: ((Swift.Bool) -> Swift.Void)?
  final public var onAnchorChanged: ((MapboxCoreMaps.ViewAnnotationAnchorConfig) -> Swift.Void)?
  final public var onAnchorCoordinateChanged: ((CoreLocation.CLLocationCoordinate2D) -> Swift.Void)?
  final public var onFrameChanged: ((CoreFoundation.CGRect) -> Swift.Void)?
  final public var anchorConfig: MapboxCoreMaps.ViewAnnotationAnchorConfig? {
    get
  }
  final public var anchorCoordinate: CoreLocation.CLLocationCoordinate2D? {
    get
  }
  public init(annotatedFeature: MapboxMaps.AnnotatedFeature, view: UIKit.UIView)
  convenience public init(coordinate: CoreLocation.CLLocationCoordinate2D, view: UIKit.UIView)
  convenience public init(layerId: Swift.String, featureId: Swift.String? = nil, view: UIKit.UIView)
  final public func remove()
  final public func setNeedsUpdateSize()
  @objc deinit
}
extension MapboxCoreMaps.ViewAnnotationAnchorConfig {
  convenience public init(anchor: MapboxCoreMaps.ViewAnnotationAnchor, offsetX: CoreFoundation.CGFloat = 0, offsetY: CoreFoundation.CGFloat = 0)
}
extension Swift.Array where Element == MapboxCoreMaps.ViewAnnotationAnchorConfig {
  public static let all: [MapboxCoreMaps.ViewAnnotationAnchorConfig]
  public static let center: [MapboxCoreMaps.ViewAnnotationAnchorConfig]
}
public struct ViewAnnotationManagerError : Swift.Error, Swift.Equatable {
  public let message: Swift.String
  public static let viewIsAlreadyAdded: MapboxMaps.ViewAnnotationManagerError
  public static let annotationNotFound: MapboxMaps.ViewAnnotationManagerError
  public static let annotatedFeatureMissing: MapboxMaps.ViewAnnotationManagerError
  public static func == (a: MapboxMaps.ViewAnnotationManagerError, b: MapboxMaps.ViewAnnotationManagerError) -> Swift.Bool
}
public protocol ViewAnnotationUpdateObserver : AnyObject {
  func framesDidChange(for annotationViews: [UIKit.UIView])
  func visibilityDidChange(for annotationViews: [UIKit.UIView])
}
@_hasMissingDesignatedInitializers final public class ViewAnnotationManager {
  @available(*, deprecated)
  final public var validatesViews: Swift.Bool {
    get
    set
  }
  final public var allAnnotations: [MapboxMaps.ViewAnnotation] {
    get
  }
  @available(*, deprecated, renamed: "allAnnotations", message: "Please use allAnnotations instead, or directly access ViewAnnotation itself")
  final public var annotations: [UIKit.UIView : MapboxMaps.ViewAnnotationOptions] {
    get
  }
  @objc deinit
  final public func add(_ annotation: MapboxMaps.ViewAnnotation)
  @available(*, deprecated, message: "Use add(_:) that takes ViewAnnotation")
  final public func add(_ view: UIKit.UIView, options: MapboxMaps.ViewAnnotationOptions) throws
  @available(*, deprecated, message: "Use add(_:) that takes ViewAnnotation")
  final public func add(_ view: UIKit.UIView, id: Swift.String?, options: MapboxMaps.ViewAnnotationOptions) throws
  @available(*, deprecated, message: "Use ViewAnnotation.remove()")
  final public func remove(_ view: UIKit.UIView)
  final public func removeAll()
  @available(*, deprecated, message: "Use ViewAnnotation properties")
  final public func update(_ view: UIKit.UIView, options: MapboxMaps.ViewAnnotationOptions) throws
  @available(*, deprecated, message: "Use ViewAnnotation.view")
  final public func view(forId id: Swift.String) -> UIKit.UIView?
  @available(*, unavailable, message: "Store annotation references on calling site")
  final public func view(forFeatureId identifier: Swift.String) -> UIKit.UIView?
  @available(*, unavailable, message: "Use options(for:) with UIView")
  final public func options(forFeatureId identifier: Swift.String) -> MapboxMaps.ViewAnnotationOptions?
  @available(*, deprecated, message: "Use ViewAnnotation properties")
  final public func options(for view: UIKit.UIView) -> MapboxMaps.ViewAnnotationOptions?
  @available(*, deprecated, message: "Use ViewAnnotation")
  final public func addViewAnnotationUpdateObserver(_ observer: any MapboxMaps.ViewAnnotationUpdateObserver)
  @available(*, deprecated, message: "Use ViewAnnotation")
  final public func removeViewAnnotationUpdateObserver(_ observer: any MapboxMaps.ViewAnnotationUpdateObserver)
  final public func camera(forAnnotations annotations: [MapboxMaps.ViewAnnotation], padding: UIKit.UIEdgeInsets = .zero, bearing: CoreFoundation.CGFloat? = nil, pitch: CoreFoundation.CGFloat? = nil) -> MapboxMaps.CameraOptions?
  @available(*, deprecated, message: "Use camera(forAnnotations:...) that works with array of ViewAnnotation")
  final public func camera(forAnnotations identifiers: [Swift.String], padding: UIKit.UIEdgeInsets = .zero, bearing: CoreFoundation.CGFloat? = nil, pitch: CoreFoundation.CGFloat? = nil) -> MapboxMaps.CameraOptions?
}
public struct ViewAnnotationOptions : Swift.Equatable {
  @available(*, unavailable, message: "Use annotatedFeature instead.")
  public var geometry: MapboxMaps.Geometry? {
    get
  }
  public var annotatedFeature: MapboxMaps.AnnotatedFeature?
  public var width: CoreFoundation.CGFloat?
  public var height: CoreFoundation.CGFloat?
  @available(*, unavailable, message: "Use annotatedFeature instead.")
  public var associatedFeatureId: Swift.String? {
    get
  }
  public var allowOverlap: Swift.Bool?
  public var allowOverlapWithPuck: Swift.Bool?
  public var visible: Swift.Bool?
  public var variableAnchors: [MapboxCoreMaps.ViewAnnotationAnchorConfig]?
  @available(*, unavailable, message: "Use variableAnchors instead.")
  public var anchor: MapboxCoreMaps.ViewAnnotationAnchor? {
    get
  }
  @available(*, unavailable, message: "Use variableAnchors instead.")
  public var offsetX: CoreFoundation.CGFloat? {
    get
  }
  @available(*, unavailable, message: "Use variableAnchors instead.")
  public var offsetY: CoreFoundation.CGFloat? {
    get
  }
  public var selected: Swift.Bool?
  public var ignoreCameraPadding: Swift.Bool?
  public init(annotatedFeature: MapboxMaps.AnnotatedFeature? = nil, width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil, allowOverlap: Swift.Bool? = nil, allowOverlapWithPuck: Swift.Bool? = nil, visible: Swift.Bool? = nil, selected: Swift.Bool? = nil, variableAnchors: [MapboxCoreMaps.ViewAnnotationAnchorConfig]? = nil, ignoreCameraPadding: Swift.Bool? = nil)
  @available(*, deprecated, message: "Use ViewAnnotation to create view annotations.")
  public init(geometry: (any Turf.GeometryConvertible)? = nil, width: CoreFoundation.CGFloat? = nil, height: CoreFoundation.CGFloat? = nil, associatedFeatureId: Swift.String? = nil, allowOverlap: Swift.Bool? = nil, visible: Swift.Bool? = nil, anchor: MapboxCoreMaps.ViewAnnotationAnchor? = nil, offsetX: CoreFoundation.CGFloat? = nil, offsetY: CoreFoundation.CGFloat? = nil, selected: Swift.Bool? = nil)
  public static func == (a: MapboxMaps.ViewAnnotationOptions, b: MapboxMaps.ViewAnnotationOptions) -> Swift.Bool
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public struct Viewport : Swift.Equatable {
  @_spi(Experimental) @_documentation(visibility: public) public struct OverviewOptions : Swift.Equatable {
    @_spi(Experimental) @_documentation(visibility: public) public var geometry: MapboxMaps.Geometry
    @_spi(Experimental) @_documentation(visibility: public) public var bearing: CoreFoundation.CGFloat
    @_spi(Experimental) @_documentation(visibility: public) public var pitch: CoreFoundation.CGFloat
    @_spi(Experimental) @_documentation(visibility: public) public var geometryPadding: SwiftUI.EdgeInsets
    @_spi(Experimental) @_documentation(visibility: public) public var maxZoom: Swift.Double?
    @_spi(Experimental) @_documentation(visibility: public) public var offset: CoreFoundation.CGPoint?
    @_spi(Experimental) public static func == (a: MapboxMaps.Viewport.OverviewOptions, b: MapboxMaps.Viewport.OverviewOptions) -> Swift.Bool
  }
  @_spi(Experimental) @_documentation(visibility: public) public struct FollowPuckOptions : Swift.Equatable {
    @_spi(Experimental) @_documentation(visibility: public) public var zoom: CoreFoundation.CGFloat
    @_spi(Experimental) @_documentation(visibility: public) public var bearing: MapboxMaps.FollowPuckViewportStateBearing
    @_spi(Experimental) @_documentation(visibility: public) public var pitch: CoreFoundation.CGFloat
    @_spi(Experimental) public static func == (a: MapboxMaps.Viewport.FollowPuckOptions, b: MapboxMaps.Viewport.FollowPuckOptions) -> Swift.Bool
  }
  @_spi(Experimental) @_documentation(visibility: public) public var padding: SwiftUI.EdgeInsets
  @_spi(Experimental) @_documentation(visibility: public) public static var idle: MapboxMaps.Viewport {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static var styleDefault: MapboxMaps.Viewport {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static func camera(center: CoreLocation.CLLocationCoordinate2D? = nil, anchor: CoreFoundation.CGPoint? = nil, zoom: CoreFoundation.CGFloat? = nil, bearing: CoreLocation.CLLocationDirection? = nil, pitch: CoreFoundation.CGFloat? = nil) -> MapboxMaps.Viewport
  @_spi(Experimental) @_documentation(visibility: public) public static func overview(geometry: any Turf.GeometryConvertible, bearing: CoreFoundation.CGFloat = 0, pitch: CoreFoundation.CGFloat = 0, geometryPadding: SwiftUI.EdgeInsets = .init(), maxZoom: Swift.Double? = nil, offset: CoreFoundation.CGPoint? = nil) -> MapboxMaps.Viewport
  @_spi(Experimental) @_documentation(visibility: public) public static func followPuck(zoom: CoreFoundation.CGFloat, bearing: MapboxMaps.FollowPuckViewportStateBearing = .constant(0), pitch: CoreFoundation.CGFloat = 0) -> MapboxMaps.Viewport
  @_spi(Experimental) @available(*, deprecated, renamed: "padding")
  public func inset(by insets: SwiftUI.EdgeInsets, ignoringSafeArea: SwiftUI.Edge.Set = []) -> MapboxMaps.Viewport
  @_spi(Experimental) @available(*, unavailable, renamed: "padding")
  public func inset(edges: SwiftUI.Edge.Set, length: CoreFoundation.CGFloat, ignoringSafeArea: Swift.Bool = false) -> MapboxMaps.Viewport
  @_spi(Experimental) @_documentation(visibility: public) public func padding(_ padding: SwiftUI.EdgeInsets) -> MapboxMaps.Viewport
  @_spi(Experimental) @_documentation(visibility: public) public func padding(_ edges: SwiftUI.Edge.Set = .all, _ length: CoreFoundation.CGFloat) -> MapboxMaps.Viewport
  @_spi(Experimental) @_documentation(visibility: public) public var isIdle: Swift.Bool {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var isStyleDefault: Swift.Bool {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var camera: MapboxMaps.CameraOptions? {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var overview: MapboxMaps.Viewport.OverviewOptions? {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public var followPuck: MapboxMaps.Viewport.FollowPuckOptions? {
    @_spi(Experimental) get
  }
  @_spi(Experimental) public static func == (a: MapboxMaps.Viewport, b: MapboxMaps.Viewport) -> Swift.Bool
}
@_spi(Experimental) @_documentation(visibility: public) public struct ViewportAnimation {
  @_spi(Experimental) @_documentation(visibility: public) public typealias ViewportTransitionFactory = (MapboxMaps.MapView) -> any MapboxMaps.ViewportTransition
  @_spi(Experimental) @_documentation(visibility: public) public var makeViewportTransition: MapboxMaps.ViewportAnimation.ViewportTransitionFactory
  @_spi(Experimental) @_documentation(visibility: public) public static var `default`: MapboxMaps.ViewportAnimation {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static func `default`(maxDuration: Foundation.TimeInterval) -> MapboxMaps.ViewportAnimation
  @_spi(Experimental) @_documentation(visibility: public) public static var fly: MapboxMaps.ViewportAnimation {
    @_spi(Experimental) get
  }
  @_spi(Experimental) @_documentation(visibility: public) public static func fly(duration: Foundation.TimeInterval) -> MapboxMaps.ViewportAnimation
  @_spi(Experimental) @_documentation(visibility: public) public static func easeOut(duration: Foundation.TimeInterval) -> MapboxMaps.ViewportAnimation
  @_spi(Experimental) @_documentation(visibility: public) public static func easeIn(duration: Foundation.TimeInterval) -> MapboxMaps.ViewportAnimation
  @_spi(Experimental) @_documentation(visibility: public) public static func easeInOut(duration: Foundation.TimeInterval) -> MapboxMaps.ViewportAnimation
  @_spi(Experimental) @_documentation(visibility: public) public static func linear(duration: Foundation.TimeInterval) -> MapboxMaps.ViewportAnimation
}
@_spi(Experimental) @available(iOS 13.0, *)
@_documentation(visibility: public) public func withViewportAnimation<Result>(_ animation: MapboxMaps.ViewportAnimation = .default, body: () throws -> Result, completion: ((Swift.Bool) -> Swift.Void)? = nil) rethrows -> Result
@_hasMissingDesignatedInitializers final public class ViewportManager {
  final public var options: MapboxMaps.ViewportOptions {
    get
    set
  }
  final public var status: MapboxMaps.ViewportStatus {
    get
  }
  final public func addStatusObserver(_ observer: any MapboxMaps.ViewportStatusObserver)
  final public func removeStatusObserver(_ observer: any MapboxMaps.ViewportStatusObserver)
  final public func idle()
  final public func transition(to toState: any MapboxMaps.ViewportState, transition: (any MapboxMaps.ViewportTransition)? = nil, completion: ((_ success: Swift.Bool) -> Swift.Void)? = nil)
  final public var defaultTransition: any MapboxMaps.ViewportTransition {
    get
    set
  }
  @_spi(Experimental) @_documentation(visibility: public) final public func makeCameraViewportState(camera: MapboxMaps.CameraOptions) -> any MapboxMaps.ViewportState
  final public func makeFollowPuckViewportState(options: MapboxMaps.FollowPuckViewportStateOptions = .init()) -> MapboxMaps.FollowPuckViewportState
  final public func makeOverviewViewportState(options: MapboxMaps.OverviewViewportStateOptions) -> MapboxMaps.OverviewViewportState
  final public func makeDefaultViewportTransition(options: MapboxMaps.DefaultViewportTransitionOptions = .init()) -> MapboxMaps.DefaultViewportTransition
  final public func makeImmediateViewportTransition() -> MapboxMaps.ImmediateViewportTransition
  @objc deinit
}
public struct ViewportOptions : Swift.Hashable {
  public var transitionsToIdleUponUserInteraction: Swift.Bool
  @_spi(Experimental) @_documentation(visibility: public) public var usesSafeAreaInsetsAsPadding: Swift.Bool
  public init(transitionsToIdleUponUserInteraction: Swift.Bool = true)
  @_spi(Experimental) @_documentation(visibility: public) public init(transitionsToIdleUponUserInteraction: Swift.Bool, usesSafeAreaInsetsAsPadding: Swift.Bool)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.ViewportOptions, b: MapboxMaps.ViewportOptions) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ViewportState : AnyObject {
  func observeDataSource(with handler: @escaping (_ camera: MapboxMaps.CameraOptions) -> Swift.Bool) -> any MapboxCommon.Cancelable
  func startUpdatingCamera()
  func stopUpdatingCamera()
}
public enum ViewportStatus : Swift.Hashable {
  case idle
  case state(_: any MapboxMaps.ViewportState)
  case transition(_: any MapboxMaps.ViewportTransition, toState: any MapboxMaps.ViewportState)
  public static func == (lhs: MapboxMaps.ViewportStatus, rhs: MapboxMaps.ViewportStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ViewportStatusObserver : AnyObject {
  func viewportStatusDidChange(from fromStatus: MapboxMaps.ViewportStatus, to toStatus: MapboxMaps.ViewportStatus, reason: MapboxMaps.ViewportStatusChangeReason)
}
public struct ViewportStatusChangeReason : Swift.Hashable {
  public static let idleRequested: MapboxMaps.ViewportStatusChangeReason
  public static let transitionStarted: MapboxMaps.ViewportStatusChangeReason
  public static let transitionSucceeded: MapboxMaps.ViewportStatusChangeReason
  public static let transitionFailed: MapboxMaps.ViewportStatusChangeReason
  public static let userInteraction: MapboxMaps.ViewportStatusChangeReason
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: MapboxMaps.ViewportStatusChangeReason, b: MapboxMaps.ViewportStatusChangeReason) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public protocol ViewportTransition : AnyObject {
  func run(to toState: any MapboxMaps.ViewportState, completion: @escaping (_ success: Swift.Bool) -> Swift.Void) -> any MapboxCommon.Cancelable
}
extension MapboxMaps.PointAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.CircleAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.PanMode : Swift.Hashable {}
extension MapboxMaps.PanMode : Swift.RawRepresentable {}
extension MapboxMaps.PuckBearing : Swift.Hashable {}
extension MapboxMaps.OrnamentPosition : Swift.Hashable {}
extension MapboxMaps.OrnamentPosition : Swift.RawRepresentable {}
extension MapboxMaps.OrnamentVisibility : Swift.Hashable {}
extension MapboxMaps.OrnamentVisibility : Swift.RawRepresentable {}
extension MapboxMaps.PolygonAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.PolylineAnnotationManager : MapboxMaps.AnnotationManager {}
extension MapboxMaps.Visibility : Swift.Equatable {}
extension MapboxMaps.Visibility : Swift.Hashable {}
extension MapboxMaps.Visibility : Swift.RawRepresentable {}
